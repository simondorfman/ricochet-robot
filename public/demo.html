<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Ricochet Robot Bidding Demo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <style>
    body { font-family: system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif; margin: 2rem; background: #f7f7f7; }
    h1 { margin-bottom: 0.5rem; }
    fieldset { border: 1px solid #ccc; padding: 1rem; margin-bottom: 1.5rem; background: #fff; }
    label { display: block; margin-bottom: 0.5rem; }
    input, select, button { padding: 0.5rem; font-size: 1rem; }
    .status { font-size: 1.25rem; margin: 0.5rem 0; }
    .timer { font-size: 2rem; font-weight: bold; }
    ul { padding-left: 1.5rem; }
    .columns { display: flex; flex-wrap: wrap; gap: 1.5rem; }
    .columns > div { flex: 1 1 250px; }
    table { width: 100%; border-collapse: collapse; }
    th, td { border: 1px solid #ddd; padding: 0.5rem; text-align: left; }
    .error { color: #b00020; }
    .message { margin-left: 1rem; font-size: 0.9rem; color: #333; }
    .message.error { color: #b00020; }
    .leading-panel { margin-top: 0.75rem; padding: 0.75rem; background: #e9f5ff; border: 1px solid #9cc9f1; border-radius: 4px; }
    .leading-panel strong { font-weight: 600; }
    #bids { list-style: none; padding-left: 0; }
    #bids li { margin-bottom: 0.35rem; padding: 0.35rem 0.5rem; border-radius: 4px; background: #fff; border: 1px solid #eee; }
    #bids li.bid-tie { border-color: #c5d6f2; background: #f2f6ff; font-weight: 600; }
    #bids li.bid-leading { border-color: #58a55c; background: #e6f6e6; color: #1f6e25; }
    .verifying-panel { margin-top: 1rem; padding: 0.75rem; background: #fff4e5; border: 1px solid #f5c48b; border-radius: 4px; }
    .verifying-panel h3 { margin: 0 0 0.5rem; font-size: 1.1rem; }
    #verifying-current { font-weight: 600; margin-bottom: 0.5rem; }
    #verifying-queue { list-style: decimal inside; padding-left: 1rem; margin: 0; }
    #verifying-queue li { padding: 0.25rem 0; }
    #verifying-queue li.current { font-weight: 700; color: #a05a00; }
    #verifying-queue li.empty { list-style: none; font-style: italic; color: #555; }
    .verify-buttons { margin-top: 0.75rem; display: flex; flex-wrap: wrap; gap: 0.5rem; align-items: center; }
    .board-wrapper { display: flex; flex-wrap: wrap; gap: 1.5rem; align-items: flex-start; }
    #board { --cell-count: 16; background: #fff; border: 2px solid #d0d5dd; border-radius: 10px; flex: 1 1 320px; max-width: 480px; padding: 0.5rem; outline: none; box-shadow: 0 10px 30px rgba(15, 23, 42, 0.08); }
    #board:focus-visible { box-shadow: 0 0 0 4px rgba(59, 130, 246, 0.35), 0 10px 30px rgba(15, 23, 42, 0.1); }
    .board.is-focused { box-shadow: 0 0 0 4px rgba(59, 130, 246, 0.25), 0 10px 30px rgba(15, 23, 42, 0.1); }
    .board-surface { position: relative; width: 100%; padding-bottom: 100%; }
    .board-grid, .robot-layer { position: absolute; inset: 0; }
    .board-grid { display: grid; grid-template-columns: repeat(16, 1fr); grid-template-rows: repeat(16, 1fr); }
    .board-cell { border: 1px solid #d1d5db; background: #fdfdfd; position: relative; }
    .board-cell.wall-top { border-top-width: 4px; border-top-color: #1f2937; }
    .board-cell.wall-bottom { border-bottom-width: 4px; border-bottom-color: #1f2937; }
    .board-cell.wall-left { border-left-width: 4px; border-left-color: #1f2937; }
    .board-cell.wall-right { border-right-width: 4px; border-right-color: #1f2937; }
    .board-cell.is-selected::after { content: ''; position: absolute; inset: 3px; border-radius: 6px; border: 2px solid rgba(59, 130, 246, 0.8); pointer-events: none; }
    .robot-layer { pointer-events: none; }
    .robot { pointer-events: auto; position: absolute; width: calc(100% / var(--cell-count) - 6px); height: calc(100% / var(--cell-count) - 6px); transform: translate(calc(var(--col) * 100% / var(--cell-count) + 3px), calc(var(--row) * 100% / var(--cell-count) + 3px)); transition: transform 160ms ease; border-radius: 50%; display: flex; align-items: center; justify-content: center; font-weight: 700; color: #fff; box-shadow: 0 6px 14px rgba(15, 23, 42, 0.2); user-select: none; }
    .robot-label { font-size: 0.9rem; text-transform: uppercase; letter-spacing: 0.05em; }
    .robot-blue { background: linear-gradient(135deg, #2563eb, #1d4ed8); }
    .robot-green { background: linear-gradient(135deg, #16a34a, #0f7a37); }
    .robot-red { background: linear-gradient(135deg, #dc2626, #b91c1c); }
    .robot-yellow { background: linear-gradient(135deg, #f59e0b, #d97706); color: #1f2937; }
    .robot.is-selected { box-shadow: 0 0 0 3px #fff, 0 0 0 6px rgba(59, 130, 246, 0.65); }
    .board-sidebar { flex: 1 1 220px; max-width: 320px; display: flex; flex-direction: column; gap: 1rem; }
    .board-selection { font-weight: 600; font-size: 1rem; }
    .robot-badges { display: flex; flex-wrap: wrap; gap: 0.5rem; }
    .robot-badge { border-radius: 999px; padding: 0.4rem 0.9rem; border: 1px solid #d1d5db; background: #fff; font-weight: 600; cursor: pointer; transition: transform 120ms ease, box-shadow 120ms ease; }
    .robot-badge:hover, .robot-badge:focus-visible { transform: translateY(-1px); box-shadow: 0 6px 12px rgba(59, 130, 246, 0.2); outline: none; }
    .robot-badge-blue { color: #1d4ed8; }
    .robot-badge-green { color: #0f7a37; }
    .robot-badge-red { color: #b91c1c; }
    .robot-badge-yellow { color: #b45309; }
    .robot-badge.is-selected { box-shadow: 0 0 0 2px rgba(59, 130, 246, 0.4); }
    .arrow-controls { display: grid; grid-template-columns: repeat(3, 48px); grid-template-rows: repeat(3, 48px); gap: 0.35rem; justify-content: flex-start; justify-items: center; align-items: center; }
    .arrow-button { border: 1px solid #d1d5db; background: #fff; border-radius: 12px; font-size: 1.25rem; font-weight: 600; display: flex; align-items: center; justify-content: center; cursor: pointer; transition: transform 120ms ease, box-shadow 120ms ease; }
    .arrow-button:hover, .arrow-button:focus-visible { transform: translateY(-1px); box-shadow: 0 8px 20px rgba(59, 130, 246, 0.25); outline: none; }
    .arrow-button.arrow-up { grid-column: 2; grid-row: 1; }
    .arrow-button.arrow-left { grid-column: 1; grid-row: 2; }
    .arrow-button.arrow-right { grid-column: 3; grid-row: 2; }
    .arrow-button.arrow-down { grid-column: 2; grid-row: 3; }
    .board-help { background: #f9fafb; border: 1px solid #e5e7eb; border-radius: 8px; padding: 0.75rem 1rem; font-size: 0.95rem; }
    .board-help summary { font-weight: 600; cursor: pointer; list-style: none; }
    .board-help summary::-webkit-details-marker { display: none; }
    .board-help summary::after { content: '⌄'; float: right; transform: rotate(0deg); transition: transform 120ms ease; }
    .board-help[open] summary::after { transform: rotate(180deg); }
    .board-help ul { margin: 0.75rem 0 0; padding-left: 1.25rem; }
    .board-help li { margin-bottom: 0.35rem; }
    .toast { position: fixed; bottom: 1.5rem; left: 50%; transform: translateX(-50%) translateY(16px); background: #111827; color: #fff; padding: 0.75rem 1.25rem; border-radius: 999px; box-shadow: 0 16px 32px rgba(15, 23, 42, 0.2); opacity: 0; pointer-events: none; transition: opacity 150ms ease, transform 150ms ease; z-index: 1000; font-weight: 600; }
    .toast.toast--visible { opacity: 1; transform: translateX(-50%) translateY(0); }
    .toast.toast--error { background: #b91c1c; }
    .toast.toast--info { background: #2563eb; }
    @media (max-width: 960px) {
      body { margin: 1.25rem; }
      .board-wrapper { flex-direction: column; }
      #board { flex: 1 1 auto; width: 100%; max-width: none; }
      .board-sidebar { width: 100%; max-width: none; }
    }
    @media (max-width: 540px) {
      .arrow-controls { grid-template-columns: repeat(3, 40px); grid-template-rows: repeat(3, 40px); }
      .arrow-button { font-size: 1rem; }
      .robot { font-size: 0.85rem; }
    }
  </style>
  <script src="js/polling.js" defer></script>
</head>
<body>
  <h1>Ricochet Robot Bidding Demo</h1>
  <p>Use this page to experiment with the server-authoritative bidding timer. Join the same room code in two tabs to observe live updates.</p>

  <fieldset>
    <legend>Join Room</legend>
    <form id="join-form">
      <label>
        Room code
        <input id="room-code" type="text" required minlength="1" maxlength="12" autocomplete="off">
      </label>
      <label>
        Player ID
        <input id="player-id" type="number" required min="1" step="1">
      </label>
      <label>
        Player Name (optional)
        <input id="player-name" type="text" maxlength="32" autocomplete="off">
      </label>
      <label>
        Polling mode
        <select id="polling-mode">
          <option value="adaptive">Adaptive short polling</option>
          <option value="long">Long polling</option>
        </select>
      </label>
      <button type="submit">Create / Connect</button>
      <span id="join-message" class="message" aria-live="polite"></span>
    </form>
  </fieldset>

  <fieldset>
    <legend>Current Round</legend>
    <div class="status">
      Status: <span id="status">—</span> (state version <span id="state-version">0</span>)
    </div>
    <div class="timer">
      Time Remaining: <span id="remaining">—</span>
    </div>
    <div>
      Lowest Bid: <span id="low-bid">—</span>
      <span id="low-bidder"></span>
    </div>
    <div id="leading-info" class="leading-panel" hidden>
      <strong>Leading:</strong>
      <span id="leading-text"></span>
    </div>
    <div id="verifying-container" class="verifying-panel" hidden>
      <h3>Verification Queue</h3>
      <div id="verifying-current">Current: —</div>
      <ol id="verifying-queue"></ol>
      <div class="verify-buttons">
        <button type="button" id="verify-pass">Pass</button>
        <button type="button" id="verify-fail">Fail</button>
        <span id="verify-message" class="message" aria-live="polite"></span>
      </div>
    </div>
  </fieldset>

  <fieldset>
    <legend>Board &amp; Controls</legend>
    <div class="board-wrapper">
      <div id="board" class="board" tabindex="0" aria-label="Ricochet Robot board">
        <div class="board-surface">
          <div id="board-grid" class="board-grid" aria-hidden="true"></div>
          <div id="robot-layer" class="robot-layer" aria-hidden="true"></div>
        </div>
      </div>
      <div class="board-sidebar">
        <div id="board-selection" class="board-selection" aria-live="polite">Selected robot: —</div>
        <div id="robot-badges" class="robot-badges" role="group" aria-label="Select robot"></div>
        <div id="arrow-controls" class="arrow-controls" role="group" aria-label="Move robot">
          <button type="button" class="arrow-button arrow-up" data-dir="UP" aria-label="Move up">↑</button>
          <button type="button" class="arrow-button arrow-left" data-dir="LEFT" aria-label="Move left">←</button>
          <button type="button" class="arrow-button arrow-right" data-dir="RIGHT" aria-label="Move right">→</button>
          <button type="button" class="arrow-button arrow-down" data-dir="DOWN" aria-label="Move down">↓</button>
        </div>
        <details class="board-help" open>
          <summary>Keyboard tips</summary>
          <ul>
            <li><strong>Bid:</strong> Type digits, press Enter</li>
            <li><strong>Select robot:</strong> Tab / Shift+Tab or click a badge</li>
            <li><strong>Move:</strong> Arrow keys or W/A/S/D</li>
            <li><strong>Clear bid:</strong> Esc</li>
          </ul>
        </details>
      </div>
    </div>
  </fieldset>

  <div class="columns">
    <div>
      <h2>Recent Bids</h2>
      <ul id="bids"></ul>
    </div>
    <div>
      <h2>Leaderboard</h2>
      <table>
        <thead>
          <tr>
            <th>Player</th>
            <th>Tokens</th>
          </tr>
        </thead>
        <tbody id="leaderboard"></tbody>
      </table>
    </div>
  </div>

  <fieldset>
    <legend>Submit Bid</legend>
    <form id="bid-form">
      <label>
        Bid value
        <input id="bidInput" inputmode="numeric" autocomplete="off" autocapitalize="off" spellcheck="false" autofocus>
      </label>
      <button type="submit">Submit Bid</button>
      <span id="bid-message" class="message" aria-live="polite"></span>
    </form>
  </fieldset>

  <div id="toast" class="toast" aria-live="polite" aria-atomic="true"></div>

  <script>
    (function () {
      const joinForm = document.getElementById('join-form');
      const bidForm = document.getElementById('bid-form');
      const roomCodeInput = document.getElementById('room-code');
      const playerIdInput = document.getElementById('player-id');
      const playerNameInput = document.getElementById('player-name');
      const pollingModeInput = document.getElementById('polling-mode');
      const joinMessage = document.getElementById('join-message');
      const bidMessage = document.getElementById('bid-message');
      const joinButton = joinForm.querySelector('button[type="submit"]');
      const bidButton = bidForm.querySelector('button[type="submit"]');
      const bidInput = document.getElementById('bidInput');

      const statusEl = document.getElementById('status');
      const versionEl = document.getElementById('state-version');
      const remainingEl = document.getElementById('remaining');
      const lowBidEl = document.getElementById('low-bid');
      const lowBidderEl = document.getElementById('low-bidder');
      const leadingPanel = document.getElementById('leading-info');
      const leadingText = document.getElementById('leading-text');
      const bidsEl = document.getElementById('bids');
      const leaderboardEl = document.getElementById('leaderboard');
      const verifyingContainer = document.getElementById('verifying-container');
      const verifyingCurrent = document.getElementById('verifying-current');
      const verifyingQueueList = document.getElementById('verifying-queue');
      const verifyPassButton = document.getElementById('verify-pass');
      const verifyFailButton = document.getElementById('verify-fail');
      const verifyMessage = document.getElementById('verify-message');
      const boardEl = document.getElementById('board');
      const boardGridEl = document.getElementById('board-grid');
      const robotLayerEl = document.getElementById('robot-layer');
      const robotBadgesEl = document.getElementById('robot-badges');
      const arrowControlsEl = document.getElementById('arrow-controls');
      const boardSelectionEl = document.getElementById('board-selection');
      const toastEl = document.getElementById('toast');

      let poller = null;
      let currentRoomCode = null;
      let currentPlayerId = null;
      let lastServerRemaining = null;
      let lastServerTimestamp = null;
      let serverSkewMs = 0;
      let hasServerSkew = false;
      let countdownTimerId = null;
      let bidAllowed = false;
      let bidInFlight = false;
      let lastVerifyingState = null;
      let verifyInFlight = false;
      const BOARD_SIZE = 16;
      const ROBOT_ORDER = ['Blue', 'Green', 'Red', 'Yellow'];
      const ROBOT_META = {
        Blue: { id: 'blue', robotClass: 'robot-blue', badgeClass: 'robot-badge-blue', shortLabel: 'B' },
        Green: { id: 'green', robotClass: 'robot-green', badgeClass: 'robot-badge-green', shortLabel: 'G' },
        Red: { id: 'red', robotClass: 'robot-red', badgeClass: 'robot-badge-red', shortLabel: 'R' },
        Yellow: { id: 'yellow', robotClass: 'robot-yellow', badgeClass: 'robot-badge-yellow', shortLabel: 'Y' }
      };
      const INITIAL_ROBOT_POSITIONS = {
        Blue: { row: 1, col: 1 },
        Green: { row: 1, col: 14 },
        Red: { row: 14, col: 1 },
        Yellow: { row: 14, col: 14 }
      };
      const STATIC_WALL_DATA = {
        '0,3': [0, 0, 0, 1],
        '0,9': [0, 0, 0, 1],
        '1,13': [0, 1, 0, 1],
        '1,15': [0, 1, 0, 0],
        '2,5': [0, 1, 0, 1],
        '3,9': [1, 0, 1, 0],
        '4,0': [0, 1, 0, 0],
        '4,2': [1, 0, 0, 1],
        '4,14': [1, 0, 0, 1],
        '5,7': [0, 1, 1, 0],
        '6,1': [1, 0, 1, 0],
        '6,12': [0, 1, 1, 0],
        '7,7': [1, 0, 1, 0],
        '7,8': [1, 0, 0, 1],
        '8,7': [0, 1, 1, 0],
        '8,8': [0, 1, 0, 1],
        '8,12': [1, 0, 1, 0],
        '9,3': [0, 1, 0, 1],
        '9,10': [0, 1, 1, 0],
        '10,0': [0, 1, 0, 0],
        '10,15': [0, 1, 0, 0],
        '11,5': [1, 0, 1, 0],
        '11,9': [0, 1, 0, 1],
        '12,14': [1, 0, 0, 1],
        '13,1': [0, 1, 1, 0],
        '14,6': [1, 0, 0, 1],
        '14,13': [1, 0, 1, 0],
        '15,4': [0, 0, 0, 1],
        '15,10': [0, 0, 0, 1]
      };
      const CENTER_CELLS = [[7, 7], [7, 8], [8, 7], [8, 8]];
      const KEY_TO_DIR = {
        ArrowUp: 'UP',
        ArrowDown: 'DOWN',
        ArrowLeft: 'LEFT',
        ArrowRight: 'RIGHT',
        w: 'UP',
        s: 'DOWN',
        a: 'LEFT',
        d: 'RIGHT'
      };
      const WALL_RELATIONS = {
        top: { dr: -1, dc: 0, opposite: 'bottom' },
        bottom: { dr: 1, dc: 0, opposite: 'top' },
        left: { dr: 0, dc: -1, opposite: 'right' },
        right: { dr: 0, dc: 1, opposite: 'left' }
      };
      const boardWalls = new Map();
      const robotState = {};
      let boardActive = false;
      let robotIdx = 0;
      let toastTimeoutId = null;

      function setMessage(element, text, isError) {
        if (!element) {
          return;
        }
        element.textContent = text || '';
        if (isError) {
          element.classList.add('error');
        } else {
          element.classList.remove('error');
        }
      }

      function updateBidFormState() {
        const inputEnabled = bidAllowed && !bidInFlight;
        if (bidInput) {
          bidInput.disabled = !inputEnabled;
        }
        bidButton.disabled = !bidAllowed || bidInFlight;
      }

      function setBidFormEnabled(enabled) {
        bidAllowed = Boolean(enabled);
        updateBidFormState();
        if (!bidAllowed && bidInput) {
          bidInput.blur();
        }
        if (bidAllowed && !bidInFlight && bidInput) {
          window.requestAnimationFrame(function () {
            if (document.activeElement !== bidInput && !bidInput.disabled) {
              bidInput.focus({ preventScroll: true });
            }
          });
        }
      }

      if (bidInput) {
        bidInput.addEventListener('input', function (event) {
          const digits = event.target.value.replace(/\D+/g, '').slice(0, 3);
          if (event.target.value !== digits) {
            event.target.value = digits;
          }
        });
        bidInput.addEventListener('keydown', function (event) {
          if (event.key === 'Enter') {
            event.preventDefault();
            submitBid();
          } else if (event.key === 'Escape') {
            event.preventDefault();
            bidInput.value = '';
            setMessage(bidMessage, '', false);
          }
        });
      }

      function getCurrentVerifier() {
        if (!lastVerifyingState || !Array.isArray(lastVerifyingState.queue)) {
          return null;
        }

        const index = Number.isInteger(lastVerifyingState.currentIndex)
          ? lastVerifyingState.currentIndex
          : 0;

        if (index < 0) {
          return null;
        }

        return lastVerifyingState.queue[index] || null;
      }

      function updateVerifyButtons() {
        const currentEntry = getCurrentVerifier();
        const enabled = Boolean(currentRoomCode && currentEntry && !verifyInFlight);
        verifyPassButton.disabled = !enabled;
        verifyFailButton.disabled = !enabled;
      }

      function stopCountdownTicker() {
        if (countdownTimerId != null) {
          clearInterval(countdownTimerId);
          countdownTimerId = null;
        }
      }

      function updateCountdownDisplay() {
        const remaining = estimateRemaining();
        if (remaining == null) {
          remainingEl.textContent = '—';
          return;
        }
        remainingEl.textContent = formatSeconds(remaining);
        if (remaining <= 0) {
          stopCountdownTicker();
        }
      }

      function startCountdownTicker() {
        updateCountdownDisplay();
        if (countdownTimerId == null) {
          countdownTimerId = setInterval(updateCountdownDisplay, 250);
        }
      }

      function formatSeconds(seconds) {
        if (seconds == null) {
          return '—';
        }
        const s = Math.max(0, Math.floor(seconds));
        const mins = Math.floor(s / 60);
        const secs = s % 60;
        return mins > 0 ? `${mins}:${secs.toString().padStart(2, '0')}` : `${secs}`;
      }

      function renderAll(state) {
        statusEl.textContent = state.status;
        versionEl.textContent = state.stateVersion;
        lowBidEl.textContent = state.currentLow != null ? state.currentLow : '—';
        lowBidderEl.textContent = state.currentLowBy != null ? `(by ${state.currentLowBy})` : '';

        const currentLow = state.currentLow;
        const leader = state.currentLeader;
        const ties = Array.isArray(state.tiesAtCurrentLow) ? state.tiesAtCurrentLow : [];
        const tieCount = ties.length;

        bidsEl.innerHTML = '';
        let leaderMarked = false;
        (state.bids || []).forEach(function (bid) {
          const li = document.createElement('li');
          const when = bid.createdAt ? new Date(bid.createdAt).toLocaleTimeString() : '—';
          let text = `Player ${bid.playerId} bid ${bid.value} @ ${when}`;

          if (currentLow != null && bid.value === currentLow) {
            li.classList.add('bid-tie');
            if (leader && !leaderMarked && leader.playerId === bid.playerId && leader.value === bid.value) {
              li.classList.add('bid-leading');
              text += ' (leading)';
              leaderMarked = true;
            } else if (tieCount > 1) {
              text += ' (tied)';
            }
          }

          li.textContent = text;
          bidsEl.appendChild(li);
        });

        leaderboardEl.innerHTML = '';
        (state.leaderboard || []).forEach(function (row) {
          const tr = document.createElement('tr');
          const nameCell = document.createElement('td');
          nameCell.textContent = row.name ? `${row.name} (${row.playerId})` : row.playerId;
          const tokensCell = document.createElement('td');
          let tokensValue = null;
          if (Number.isFinite(row.tokensWon)) {
            tokensValue = row.tokensWon;
          } else if (Number.isFinite(row.points)) {
            tokensValue = row.points;
          }
          tokensCell.textContent = tokensValue != null ? tokensValue : '0';
          tr.appendChild(nameCell);
          tr.appendChild(tokensCell);
          leaderboardEl.appendChild(tr);
        });

        let verifyingState = null;
        if (state.status === 'verifying' && state.verifying && Array.isArray(state.verifying.queue)) {
          const queueCopy = state.verifying.queue.map(function (entry) {
            return {
              playerId: entry.playerId,
              value: entry.value,
              tokensWon: entry.tokensWon,
              createdAt: entry.createdAt
            };
          });
          const currentIndex = Number.isInteger(state.verifying.currentIndex) ? state.verifying.currentIndex : 0;
          verifyingState = { queue: queueCopy, currentIndex: currentIndex };
        }

        lastVerifyingState = verifyingState;

        if (verifyingState) {
          verifyingContainer.hidden = false;
          verifyingQueueList.innerHTML = '';
          const queue = verifyingState.queue;
          const currentIndex = verifyingState.currentIndex >= 0 ? verifyingState.currentIndex : 0;

          if (queue.length === 0) {
            const emptyLi = document.createElement('li');
            emptyLi.textContent = 'No bids awaiting verification.';
            emptyLi.classList.add('empty');
            verifyingQueueList.appendChild(emptyLi);
          } else {
            queue.forEach(function (entry, index) {
              const li = document.createElement('li');
              const valueText = entry.value != null ? entry.value : '—';
              const tokensText = entry.tokensWon != null ? ` (tokens ${entry.tokensWon})` : '';
              li.textContent = `Player ${entry.playerId} @ ${valueText}${tokensText}`;
              if (index === currentIndex) {
                li.classList.add('current');
              }
              verifyingQueueList.appendChild(li);
            });
          }

          const currentEntry = getCurrentVerifier();
          if (currentEntry) {
            const valueText = currentEntry.value != null ? currentEntry.value : '—';
            const tokensText = currentEntry.tokensWon != null ? ` (tokens ${currentEntry.tokensWon})` : '';
            verifyingCurrent.textContent = `Current: Player ${currentEntry.playerId} @ ${valueText}${tokensText}`;
          } else {
            verifyingCurrent.textContent = 'Current: —';
          }

          updateVerifyButtons();
        } else {
          verifyingContainer.hidden = true;
          verifyingQueueList.innerHTML = '';
          verifyingCurrent.textContent = 'Current: —';
          lastVerifyingState = null;
          verifyInFlight = false;
          updateVerifyButtons();
          setMessage(verifyMessage, '', false);
        }

        if (leader && leader.playerId != null && leader.value != null) {
          const reason = leader.leaderReason || {};
          let reasonText = '';
          if (reason.kind === 'fewer_tokens') {
            const leaderTokens = Number.isFinite(reason.leaderTokens) ? reason.leaderTokens : leader.tokensWon;
            const otherTokens = Number.isFinite(reason.otherBestTokens) ? reason.otherBestTokens : undefined;
            const otherPart = otherTokens != null ? ` vs ${otherTokens}` : '';
            reasonText = `fewer tokens: ${leaderTokens != null ? leaderTokens : '—'}${otherPart}`;
          } else if (reason.kind === 'earlier_bid') {
            let timeText = '';
            if (reason.leaderCreatedAt) {
              const parsed = Date.parse(reason.leaderCreatedAt);
              if (!Number.isNaN(parsed)) {
                timeText = new Date(parsed).toLocaleTimeString();
              }
            }
            const leaderTokens = Number.isFinite(reason.leaderTokens) ? reason.leaderTokens : leader.tokensWon;
            const otherTokens = Number.isFinite(reason.otherBestTokens) ? reason.otherBestTokens : undefined;
            const tokenPart = leaderTokens != null && otherTokens != null ? ` (tokens ${leaderTokens} vs ${otherTokens})` : '';
            reasonText = timeText ? `earlier bid at ${timeText}${tokenPart}` : `earlier bid${tokenPart}`;
          } else if (reason.kind === 'new_low') {
            const leaderTokens = Number.isFinite(reason.leaderTokens) ? reason.leaderTokens : leader.tokensWon;
            reasonText = leaderTokens != null ? `new low bid (tokens ${leaderTokens})` : 'new low bid';
          }

          const baseText = `Player ${leader.playerId} @ ${leader.value}`;
          leadingText.textContent = reasonText ? `${baseText} (reason: ${reasonText})` : baseText;
          leadingPanel.hidden = false;
        } else {
          leadingPanel.hidden = true;
          leadingText.textContent = '';
        }

        lastServerRemaining = typeof state.remaining === 'number' ? state.remaining : null;
        const parsedServerNow = state.serverNow ? Date.parse(state.serverNow) : NaN;
        if (!Number.isNaN(parsedServerNow)) {
          lastServerTimestamp = parsedServerNow;
          if (!hasServerSkew) {
            serverSkewMs = parsedServerNow - Date.now();
            hasServerSkew = true;
          }
        } else {
          lastServerTimestamp = null;
          hasServerSkew = false;
        }

        if (lastServerRemaining == null || !hasServerSkew) {
          stopCountdownTicker();
          remainingEl.textContent = '—';
        } else {
          startCountdownTicker();
        }

        const biddingOpen = state.status === 'bidding' || state.status === 'countdown';
        setBidFormEnabled(Boolean(currentRoomCode && currentPlayerId && biddingOpen));
      }

      function estimateRemaining() {
        if (lastServerRemaining == null || lastServerTimestamp == null) {
          return null;
        }
        const serverNow = Date.now() + (hasServerSkew ? serverSkewMs : 0);
        const elapsed = Math.floor((serverNow - lastServerTimestamp) / 1000);
        return Math.max(0, lastServerRemaining - elapsed);
      }

      joinForm.addEventListener('submit', function (event) {
        event.preventDefault();
        if (!window.PollingHelpers) {
          setMessage(joinMessage, 'Helpers not loaded yet. Please retry.', true);
          return;
        }

        const code = roomCodeInput.value.trim();
        const player = Number(playerIdInput.value);
        const playerName = playerNameInput.value.trim();
        const mode = pollingModeInput.value;

        if (!code || !Number.isFinite(player) || player <= 0) {
          setMessage(joinMessage, 'Enter a room code and player id.', true);
          return;
        }

        setMessage(joinMessage, '', false);
        currentRoomCode = code;
        currentPlayerId = player;
        setMessage(bidMessage, '', false);

        if (poller && typeof poller.stop === 'function') {
          poller.stop();
        }
        poller = null;

        lastServerRemaining = null;
        lastServerTimestamp = null;
        serverSkewMs = 0;
        hasServerSkew = false;
        stopCountdownTicker();
        setBidFormEnabled(false);

        joinButton.disabled = true;

        (async function connect() {
          try {
            const note = await ensureRoomExists(currentRoomCode, playerName);
            let messagePrefix = note ? `${note.trim()} ` : '';

            if (mode === 'long') {
              poller = window.PollingHelpers.createLongPoller({
                code: currentRoomCode,
                renderAll: renderAll
              });
            } else {
              poller = window.PollingHelpers.createAdaptivePoller({
                code: currentRoomCode,
                renderAll: renderAll,
                getRemainingFromUI: estimateRemaining
              });
            }

            const startResult = poller.start();
            if (startResult && typeof startResult.then === 'function') {
              await startResult;
            }

            setMessage(joinMessage, `${messagePrefix}Connected to room ${currentRoomCode}.`.trim(), false);
          } catch (err) {
            console.error(err);
            setMessage(joinMessage, err && err.message ? err.message : 'Unable to connect to the room.', true);
            currentRoomCode = null;
            currentPlayerId = null;
            if (poller && typeof poller.stop === 'function') {
              poller.stop();
            }
            poller = null;
            setBidFormEnabled(false);
          } finally {
            joinButton.disabled = false;
          }
        }());
      });

      bidForm.addEventListener('submit', function (event) {
        event.preventDefault();
        submitBid();
      });

      async function submitBid() {
        setMessage(bidMessage, '', false);
        if (!currentRoomCode || !currentPlayerId) {
          setMessage(bidMessage, 'Join a room first.', true);
          return;
        }
        if (!bidAllowed) {
          setMessage(bidMessage, 'Bidding is closed.', true);
          return;
        }
        const rawValue = bidInput ? bidInput.value.trim() : '';
        if (!rawValue) {
          setMessage(bidMessage, 'Enter a positive bid value.', true);
          return;
        }
        const value = Number.parseInt(rawValue, 10);
        if (!Number.isFinite(value) || value <= 0) {
          setMessage(bidMessage, 'Enter a positive bid value.', true);
          return;
        }
        if (bidInFlight) {
          return;
        }

        bidInFlight = true;
        updateBidFormState();
        try {
          await window.PollingHelpers.submitBid(currentRoomCode, currentPlayerId, value);
          if (bidInput) {
            bidInput.value = '';
            if (!bidInput.disabled) {
              bidInput.focus({ preventScroll: true });
            }
          }
        } catch (err) {
          console.error(err);
          const message = err && err.message ? err.message : 'Bid failed.';
          setMessage(bidMessage, message, true);
          showToast(message, true);
          if (message.toLowerCase().includes('bidding is closed')) {
            setBidFormEnabled(false);
          }
        } finally {
          bidInFlight = false;
          updateBidFormState();
        }
      }

      setBidFormEnabled(false);
      setMessage(verifyMessage, '', false);
      updateVerifyButtons();

      verifyPassButton.addEventListener('click', function () {
        if (!currentRoomCode) {
          setMessage(verifyMessage, 'Join a room first.', true);
          return;
        }

        const currentEntry = getCurrentVerifier();
        if (!currentEntry) {
          setMessage(verifyMessage, 'No verifier available.', true);
          return;
        }

        verifyInFlight = true;
        updateVerifyButtons();
        setMessage(verifyMessage, '', false);

        window.PollingHelpers.verifyPass(currentRoomCode, currentEntry.playerId).then(function () {
          setMessage(verifyMessage, 'Marked as solved.', false);
        }).catch(function (err) {
          console.error(err);
          const message = err && err.message ? err.message : 'Verification update failed.';
          setMessage(verifyMessage, message, true);
        }).finally(function () {
          verifyInFlight = false;
          updateVerifyButtons();
        });
      });

      verifyFailButton.addEventListener('click', function () {
        if (!currentRoomCode) {
          setMessage(verifyMessage, 'Join a room first.', true);
          return;
        }

        const currentEntry = getCurrentVerifier();
        if (!currentEntry) {
          setMessage(verifyMessage, 'No verifier available.', true);
          return;
        }

        verifyInFlight = true;
        updateVerifyButtons();
        setMessage(verifyMessage, '', false);

        window.PollingHelpers.verifyFail(currentRoomCode, currentEntry.playerId).then(function () {
          setMessage(verifyMessage, 'Advanced to next verifier.', false);
        }).catch(function (err) {
          console.error(err);
          const message = err && err.message ? err.message : 'Verification update failed.';
          setMessage(verifyMessage, message, true);
        }).finally(function () {
          verifyInFlight = false;
          updateVerifyButtons();
        });
      });

      function showToast(message, isError) {
        if (!toastEl) {
          return;
        }
        if (toastTimeoutId) {
          clearTimeout(toastTimeoutId);
        }
        toastEl.textContent = message;
        toastEl.setAttribute('aria-live', isError ? 'assertive' : 'polite');
        toastEl.classList.remove('toast--error', 'toast--info', 'toast--visible');
        void toastEl.offsetWidth;
        toastEl.classList.add(isError ? 'toast--error' : 'toast--info');
        toastEl.classList.add('toast--visible');
        toastTimeoutId = window.setTimeout(hideToast, 4000);
      }

      function hideToast() {
        if (!toastEl) {
          return;
        }
        toastEl.classList.remove('toast--visible');
      }

      function ensureCellWall(row, col) {
        if (row < 0 || row >= BOARD_SIZE || col < 0 || col >= BOARD_SIZE) {
          return null;
        }
        const key = `${row},${col}`;
        if (!boardWalls.has(key)) {
          boardWalls.set(key, { top: false, bottom: false, left: false, right: false });
        }
        return boardWalls.get(key);
      }

      function addWall(row, col, side) {
        const cell = ensureCellWall(row, col);
        if (!cell) {
          return;
        }
        cell[side] = true;
        const relation = WALL_RELATIONS[side];
        if (!relation) {
          return;
        }
        const neighborRow = row + relation.dr;
        const neighborCol = col + relation.dc;
        const neighborCell = ensureCellWall(neighborRow, neighborCol);
        if (neighborCell) {
          neighborCell[relation.opposite] = true;
        }
      }

      function buildWallData() {
        boardWalls.clear();
        for (let r = 0; r < BOARD_SIZE; r += 1) {
          for (let c = 0; c < BOARD_SIZE; c += 1) {
            ensureCellWall(r, c);
          }
        }
        Object.entries(STATIC_WALL_DATA).forEach(function ([key, arr]) {
          if (!Array.isArray(arr) || arr.length < 4) {
            return;
          }
          const parts = key.split(',');
          const row = Number.parseInt(parts[0], 10);
          const col = Number.parseInt(parts[1], 10);
          if (!Number.isFinite(row) || !Number.isFinite(col)) {
            return;
          }
          if (arr[0]) {
            addWall(row, col, 'top');
          }
          if (arr[1]) {
            addWall(row, col, 'bottom');
          }
          if (arr[2]) {
            addWall(row, col, 'left');
          }
          if (arr[3]) {
            addWall(row, col, 'right');
          }
        });
        CENTER_CELLS.forEach(function (pair) {
          const row = pair[0];
          const col = pair[1];
          ['top', 'bottom', 'left', 'right'].forEach(function (side) {
            addWall(row, col, side);
          });
        });
      }

      function buildBoardGrid() {
        if (!boardGridEl) {
          return;
        }
        const fragment = document.createDocumentFragment();
        boardGridEl.innerHTML = '';
        for (let r = 0; r < BOARD_SIZE; r += 1) {
          for (let c = 0; c < BOARD_SIZE; c += 1) {
            const cell = document.createElement('div');
            cell.className = 'board-cell';
            cell.dataset.row = String(r);
            cell.dataset.col = String(c);
            const cellWalls = boardWalls.get(`${r},${c}`);
            if (cellWalls) {
              if (cellWalls.top) {
                cell.classList.add('wall-top');
              }
              if (cellWalls.bottom) {
                cell.classList.add('wall-bottom');
              }
              if (cellWalls.left) {
                cell.classList.add('wall-left');
              }
              if (cellWalls.right) {
                cell.classList.add('wall-right');
              }
            }
            fragment.appendChild(cell);
          }
        }
        boardGridEl.appendChild(fragment);
      }

      function initializeRobots() {
        ROBOT_ORDER.forEach(function (name) {
          const start = INITIAL_ROBOT_POSITIONS[name] || { row: 0, col: 0 };
          const clampedRow = Math.max(0, Math.min(BOARD_SIZE - 1, start.row));
          const clampedCol = Math.max(0, Math.min(BOARD_SIZE - 1, start.col));
          robotState[name] = { row: clampedRow, col: clampedCol };
        });
      }

      function renderRobotBadges() {
        if (!robotBadgesEl) {
          return;
        }
        robotBadgesEl.innerHTML = '';
        const fragment = document.createDocumentFragment();
        ROBOT_ORDER.forEach(function (name) {
          const meta = ROBOT_META[name];
          if (!meta) {
            return;
          }
          const button = document.createElement('button');
          button.type = 'button';
          button.className = `robot-badge ${meta.badgeClass}`;
          button.dataset.robot = name;
          button.textContent = name;
          button.setAttribute('aria-pressed', 'false');
          button.addEventListener('click', function () {
            selectRobotByName(name);
            if (boardEl) {
              boardEl.focus({ preventScroll: true });
            }
          });
          fragment.appendChild(button);
        });
        robotBadgesEl.appendChild(fragment);
      }

      function renderRobots() {
        if (!robotLayerEl) {
          return;
        }
        robotLayerEl.innerHTML = '';
        const fragment = document.createDocumentFragment();
        ROBOT_ORDER.forEach(function (name) {
          const state = robotState[name];
          const meta = ROBOT_META[name];
          if (!state || !meta) {
            return;
          }
          const robotEl = document.createElement('div');
          robotEl.className = `robot ${meta.robotClass}`;
          robotEl.dataset.robot = name;
          robotEl.style.setProperty('--row', String(state.row));
          robotEl.style.setProperty('--col', String(state.col));
          robotEl.setAttribute('role', 'img');
          robotEl.setAttribute('aria-label', `${name} robot at row ${state.row} column ${state.col}`);
          robotEl.tabIndex = -1;
          const label = document.createElement('span');
          label.className = 'robot-label';
          label.textContent = meta.shortLabel;
          robotEl.appendChild(label);
          robotEl.addEventListener('click', function () {
            selectRobotByName(name);
            if (boardEl) {
              boardEl.focus({ preventScroll: true });
            }
          });
          fragment.appendChild(robotEl);
        });
        robotLayerEl.appendChild(fragment);
        updateSelectedRobotStyles();
      }

      function highlightSelectedCell() {
        if (!boardGridEl) {
          return;
        }
        boardGridEl.querySelectorAll('.board-cell.is-selected').forEach(function (cell) {
          cell.classList.remove('is-selected');
        });
        const currentName = ROBOT_ORDER[robotIdx];
        const state = robotState[currentName];
        if (!state) {
          return;
        }
        const cell = boardGridEl.querySelector(`.board-cell[data-row="${state.row}"][data-col="${state.col}"]`);
        if (cell) {
          cell.classList.add('is-selected');
        }
      }

      function updateSelectedRobotStyles() {
        const currentName = ROBOT_ORDER[robotIdx];
        if (robotBadgesEl) {
          robotBadgesEl.querySelectorAll('.robot-badge').forEach(function (badge) {
            const isCurrent = badge.dataset.robot === currentName;
            badge.classList.toggle('is-selected', isCurrent);
            badge.setAttribute('aria-pressed', isCurrent ? 'true' : 'false');
          });
        }
        if (robotLayerEl) {
          robotLayerEl.querySelectorAll('.robot').forEach(function (robotEl) {
            const isCurrent = robotEl.dataset.robot === currentName;
            robotEl.classList.toggle('is-selected', isCurrent);
            robotEl.setAttribute('aria-current', isCurrent ? 'true' : 'false');
          });
        }
        if (boardSelectionEl) {
          if (currentName && robotState[currentName]) {
            const pos = robotState[currentName];
            boardSelectionEl.textContent = `Selected robot: ${currentName} (${pos.row}, ${pos.col})`;
          } else {
            boardSelectionEl.textContent = 'Selected robot: —';
          }
        }
        highlightSelectedCell();
      }

      function selectRobotByIndex(index) {
        if (!ROBOT_ORDER.length) {
          return;
        }
        const normalized = ((index % ROBOT_ORDER.length) + ROBOT_ORDER.length) % ROBOT_ORDER.length;
        robotIdx = normalized;
        updateSelectedRobotStyles();
      }

      function selectRobotByName(name) {
        const nextIndex = ROBOT_ORDER.indexOf(name);
        if (nextIndex === -1) {
          return;
        }
        selectRobotByIndex(nextIndex);
      }

      function isRobotAt(row, col, ignoreName) {
        return ROBOT_ORDER.some(function (name) {
          if (name === ignoreName) {
            return false;
          }
          const state = robotState[name];
          return state && state.row === row && state.col === col;
        });
      }

      function hasWall(row, col, side) {
        if (row < 0 || row >= BOARD_SIZE || col < 0 || col >= BOARD_SIZE) {
          return true;
        }
        const cell = boardWalls.get(`${row},${col}`);
        return cell ? Boolean(cell[side]) : false;
      }

      function canMove(row, col, direction) {
        switch (direction) {
          case 'UP':
            return row > 0 && !hasWall(row, col, 'top') && !hasWall(row - 1, col, 'bottom');
          case 'DOWN':
            return row < BOARD_SIZE - 1 && !hasWall(row, col, 'bottom') && !hasWall(row + 1, col, 'top');
          case 'LEFT':
            return col > 0 && !hasWall(row, col, 'left') && !hasWall(row, col - 1, 'right');
          case 'RIGHT':
            return col < BOARD_SIZE - 1 && !hasWall(row, col, 'right') && !hasWall(row, col + 1, 'left');
          default:
            return false;
        }
      }

      function moveOne(row, col, direction) {
        switch (direction) {
          case 'UP':
            return { row: row - 1, col: col };
          case 'DOWN':
            return { row: row + 1, col: col };
          case 'LEFT':
            return { row: row, col: col - 1 };
          case 'RIGHT':
            return { row: row, col: col + 1 };
          default:
            return { row: row, col: col };
        }
      }

      function computeSlide(row, col, direction, ignoreName) {
        let nextRow = row;
        let nextCol = col;
        while (canMove(nextRow, nextCol, direction)) {
          const candidate = moveOne(nextRow, nextCol, direction);
          if (isRobotAt(candidate.row, candidate.col, ignoreName)) {
            break;
          }
          nextRow = candidate.row;
          nextCol = candidate.col;
        }
        return { row: nextRow, col: nextCol };
      }

      function slideSelectedRobot(direction) {
        const currentName = ROBOT_ORDER[robotIdx];
        const state = robotState[currentName];
        if (!state) {
          return;
        }
        const next = computeSlide(state.row, state.col, direction, currentName);
        if (next.row === state.row && next.col === state.col) {
          return;
        }
        state.row = next.row;
        state.col = next.col;
        renderRobots();
      }

      function handleBoardKeydown(event) {
        if (!boardActive) {
          return;
        }
        if (event.key === 'Escape') {
          if (boardEl) {
            boardEl.blur();
          }
          return;
        }
        if (event.key === 'Tab') {
          event.preventDefault();
          const delta = event.shiftKey ? -1 : 1;
          selectRobotByIndex(robotIdx + delta);
          return;
        }
        const key = event.key.length === 1 ? event.key.toLowerCase() : event.key;
        const direction = KEY_TO_DIR[key] || KEY_TO_DIR[event.key];
        if (!direction) {
          return;
        }
        event.preventDefault();
        slideSelectedRobot(direction);
      }

      function handleArrowClick(event) {
        const target = event.target.closest('button[data-dir]');
        if (!target) {
          return;
        }
        const direction = target.getAttribute('data-dir');
        if (!direction) {
          return;
        }
        slideSelectedRobot(direction);
        if (boardEl) {
          boardEl.focus({ preventScroll: true });
        }
      }

      function initBoard() {
        if (!boardEl || !boardGridEl || !robotLayerEl) {
          return;
        }
        if (boardEl.tabIndex < 0) {
          boardEl.tabIndex = 0;
        }
        boardEl.classList.remove('is-focused');
        buildWallData();
        buildBoardGrid();
        initializeRobots();
        renderRobotBadges();
        renderRobots();
        boardEl.addEventListener('focus', function () {
          boardActive = true;
          boardEl.classList.add('is-focused');
        });
        boardEl.addEventListener('blur', function () {
          boardActive = false;
          boardEl.classList.remove('is-focused');
        });
        boardEl.addEventListener('mousedown', function () {
          boardEl.focus({ preventScroll: true });
        });
        boardEl.addEventListener('touchstart', function () {
          boardEl.focus({ preventScroll: true });
        }, { passive: true });
        window.addEventListener('keydown', handleBoardKeydown);
        if (arrowControlsEl) {
          arrowControlsEl.addEventListener('click', handleArrowClick);
        }
        updateSelectedRobotStyles();
      }

      initBoard();
      if (toastEl) {
        toastEl.addEventListener('click', hideToast);
      }

      async function ensureRoomExists(code, hostName) {
        const payload = hostName ? { hostPlayerName: hostName } : {};
        const res = await fetch(`/api/rooms/${encodeURIComponent(code)}/create`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(payload)
        });
        let data = null;
        try {
          data = await res.json();
        } catch (err) {
          data = null;
        }

        if (res.ok) {
          return data && data.message ? data.message : '';
        }

        if (res.status === 409) {
          return data && data.error ? data.error : 'Room already exists; joining…';
        }

        const errorText = data && data.error ? data.error : 'Unable to create room.';
        throw new Error(errorText);
      }
    }());
  </script>
</body>
</html>
