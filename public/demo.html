<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Ricochet Robot Bidding Demo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <style>
    body { font-family: system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif; margin: 2rem; background: #f7f7f7; }
    h1 { margin-bottom: 0.5rem; }
    fieldset { border: 1px solid #ccc; padding: 1rem; margin-bottom: 1.5rem; background: #fff; }
    label { display: block; margin-bottom: 0.5rem; }
    input, select, button { padding: 0.5rem; font-size: 1rem; }
    .status { font-size: 1.25rem; margin: 0.5rem 0; }
    .timer { font-size: 2rem; font-weight: bold; }
    ul { padding-left: 1.5rem; }
    .columns { display: flex; flex-wrap: wrap; gap: 1.5rem; }
    .columns > div { flex: 1 1 250px; }
    table { width: 100%; border-collapse: collapse; }
    th, td { border: 1px solid #ddd; padding: 0.5rem; text-align: left; }
    .error { color: #b00020; }
    .message { margin-left: 1rem; font-size: 0.9rem; color: #333; }
    .message.error { color: #b00020; }
    body.join-gate-open { overflow: hidden; }
    .join-gate { position: fixed; inset: 0; background: rgba(15, 23, 42, 0.55); backdrop-filter: blur(6px); display: flex; align-items: center; justify-content: center; padding: 1.5rem; z-index: 900; }
    .join-gate[hidden] { display: none; }
    .join-gate__panel { width: min(480px, 100%); background: #fff; border-radius: 16px; padding: 1.5rem; box-shadow: 0 24px 60px rgba(15, 23, 42, 0.3); }
    .join-gate__panel h1 { margin-top: 0; margin-bottom: 0.5rem; font-size: 1.6rem; }
    .join-gate__room { margin: 0 0 1.25rem; font-size: 0.95rem; color: #475569; font-weight: 600; }
    .join-gate__room code { display: inline-block; padding: 0.2rem 0.45rem; border-radius: 6px; background: #eef2ff; color: #1d4ed8; }
    .join-gate form { display: grid; gap: 0.9rem; }
    .join-gate label { font-weight: 600; margin-bottom: 0.35rem; color: #111827; }
    .join-gate input, .join-gate select { width: 100%; box-sizing: border-box; }
    .join-gate button[type="submit"] { margin-top: 0.25rem; }
    .join-gate__status { margin-top: 0.75rem; }
    .share-banner { margin-bottom: 1.25rem; padding: 0.75rem 1rem; border-radius: 8px; border: 1px solid #facc15; background: #fef3c7; color: #92400e; display: flex; flex-wrap: wrap; gap: 0.75rem; align-items: center; }
    .share-banner__text { font-weight: 600; }
    .share-banner__link { font-weight: 600; color: inherit; word-break: break-word; text-decoration: none; }
    .share-banner__link:focus-visible, .share-banner__link:hover { text-decoration: underline; }
    .share-banner__actions { margin-left: auto; display: flex; gap: 0.5rem; align-items: center; }
    .share-banner__dismiss { border: none; background: transparent; font-size: 1.15rem; line-height: 1; color: inherit; cursor: pointer; padding: 0.25rem; border-radius: 6px; }
    .share-banner__dismiss:hover, .share-banner__dismiss:focus-visible { background: rgba(250, 204, 21, 0.25); outline: none; }
    .leading-panel { margin-top: 0.75rem; padding: 0.75rem; background: #e9f5ff; border: 1px solid #9cc9f1; border-radius: 4px; }
    .leading-panel strong { font-weight: 600; }
    #bids { list-style: none; padding-left: 0; }
    #bids li { margin-bottom: 0.35rem; padding: 0.35rem 0.5rem; border-radius: 4px; background: #fff; border: 1px solid #eee; }
    #bids li.bid-tie { border-color: #c5d6f2; background: #f2f6ff; font-weight: 600; }
    #bids li.bid-leading { border-color: #58a55c; background: #e6f6e6; color: #1f6e25; }
    .verifying-panel { margin-top: 1rem; padding: 0.75rem; background: #fff4e5; border: 1px solid #f5c48b; border-radius: 4px; }
    .verifying-panel h3 { margin: 0 0 0.5rem; font-size: 1.1rem; }
    #verifying-current { font-weight: 600; margin-bottom: 0.5rem; }
    #verifying-queue { list-style: decimal inside; padding-left: 1rem; margin: 0; }
    #verifying-queue li { padding: 0.25rem 0; }
    #verifying-queue li.current { font-weight: 700; color: #a05a00; }
    #verifying-queue li.empty { list-style: none; font-style: italic; color: #555; }
    .verify-buttons { margin-top: 0.75rem; display: flex; flex-wrap: wrap; gap: 0.5rem; align-items: center; }
    .board-wrapper { display: flex; flex-wrap: wrap; gap: 1.5rem; align-items: flex-start; }
    #board { --cell-count: 16; background: #fff; border: 2px solid #d0d5dd; border-radius: 10px; flex: 1 1 320px; max-width: 480px; padding: 0.5rem; outline: none; box-shadow: 0 10px 30px rgba(15, 23, 42, 0.08); }
    #board:focus-visible { box-shadow: 0 0 0 4px rgba(59, 130, 246, 0.35), 0 10px 30px rgba(15, 23, 42, 0.1); }
    .board.is-focused { box-shadow: 0 0 0 4px rgba(59, 130, 246, 0.25), 0 10px 30px rgba(15, 23, 42, 0.1); }
    .board-surface { position: relative; width: 100%; padding-bottom: 100%; }
    .board-grid, .robot-layer { position: absolute; inset: 0; }
    .board-grid { display: grid; grid-template-columns: repeat(16, 1fr); grid-template-rows: repeat(16, 1fr); }
    .board-cell { border: 1px solid #d1d5db; background: #fdfdfd; position: relative; }
    .board-cell.wall-top { border-top-width: 4px; border-top-color: #1f2937; }
    .board-cell.wall-bottom { border-bottom-width: 4px; border-bottom-color: #1f2937; }
    .board-cell.wall-left { border-left-width: 4px; border-left-color: #1f2937; }
    .board-cell.wall-right { border-right-width: 4px; border-right-color: #1f2937; }
    .board-cell.is-selected::after { content: ''; position: absolute; inset: 3px; border-radius: 6px; border: 2px solid rgba(59, 130, 246, 0.8); pointer-events: none; }
    .robot-layer { pointer-events: none; }
    .robot { pointer-events: auto; position: absolute; width: calc(100% / var(--cell-count) - 6px); height: calc(100% / var(--cell-count) - 6px); transform: translate(calc(var(--col) * 100% / var(--cell-count) + 3px), calc(var(--row) * 100% / var(--cell-count) + 3px)); transition: transform 160ms ease; border-radius: 50%; display: flex; align-items: center; justify-content: center; font-weight: 700; color: #fff; box-shadow: 0 6px 14px rgba(15, 23, 42, 0.2); user-select: none; }
    .robot-label { font-size: 0.9rem; text-transform: uppercase; letter-spacing: 0.05em; }
    .robot-blue { background: linear-gradient(135deg, #2563eb, #1d4ed8); }
    .robot-green { background: linear-gradient(135deg, #16a34a, #0f7a37); }
    .robot-red { background: linear-gradient(135deg, #dc2626, #b91c1c); }
    .robot-yellow { background: linear-gradient(135deg, #f59e0b, #d97706); color: #1f2937; }
    .robot.is-selected { box-shadow: 0 0 0 3px #fff, 0 0 0 6px rgba(59, 130, 246, 0.65); }
    .board-sidebar { flex: 1 1 220px; max-width: 320px; display: flex; flex-direction: column; gap: 1rem; }
    .board-selection { font-weight: 600; font-size: 1rem; }
    .robot-badges { display: flex; flex-wrap: wrap; gap: 0.5rem; }
    .robot-badge { border-radius: 999px; padding: 0.4rem 0.9rem; border: 1px solid #d1d5db; background: #fff; font-weight: 600; cursor: pointer; transition: transform 120ms ease, box-shadow 120ms ease; }
    .robot-badge:hover, .robot-badge:focus-visible { transform: translateY(-1px); box-shadow: 0 6px 12px rgba(59, 130, 246, 0.2); outline: none; }
    .robot-badge-blue { color: #1d4ed8; }
    .robot-badge-green { color: #0f7a37; }
    .robot-badge-red { color: #b91c1c; }
    .robot-badge-yellow { color: #b45309; }
    .robot-badge.is-selected { box-shadow: 0 0 0 2px rgba(59, 130, 246, 0.4); }
    .arrow-controls { display: grid; grid-template-columns: repeat(3, 48px); grid-template-rows: repeat(3, 48px); gap: 0.35rem; justify-content: flex-start; justify-items: center; align-items: center; }
    .arrow-button { border: 1px solid #d1d5db; background: #fff; border-radius: 12px; font-size: 1.25rem; font-weight: 600; display: flex; align-items: center; justify-content: center; cursor: pointer; transition: transform 120ms ease, box-shadow 120ms ease; }
    .arrow-button:hover, .arrow-button:focus-visible { transform: translateY(-1px); box-shadow: 0 8px 20px rgba(59, 130, 246, 0.25); outline: none; }
    .arrow-button.arrow-up { grid-column: 2; grid-row: 1; }
    .arrow-button.arrow-left { grid-column: 1; grid-row: 2; }
    .arrow-button.arrow-right { grid-column: 3; grid-row: 2; }
    .arrow-button.arrow-down { grid-column: 2; grid-row: 3; }
    .color-picker { display: flex; align-items: center; gap: 0.5rem; }
    .color-preview { width: 1.5rem; height: 1.5rem; border-radius: 50%; border: 1px solid #d1d5db; background: #f3f4f6; display: inline-block; }
    .banner { margin-top: 0.75rem; padding: 0.5rem 0.75rem; border-radius: 6px; border: 1px solid #facc15; background: #fef3c7; color: #92400e; font-size: 0.95rem; }
    .join-actions { margin-top: 0.75rem; display: flex; flex-wrap: wrap; gap: 0.5rem; align-items: center; }
    .players-header { display: flex; align-items: center; justify-content: space-between; margin-bottom: 0.75rem; }
    .players-list { list-style: none; margin: 0; padding: 0; display: flex; flex-direction: column; gap: 0.5rem; }
    .player-row { display: flex; align-items: center; justify-content: space-between; gap: 0.75rem; padding: 0.5rem 0.75rem; border-radius: 8px; border: 1px solid #e5e7eb; background: #fff; }
    .player-row.is-self { border-color: #2563eb; box-shadow: inset 0 0 0 1px rgba(37, 99, 235, 0.35); }
    .player-info { display: flex; align-items: center; gap: 0.5rem; }
    .player-badge { width: 1rem; height: 1rem; border-radius: 50%; border: 1px solid rgba(17, 24, 39, 0.2); }
    .player-name { font-weight: 600; }
    .player-color { font-size: 0.85rem; color: #4b5563; }
    .player-tokens { font-size: 0.9rem; color: #4b5563; min-width: 2.5rem; text-align: right; }
    .host-status { font-weight: 600; color: #2563eb; }
    .host-status.is-self { color: #15803d; }
    .player-role { font-size: 0.8rem; font-weight: 600; color: #1d4ed8; }
    button.secondary { padding: 0.5rem 0.9rem; font-weight: 600; border-radius: 6px; border: 1px solid #2563eb; background: #fff; color: #2563eb; cursor: pointer; transition: background 120ms ease, color 120ms ease; }
    button.secondary:hover, button.secondary:focus-visible { background: #eff6ff; color: #1d4ed8; }
    .host-controls { margin-top: 0.75rem; display: flex; flex-wrap: wrap; gap: 0.75rem; align-items: center; }
    .board-help { background: #f9fafb; border: 1px solid #e5e7eb; border-radius: 8px; padding: 0.75rem 1rem; font-size: 0.95rem; }
    .board-help summary { font-weight: 600; cursor: pointer; list-style: none; }
    .board-help summary::-webkit-details-marker { display: none; }
    .board-help summary::after { content: '⌄'; float: right; transform: rotate(0deg); transition: transform 120ms ease; }
    .board-help[open] summary::after { transform: rotate(180deg); }
    .board-help ul { margin: 0.75rem 0 0; padding-left: 1.25rem; }
    .board-help li { margin-bottom: 0.35rem; }
    .toast { position: fixed; bottom: 1.5rem; left: 50%; transform: translateX(-50%) translateY(16px); background: #111827; color: #fff; padding: 0.75rem 1.25rem; border-radius: 999px; box-shadow: 0 16px 32px rgba(15, 23, 42, 0.2); opacity: 0; pointer-events: none; transition: opacity 150ms ease, transform 150ms ease; z-index: 1000; font-weight: 600; }
    .toast.toast--visible { opacity: 1; transform: translateX(-50%) translateY(0); }
    .toast.toast--error { background: #b91c1c; }
    .toast.toast--info { background: #2563eb; }
    @media (max-width: 960px) {
      body { margin: 1.25rem; }
      .board-wrapper { flex-direction: column; }
      #board { flex: 1 1 auto; width: 100%; max-width: none; }
      .board-sidebar { width: 100%; max-width: none; }
    }
    @media (max-width: 540px) {
      .arrow-controls { grid-template-columns: repeat(3, 40px); grid-template-rows: repeat(3, 40px); }
      .arrow-button { font-size: 1rem; }
      .robot { font-size: 0.85rem; }
    }
  </style>
  <script src="/public/js/polling.js" defer></script>
</head>
<body class="join-gate-open">
  <div id="join-gate" class="join-gate" role="dialog" aria-modal="true" aria-labelledby="join-gate-title">
    <div class="join-gate__panel">
      <h1 id="join-gate-title">Join the room</h1>
      <p id="join-gate-room" class="join-gate__room" aria-live="polite" hidden></p>
      <form id="join-form">
        <label>
          Room code
          <input id="room-code" type="text" required minlength="1" maxlength="32" pattern="^[a-z0-9](?:[a-z0-9-]{0,30}[a-z0-9])?$" autocomplete="off" autocapitalize="off" spellcheck="false">
        </label>
        <label>
          Display name
          <input id="player-name" type="text" maxlength="64" autocomplete="off" required>
        </label>
        <label>
          Player color
          <div class="color-picker">
            <span id="color-preview" class="color-preview" aria-hidden="true"></span>
            <select id="player-color" required>
              <option value="Purple">Purple</option>
              <option value="Orange">Orange</option>
              <option value="Teal">Teal</option>
              <option value="Magenta">Magenta</option>
              <option value="Cyan">Cyan</option>
              <option value="Indigo">Indigo</option>
              <option value="Amber">Amber</option>
              <option value="Brown">Brown</option>
              <option value="Gray">Gray</option>
              <option value="Pink">Pink</option>
            </select>
          </div>
        </label>
        <button type="submit">Join room</button>
        <span id="join-message" class="message" aria-live="polite"></span>
      </form>
      <div id="join-status" class="banner join-gate__status" hidden aria-live="polite"></div>
      <div id="color-warning" class="banner" hidden></div>
    </div>
  </div>
  <div id="room-app" hidden aria-hidden="true">
    <div id="share-banner" class="share-banner" hidden role="status" aria-live="polite">
      <span class="share-banner__text">Room created! Share this link with your friends:</span>
      <a id="share-link" class="share-banner__link" href="" rel="noopener noreferrer"></a>
      <div class="share-banner__actions">
        <button type="button" id="share-copy" class="secondary">Copy</button>
        <button type="button" id="share-dismiss" class="share-banner__dismiss" aria-label="Dismiss banner">✕</button>
      </div>
    </div>
    <h1>Ricochet Robot Bidding Demo</h1>
    <p>Use this page to experiment with the server-authoritative bidding timer. Join the same room code in two tabs to observe live updates.</p>
    <div class="join-actions">
      <button type="button" id="edit-identity" class="secondary" hidden>Change identity</button>
    </div>

    <fieldset id="players-fieldset" hidden>
    <legend>Players</legend>
    <div class="players-header">
      <div><strong id="player-count">0</strong> joined</div>
      <div id="host-status" class="host-status" aria-live="polite"></div>
    </div>
    <ul id="players-list" class="players-list"></ul>
    <button type="button" id="claim-host" class="secondary" hidden>Claim Host</button>
  </fieldset>

  <fieldset>
    <legend>Current Round</legend>
    <div class="status">
      Status: <span id="status">—</span> (state version <span id="state-version">0</span>)
    </div>
    <div class="timer">
      Time Remaining: <span id="remaining">—</span>
    </div>
    <div>
      Lowest Bid: <span id="low-bid">—</span>
      <span id="low-bidder"></span>
    </div>
    <div id="leading-info" class="leading-panel" hidden>
      <strong>Leading:</strong>
      <span id="leading-text"></span>
    </div>
    <div id="verifying-container" class="verifying-panel" hidden>
      <h3>Verification Queue</h3>
      <div id="verifying-current">Current: —</div>
      <ol id="verifying-queue"></ol>
      <div class="verify-buttons">
        <button type="button" id="verify-pass">Pass</button>
        <button type="button" id="verify-fail">Fail</button>
        <span id="verify-message" class="message" aria-live="polite"></span>
      </div>
    </div>
    <div id="host-controls" class="host-controls" hidden>
      <button type="button" id="next-round" class="secondary">Next Round</button>
      <span id="next-message" class="message" aria-live="polite"></span>
    </div>
  </fieldset>

  <fieldset>
    <legend>Board &amp; Controls</legend>
    <div class="board-wrapper">
      <div id="board" class="board" tabindex="0" aria-label="Ricochet Robot board">
        <div class="board-surface">
          <div id="board-grid" class="board-grid" aria-hidden="true"></div>
          <div id="robot-layer" class="robot-layer" aria-hidden="true"></div>
        </div>
      </div>
      <div class="board-sidebar">
        <div id="board-selection" class="board-selection" aria-live="polite">Selected robot: —</div>
        <div id="robot-badges" class="robot-badges" role="group" aria-label="Select robot"></div>
        <div id="arrow-controls" class="arrow-controls" role="group" aria-label="Move robot">
          <button type="button" class="arrow-button arrow-up" data-dir="UP" aria-label="Move up">↑</button>
          <button type="button" class="arrow-button arrow-left" data-dir="LEFT" aria-label="Move left">←</button>
          <button type="button" class="arrow-button arrow-right" data-dir="RIGHT" aria-label="Move right">→</button>
          <button type="button" class="arrow-button arrow-down" data-dir="DOWN" aria-label="Move down">↓</button>
        </div>
        <details class="board-help" open>
          <summary>Keyboard tips</summary>
          <ul>
            <li><strong>Bid:</strong> Type digits, press Enter</li>
            <li><strong>Select robot:</strong> Tab / Shift+Tab or click a badge</li>
            <li><strong>Move:</strong> Arrow keys or W/A/S/D</li>
            <li><strong>Clear bid:</strong> Esc</li>
          </ul>
        </details>
      </div>
    </div>
  </fieldset>

  <div class="columns">
    <div>
      <h2>Recent Bids</h2>
      <ul id="bids"></ul>
    </div>
    <div>
      <h2>Leaderboard</h2>
      <table>
        <thead>
          <tr>
            <th>Player</th>
            <th>Tokens</th>
          </tr>
        </thead>
        <tbody id="leaderboard"></tbody>
      </table>
    </div>
  </div>

  <fieldset>
    <legend>Submit Bid</legend>
    <form id="bid-form">
      <label>
        Bid value
        <input id="bidInput" inputmode="numeric" autocomplete="off" autocapitalize="off" spellcheck="false" autofocus>
      </label>
      <button type="submit">Submit Bid</button>
      <span id="bid-message" class="message" aria-live="polite"></span>
    </form>
  </fieldset>

  </div>

  <div id="toast" class="toast" aria-live="polite" aria-atomic="true"></div>

  <script>
    (function () {
      const joinForm = document.getElementById('join-form');
      const bidForm = document.getElementById('bid-form');
      const joinGate = document.getElementById('join-gate');
      const joinGateRoom = document.getElementById('join-gate-room');
      const roomApp = document.getElementById('room-app');
      const shareBanner = document.getElementById('share-banner');
      const shareLink = document.getElementById('share-link');
      const shareCopyButton = document.getElementById('share-copy');
      const shareDismissButton = document.getElementById('share-dismiss');
      const roomCodeInput = document.getElementById('room-code');
      const playerNameInput = document.getElementById('player-name');
      const playerColorInput = document.getElementById('player-color');
      const colorPreview = document.getElementById('color-preview');
      const colorWarning = document.getElementById('color-warning');
      const joinMessage = document.getElementById('join-message');
      const joinStatus = document.getElementById('join-status');
      const bidMessage = document.getElementById('bid-message');
      const joinButton = joinForm ? joinForm.querySelector('button[type="submit"]') : null;
      const bidButton = bidForm ? bidForm.querySelector('button[type="submit"]') : null;
      const editIdentityButton = document.getElementById('edit-identity');
      const bidInput = document.getElementById('bidInput');
      const playersFieldset = document.getElementById('players-fieldset');
      const playersListEl = document.getElementById('players-list');
      const playerCountEl = document.getElementById('player-count');
      const hostStatusEl = document.getElementById('host-status');
      const claimHostButton = document.getElementById('claim-host');
      const hostControls = document.getElementById('host-controls');
      const nextRoundButton = document.getElementById('next-round');
      const nextMessage = document.getElementById('next-message');

      const ROOM_CODE_PATTERN = /^[a-z0-9](?:[a-z0-9-]{0,30}[a-z0-9])?$/;
      const DOUBLE_HYPHEN_PATTERN = /--/;

      function isValidRoomCode(value) {
        const normalized = normalizeRoomCode(value);
        if (!normalized) {
          return false;
        }
        return ROOM_CODE_PATTERN.test(normalized) && !DOUBLE_HYPHEN_PATTERN.test(normalized);
      }

      const searchParams = new URLSearchParams(window.location.search);
      let shouldShowShareBanner = searchParams.get('created') === '1';
      let shareBannerDisplayed = false;

      let storedPlayerInfo = null;
      let autoJoinContext = null;
      const pathRoomMatch = window.location.pathname.match(/^\/r\/([^/]+)/i);
      const matchedRoomCode = pathRoomMatch ? normalizeRoomCode(decodeURIComponent(pathRoomMatch[1])) : '';
      const initialRoomCode = matchedRoomCode && isValidRoomCode(matchedRoomCode) ? matchedRoomCode : '';
      if (initialRoomCode) {
        roomCodeInput.value = initialRoomCode;
        roomCodeInput.readOnly = true;
        roomCodeInput.setAttribute('aria-readonly', 'true');
        storedPlayerInfo = loadStoredPlayer(initialRoomCode);
        updateJoinGateRoom(initialRoomCode);
      }

      if (!storedPlayerInfo && roomCodeInput && roomCodeInput.value) {
        const inputRoomCode = normalizeRoomCode(roomCodeInput.value);
        if (inputRoomCode && isValidRoomCode(inputRoomCode)) {
          storedPlayerInfo = loadStoredPlayer(inputRoomCode);
          if (!initialRoomCode) {
            roomCodeInput.value = inputRoomCode;
            updateJoinGateRoom(inputRoomCode);
          }
        } else if (!initialRoomCode) {
          updateJoinGateRoom('');
        }
      }

      const globalIdentity = loadGlobalIdentity();

      if (storedPlayerInfo) {
        const storedNameRaw = storedPlayerInfo.displayName
          ? storedPlayerInfo.displayName
          : (globalIdentity && globalIdentity.displayName ? globalIdentity.displayName : '');
        const storedName = storedNameRaw ? storedNameRaw.trim() : '';
        if (storedName) {
          playerNameInput.value = storedName;
        }
        const storedColor = canonicalizeColor(storedPlayerInfo.color);
        if (storedColor) {
          playerColorInput.value = storedColor;
          if (initialRoomCode && storedName && storedPlayerInfo.playerId) {
            autoJoinContext = {
              code: initialRoomCode,
              displayName: storedName,
              color: storedColor
            };
          }
        } else {
          showColorWarning('Your previous color is no longer available. Please pick a new one.');
        }
      } else if (globalIdentity) {
        const globalName = globalIdentity.displayName ? globalIdentity.displayName.trim() : '';
        if (globalName) {
          playerNameInput.value = globalName;
        }
        const globalColor = canonicalizeColor(globalIdentity.color);
        if (globalColor) {
          playerColorInput.value = globalColor;
        }
      }

      updateColorPreview(playerColorInput.value);

      if (autoJoinContext) {
        setJoinFormVisible(false);
        setEditIdentityVisible(false);
        showJoinStatusBanner(`Rejoining as ${formatIdentityLabel(autoJoinContext.displayName, autoJoinContext.color)}…`);
      } else {
        setJoinFormVisible(true);
        setEditIdentityVisible(false);
        hideJoinStatusBanner();
      }

      const statusEl = document.getElementById('status');
      const versionEl = document.getElementById('state-version');
      const remainingEl = document.getElementById('remaining');
      const lowBidEl = document.getElementById('low-bid');
      const lowBidderEl = document.getElementById('low-bidder');
      const leadingPanel = document.getElementById('leading-info');
      const leadingText = document.getElementById('leading-text');
      const bidsEl = document.getElementById('bids');
      const leaderboardEl = document.getElementById('leaderboard');
      const verifyingContainer = document.getElementById('verifying-container');
      const verifyingCurrent = document.getElementById('verifying-current');
      const verifyingQueueList = document.getElementById('verifying-queue');
      const verifyPassButton = document.getElementById('verify-pass');
      const verifyFailButton = document.getElementById('verify-fail');
      const verifyMessage = document.getElementById('verify-message');
      const boardEl = document.getElementById('board');
      const boardGridEl = document.getElementById('board-grid');
      const robotLayerEl = document.getElementById('robot-layer');
      const robotBadgesEl = document.getElementById('robot-badges');
      const arrowControlsEl = document.getElementById('arrow-controls');
      const boardSelectionEl = document.getElementById('board-selection');
      const toastEl = document.getElementById('toast');

      let poller = null;
      let currentRoomCode = null;
      let currentPlayerId = null;
      let lastStateSnapshot = null;
      let currentPlayerName = '';
      let currentPlayerColor = null;
      let playersById = {};
      let hostPlayerId = null;
      let lastServerRemaining = null;
      let lastServerTimestamp = null;
      let serverSkewMs = 0;
      let hasServerSkew = false;
      let countdownTimerId = null;
      let bidAllowed = false;
      let bidInFlight = false;
      let joinInFlight = false;
      let autoJoinScheduled = false;
      let lastVerifyingState = null;
      let verifyInFlight = false;
      let nextInFlight = false;
      let claimInFlight = false;
      const BOARD_SIZE = 16;
      const ROBOT_ORDER = ['Blue', 'Green', 'Red', 'Yellow'];
      const ROBOT_META = {
        Blue: { id: 'blue', robotClass: 'robot-blue', badgeClass: 'robot-badge-blue', shortLabel: 'B' },
        Green: { id: 'green', robotClass: 'robot-green', badgeClass: 'robot-badge-green', shortLabel: 'G' },
        Red: { id: 'red', robotClass: 'robot-red', badgeClass: 'robot-badge-red', shortLabel: 'R' },
        Yellow: { id: 'yellow', robotClass: 'robot-yellow', badgeClass: 'robot-badge-yellow', shortLabel: 'Y' }
      };
      const PLAYER_COLORS = ['Purple', 'Orange', 'Teal', 'Magenta', 'Cyan', 'Indigo', 'Amber', 'Brown', 'Gray', 'Pink'];
      const PLAYER_COLOR_HEX = {
        Purple: '#7c3aed',
        Orange: '#f97316',
        Teal: '#0d9488',
        Magenta: '#db2777',
        Cyan: '#06b6d4',
        Indigo: '#4338ca',
        Amber: '#f59e0b',
        Brown: '#92400e',
        Gray: '#6b7280',
        Pink: '#ec4899'
      };
      const INITIAL_ROBOT_POSITIONS = {
        Blue: { row: 1, col: 1 },
        Green: { row: 1, col: 14 },
        Red: { row: 14, col: 1 },
        Yellow: { row: 14, col: 14 }
      };
      const STATIC_WALL_DATA = {
        '0,3': [0, 0, 0, 1],
        '0,9': [0, 0, 0, 1],
        '1,13': [0, 1, 0, 1],
        '1,15': [0, 1, 0, 0],
        '2,5': [0, 1, 0, 1],
        '3,9': [1, 0, 1, 0],
        '4,0': [0, 1, 0, 0],
        '4,2': [1, 0, 0, 1],
        '4,14': [1, 0, 0, 1],
        '5,7': [0, 1, 1, 0],
        '6,1': [1, 0, 1, 0],
        '6,12': [0, 1, 1, 0],
        '7,7': [1, 0, 1, 0],
        '7,8': [1, 0, 0, 1],
        '8,7': [0, 1, 1, 0],
        '8,8': [0, 1, 0, 1],
        '8,12': [1, 0, 1, 0],
        '9,3': [0, 1, 0, 1],
        '9,10': [0, 1, 1, 0],
        '10,0': [0, 1, 0, 0],
        '10,15': [0, 1, 0, 0],
        '11,5': [1, 0, 1, 0],
        '11,9': [0, 1, 0, 1],
        '12,14': [1, 0, 0, 1],
        '13,1': [0, 1, 1, 0],
        '14,6': [1, 0, 0, 1],
        '14,13': [1, 0, 1, 0],
        '15,4': [0, 0, 0, 1],
        '15,10': [0, 0, 0, 1]
      };
      const CENTER_CELLS = [[7, 7], [7, 8], [8, 7], [8, 8]];
      const KEY_TO_DIR = {
        ArrowUp: 'UP',
        ArrowDown: 'DOWN',
        ArrowLeft: 'LEFT',
        ArrowRight: 'RIGHT',
        w: 'UP',
        s: 'DOWN',
        a: 'LEFT',
        d: 'RIGHT'
      };
      const WALL_RELATIONS = {
        top: { dr: -1, dc: 0, opposite: 'bottom' },
        bottom: { dr: 1, dc: 0, opposite: 'top' },
        left: { dr: 0, dc: -1, opposite: 'right' },
        right: { dr: 0, dc: 1, opposite: 'left' }
      };
      const boardWalls = new Map();
      const robotState = {};
      let boardInitialized = false;
      let boardActive = false;
      let robotIdx = 0;
      let toastTimeoutId = null;

      function setMessage(element, text, isError) {
        if (!element) {
          return;
        }
        element.textContent = text || '';
        if (isError) {
          element.classList.add('error');
        } else {
          element.classList.remove('error');
        }
      }

      function formatIdentityLabel(name, color) {
        const safeName = typeof name === 'string' ? name.trim() : '';
        const canonicalColor = canonicalizeColor(color);
        if (safeName && canonicalColor) {
          return `${safeName} (${canonicalColor})`;
        }
        if (safeName) {
          return safeName;
        }
        if (canonicalColor) {
          return canonicalColor;
        }
        return 'Player';
      }

      function setJoinFormDisabled(disabled) {
        if (!joinForm) {
          return;
        }
        const elements = Array.prototype.slice.call(joinForm.elements || []);
        elements.forEach(function (el) {
          if (!el || typeof el.disabled !== 'boolean') {
            return;
          }
          el.disabled = disabled;
        });
        if (joinButton) {
          joinButton.disabled = disabled;
        }
      }

      function setJoinFormVisible(visible) {
        if (!joinForm) {
          return;
        }
        joinForm.hidden = !visible;
        if (visible) {
          joinForm.removeAttribute('aria-hidden');
          setJoinFormDisabled(false);
        } else {
          joinForm.setAttribute('aria-hidden', 'true');
          setJoinFormDisabled(true);
        }
      }

      function setEditIdentityVisible(visible) {
        if (!editIdentityButton) {
          return;
        }
        editIdentityButton.hidden = !visible;
        editIdentityButton.disabled = !visible;
      }

      function showJoinStatusBanner(text) {
        if (!joinStatus) {
          return;
        }
        const message = text || '';
        joinStatus.textContent = message;
        joinStatus.hidden = message === '';
      }

      function hideJoinStatusBanner() {
        showJoinStatusBanner('');
      }

      function setJoinGateVisible(visible) {
        if (joinGate) {
          joinGate.hidden = !visible;
        }
        if (visible) {
          document.body.classList.add('join-gate-open');
          if (roomApp) {
            roomApp.setAttribute('aria-hidden', 'true');
          }
        } else {
          document.body.classList.remove('join-gate-open');
          if (roomApp) {
            roomApp.removeAttribute('aria-hidden');
          }
        }
      }

      function showRoomApp() {
        if (roomApp) {
          roomApp.hidden = false;
          roomApp.removeAttribute('aria-hidden');
        }
      }

      function updateJoinGateRoom(code) {
        if (!joinGateRoom) {
          return;
        }
        const normalized = normalizeRoomCode(code);
        if (!normalized || !ROOM_CODE_PATTERN.test(normalized) || DOUBLE_HYPHEN_PATTERN.test(normalized)) {
          joinGateRoom.textContent = '';
          joinGateRoom.hidden = true;
          return;
        }
        const display = normalized.toLowerCase();
        joinGateRoom.hidden = false;
        joinGateRoom.textContent = '';
        const label = document.createElement('span');
        label.textContent = 'Room code: ';
        const codeEl = document.createElement('code');
        codeEl.textContent = display;
        joinGateRoom.appendChild(label);
        joinGateRoom.appendChild(codeEl);
      }

      function getShareUrl(code) {
        const normalized = normalizeRoomCode(code);
        if (!normalized || !ROOM_CODE_PATTERN.test(normalized) || DOUBLE_HYPHEN_PATTERN.test(normalized)) {
          return '';
        }
        const base = `${window.location.protocol}//${window.location.host}`;
        return `${base}/r/${encodeURIComponent(normalized)}`;
      }

      function consumeCreationFlag() {
        if (!shouldShowShareBanner) {
          return;
        }
        shouldShowShareBanner = false;
        try {
          const url = new URL(window.location.href);
          url.searchParams.delete('created');
          const searchString = url.searchParams.toString();
          const next = `${url.pathname}${searchString ? `?${searchString}` : ''}${url.hash}`;
          window.history.replaceState(null, '', next);
        } catch (err) {
          // Ignore history errors.
        }
      }

      function maybeShowShareBanner(code) {
        if (!shareBanner || shareBannerDisplayed || !shouldShowShareBanner) {
          return;
        }
        const shareUrl = getShareUrl(code);
        if (!shareUrl) {
          return;
        }
        if (shareLink) {
          shareLink.href = shareUrl;
          shareLink.textContent = shareUrl;
        }
        shareBanner.hidden = false;
        shareBannerDisplayed = true;
        consumeCreationFlag();
      }

      function hideShareBanner() {
        if (shareBanner) {
          shareBanner.hidden = true;
        }
        shareBannerDisplayed = false;
        consumeCreationFlag();
      }

      async function copyShareLink() {
        const shareUrl = shareLink && shareLink.href ? shareLink.href : window.location.href;
        if (!shareUrl) {
          return;
        }
        try {
          if (navigator.clipboard && typeof navigator.clipboard.writeText === 'function') {
            await navigator.clipboard.writeText(shareUrl);
          } else {
            const textArea = document.createElement('textarea');
            textArea.value = shareUrl;
            textArea.setAttribute('readonly', '');
            textArea.style.position = 'absolute';
            textArea.style.left = '-9999px';
            document.body.appendChild(textArea);
            textArea.select();
            document.execCommand('copy');
            document.body.removeChild(textArea);
          }
          showToast('Link copied to clipboard', false);
        } catch (err) {
          showToast('Unable to copy link. Copy it manually.', true);
        }
      }

      function whenPollingHelpersReady(callback, onTimeout) {
        if (typeof callback !== 'function') {
          return;
        }
        if (window.PollingHelpers) {
          callback();
          return;
        }
        let attempts = 0;
        const maxAttempts = 60;
        const timerId = window.setInterval(function () {
          attempts += 1;
          if (window.PollingHelpers) {
            clearInterval(timerId);
            callback();
          } else if (attempts >= maxAttempts) {
            clearInterval(timerId);
            console.warn('PollingHelpers did not initialize in time.');
            if (typeof onTimeout === 'function') {
              onTimeout();
            }
          }
        }, 100);
      }

      function normalizeRoomCode(value) {
        if (typeof value !== 'string') {
          return '';
        }
        const trimmed = value.trim();
        return trimmed ? trimmed.toLowerCase() : '';
      }

      function canonicalizeColor(value) {
        if (typeof value !== 'string') {
          return null;
        }
        const trimmed = value.trim();
        if (!trimmed) {
          return null;
        }
        const match = PLAYER_COLORS.find(function (color) {
          return color.toLowerCase() === trimmed.toLowerCase();
        });
        return match || null;
      }

      function updateColorPreview(color) {
        if (!colorPreview) {
          return;
        }
        const canonical = canonicalizeColor(color);
        const hex = canonical ? PLAYER_COLOR_HEX[canonical] : null;
        if (hex) {
          colorPreview.style.background = hex;
          colorPreview.style.borderColor = 'rgba(17, 24, 39, 0.3)';
        } else {
          colorPreview.style.background = '#f3f4f6';
          colorPreview.style.borderColor = '#d1d5db';
        }
      }

      function showColorWarning(text) {
        if (!colorWarning) {
          return;
        }
        const message = text || '';
        colorWarning.textContent = message;
        colorWarning.hidden = message === '';
      }

      function hideColorWarning() {
        showColorWarning('');
      }

      function getPlayerInfo(playerId) {
        const key = Number(playerId);
        if (!Number.isFinite(key)) {
          return null;
        }
        return playersById[key] || null;
      }

      function formatPlayerLabel(playerId) {
        const info = getPlayerInfo(playerId);
        if (info && info.displayName) {
          return info.displayName;
        }
        return `Player ${playerId}`;
      }

      function formatPlayerWithColor(playerId) {
        const info = getPlayerInfo(playerId);
        const base = formatPlayerLabel(playerId);
        if (info && info.color) {
          return `${base} (${info.color})`;
        }
        return base;
      }

      function storagePrefixForRoom(code) {
        const normalized = normalizeRoomCode(code);
        if (!normalized || !ROOM_CODE_PATTERN.test(normalized) || DOUBLE_HYPHEN_PATTERN.test(normalized)) {
          return null;
        }
        return `rr.${normalized}`;
      }

      function loadStoredPlayer(code) {
        const prefix = storagePrefixForRoom(code);
        if (!prefix) {
          return null;
        }
        try {
          const idRaw = window.localStorage.getItem(`${prefix}.playerId`);
          const nameRaw = window.localStorage.getItem(`${prefix}.displayName`) || '';
          const colorRaw = window.localStorage.getItem(`${prefix}.color`) || '';
          const parsedId = idRaw != null ? Number.parseInt(idRaw, 10) : NaN;
          const playerId = Number.isFinite(parsedId) && parsedId > 0 ? parsedId : null;
          const displayName = typeof nameRaw === 'string' ? nameRaw : '';
          const color = typeof colorRaw === 'string' && colorRaw ? colorRaw : null;
          if (playerId || displayName || color) {
            return { playerId: playerId, displayName: displayName, color: color };
          }
        } catch (err) {
          // Ignore storage errors.
        }
        return null;
      }

      function saveStoredPlayer(code, playerId, displayName, color) {
        const prefix = storagePrefixForRoom(code);
        if (!prefix) {
          return;
        }
        try {
          if (Number.isFinite(Number(playerId)) && Number(playerId) > 0) {
            window.localStorage.setItem(`${prefix}.playerId`, String(Number(playerId)));
          } else {
            window.localStorage.removeItem(`${prefix}.playerId`);
          }
          const trimmedName = typeof displayName === 'string' ? displayName.trim() : '';
          if (trimmedName) {
            window.localStorage.setItem(`${prefix}.displayName`, trimmedName);
          } else {
            window.localStorage.removeItem(`${prefix}.displayName`);
          }
          if (color) {
            window.localStorage.setItem(`${prefix}.color`, color);
          } else {
            window.localStorage.removeItem(`${prefix}.color`);
          }
        } catch (err) {
          // Ignore storage failures.
        }
      }

      function clearStoredPlayer(code) {
        const prefix = storagePrefixForRoom(code);
        if (!prefix) {
          return;
        }
        try {
          window.localStorage.removeItem(`${prefix}.playerId`);
          window.localStorage.removeItem(`${prefix}.displayName`);
          window.localStorage.removeItem(`${prefix}.color`);
        } catch (err) {
          // Ignore.
        }
      }

      function loadGlobalIdentity() {
        try {
          const storedId = window.localStorage.getItem('rr.playerId');
          const storedName = window.localStorage.getItem('rr.displayName') || '';
          const storedColor = window.localStorage.getItem('rr.color') || null;
          const parsedId = storedId != null ? Number.parseInt(storedId, 10) : NaN;
          if (Number.isFinite(parsedId) && parsedId > 0) {
            return { playerId: parsedId, displayName: storedName, color: storedColor };
          }
          if (storedName || storedColor) {
            return { playerId: null, displayName: storedName, color: storedColor };
          }
        } catch (err) {
          return null;
        }
        return null;
      }

      function saveGlobalIdentity(playerId, displayName, color) {
        try {
          if (playerId != null && Number.isFinite(Number(playerId)) && Number(playerId) > 0) {
            window.localStorage.setItem('rr.playerId', String(playerId));
          } else {
            window.localStorage.removeItem('rr.playerId');
          }
          if (typeof displayName === 'string' && displayName) {
            window.localStorage.setItem('rr.displayName', displayName);
          } else {
            window.localStorage.removeItem('rr.displayName');
          }
          if (typeof color === 'string' && color) {
            window.localStorage.setItem('rr.color', color);
          } else {
            window.localStorage.removeItem('rr.color');
          }
        } catch (err) {
          // Ignore storage errors.
        }
      }

      function clearGlobalIdentity() {
        try {
          window.localStorage.removeItem('rr.playerId');
          window.localStorage.removeItem('rr.displayName');
          window.localStorage.removeItem('rr.color');
        } catch (err) {
          // Ignore.
        }
      }

      function updateBidFormState() {
        const inputEnabled = bidAllowed && !bidInFlight;
        if (bidInput) {
          bidInput.disabled = !inputEnabled;
        }
        bidButton.disabled = !bidAllowed || bidInFlight;
      }

      function setBidFormEnabled(enabled) {
        bidAllowed = Boolean(enabled);
        updateBidFormState();
        if (!bidAllowed && bidInput) {
          bidInput.blur();
        }
        if (bidAllowed && !bidInFlight && bidInput) {
          window.requestAnimationFrame(function () {
            if (document.activeElement !== bidInput && !bidInput.disabled) {
              bidInput.focus({ preventScroll: true });
            }
          });
        }
      }

      function resetClientState() {
        lastServerRemaining = null;
        lastServerTimestamp = null;
        serverSkewMs = 0;
        hasServerSkew = false;
        stopCountdownTicker();
        setBidFormEnabled(false);
        lastVerifyingState = null;
        verifyInFlight = false;
        nextInFlight = false;
        if (verifyMessage) {
          setMessage(verifyMessage, '', false);
        }
        if (nextMessage) {
          setMessage(nextMessage, '', false);
        }
      }

      if (bidInput) {
        bidInput.addEventListener('input', function (event) {
          const digits = event.target.value.replace(/\D+/g, '').slice(0, 3);
          if (event.target.value !== digits) {
            event.target.value = digits;
          }
        });
        bidInput.addEventListener('keydown', function (event) {
          if (event.key === 'Enter') {
            event.preventDefault();
            submitBid();
          } else if (event.key === 'Escape') {
            event.preventDefault();
            bidInput.value = '';
            setMessage(bidMessage, '', false);
          }
        });
      }

      if (playerColorInput) {
        playerColorInput.addEventListener('change', function () {
          updateColorPreview(playerColorInput.value);
          hideColorWarning();
        });
      }

      function getCurrentVerifier() {
        if (!lastVerifyingState || !Array.isArray(lastVerifyingState.queue)) {
          return null;
        }

        const index = Number.isInteger(lastVerifyingState.currentIndex)
          ? lastVerifyingState.currentIndex
          : 0;

        if (index < 0) {
          return null;
        }

        return lastVerifyingState.queue[index] || null;
      }

      function updateVerifyButtons() {
        if (!verifyPassButton || !verifyFailButton) {
          return;
        }
        const isHost = currentPlayerId != null && hostPlayerId != null && currentPlayerId === hostPlayerId;
        const currentEntry = getCurrentVerifier();
        const enabled = Boolean(currentRoomCode && currentEntry && !verifyInFlight && isHost);
        verifyPassButton.disabled = !enabled;
        verifyFailButton.disabled = !enabled;
        verifyPassButton.hidden = !isHost;
        verifyFailButton.hidden = !isHost;
      }

      function stopCountdownTicker() {
        if (countdownTimerId != null) {
          clearInterval(countdownTimerId);
          countdownTimerId = null;
        }
      }

      function updateCountdownDisplay() {
        const remaining = estimateRemaining();
        if (remaining == null) {
          remainingEl.textContent = '—';
          return;
        }
        remainingEl.textContent = formatSeconds(remaining);
        if (remaining <= 0) {
          stopCountdownTicker();
        }
      }

      function startCountdownTicker() {
        updateCountdownDisplay();
        if (countdownTimerId == null) {
          countdownTimerId = setInterval(updateCountdownDisplay, 250);
        }
      }

      function formatSeconds(seconds) {
        if (seconds == null) {
          return '—';
        }
        const s = Math.max(0, Math.floor(seconds));
        const mins = Math.floor(s / 60);
        const secs = s % 60;
        return mins > 0 ? `${mins}:${secs.toString().padStart(2, '0')}` : `${secs}`;
      }

      function renderPlayersList() {
        if (!playersFieldset || !playersListEl || !playerCountEl) {
          return;
        }

        const entries = Object.values(playersById || {});
        const hasPlayers = entries.length > 0;
        playersFieldset.hidden = !hasPlayers && !currentRoomCode;
        playersListEl.innerHTML = '';
        playerCountEl.textContent = String(entries.length);

        if (!hasPlayers) {
          if (hostStatusEl) {
            hostStatusEl.textContent = 'No host yet.';
            hostStatusEl.classList.remove('is-self');
          }
          if (claimHostButton) {
            claimHostButton.hidden = true;
          }
          return;
        }

        const sorted = entries.slice().sort(function (a, b) {
          const tokensA = Number.isFinite(a.tokensWon) ? a.tokensWon : 0;
          const tokensB = Number.isFinite(b.tokensWon) ? b.tokensWon : 0;
          if (tokensB !== tokensA) {
            return tokensB - tokensA;
          }
          const nameA = (a.displayName || '').toLowerCase();
          const nameB = (b.displayName || '').toLowerCase();
          if (nameA !== nameB) {
            return nameA < nameB ? -1 : 1;
          }
          return a.playerId - b.playerId;
        });

        sorted.forEach(function (entry) {
          const li = document.createElement('li');
          li.className = 'player-row';
          if (entry.playerId === currentPlayerId) {
            li.classList.add('is-self');
          }

          const infoWrap = document.createElement('div');
          infoWrap.className = 'player-info';

          const badge = document.createElement('span');
          badge.className = 'player-badge';
          const badgeHex = entry.color && PLAYER_COLOR_HEX[entry.color] ? PLAYER_COLOR_HEX[entry.color] : '#9ca3af';
          badge.style.background = badgeHex;
          infoWrap.appendChild(badge);

          const nameSpan = document.createElement('span');
          nameSpan.className = 'player-name';
          nameSpan.textContent = entry.displayName || `Player ${entry.playerId}`;
          infoWrap.appendChild(nameSpan);

          if (entry.color) {
            const colorSpan = document.createElement('span');
            colorSpan.className = 'player-color';
            colorSpan.textContent = entry.color;
            infoWrap.appendChild(colorSpan);
          }

          if (hostPlayerId != null && entry.playerId === hostPlayerId) {
            const roleSpan = document.createElement('span');
            roleSpan.className = 'player-role';
            roleSpan.textContent = 'Host';
            infoWrap.appendChild(roleSpan);
          }

          li.appendChild(infoWrap);

          const tokensSpan = document.createElement('span');
          tokensSpan.className = 'player-tokens';
          const tokens = Number.isFinite(entry.tokensWon) ? entry.tokensWon : 0;
          tokensSpan.textContent = `${tokens} token${tokens === 1 ? '' : 's'}`;
          li.appendChild(tokensSpan);

          playersListEl.appendChild(li);
        });

        if (hostStatusEl) {
          if (hostPlayerId != null) {
            if (currentPlayerId === hostPlayerId) {
              hostStatusEl.textContent = 'You are the host.';
              hostStatusEl.classList.add('is-self');
            } else {
              hostStatusEl.textContent = `Host: ${formatPlayerWithColor(hostPlayerId)}`;
              hostStatusEl.classList.remove('is-self');
            }
          } else {
            hostStatusEl.textContent = 'No host yet.';
            hostStatusEl.classList.remove('is-self');
          }
        }

        if (claimHostButton) {
          const canClaim = hostPlayerId == null && currentPlayerId != null;
          claimHostButton.hidden = !canClaim;
          claimHostButton.disabled = !canClaim || claimInFlight;
        }
      }

      function updateHostControls(state) {
        if (!hostControls || !nextRoundButton) {
          return;
        }
        const isHost = currentPlayerId != null && hostPlayerId != null && currentPlayerId === hostPlayerId;
        if (!isHost) {
          hostControls.hidden = true;
          nextRoundButton.disabled = true;
          return;
        }
        hostControls.hidden = false;
        const canAdvance = state.status === 'complete';
        nextRoundButton.disabled = !canAdvance || nextInFlight;
      }

      function renderAll(state) {
        lastStateSnapshot = state;
        statusEl.textContent = state.status;
        versionEl.textContent = state.stateVersion;
        const playersState = state.players && typeof state.players === 'object' ? state.players : {};
        const nextPlayers = {};
        Object.keys(playersState).forEach(function (key) {
          const id = Number(key);
          if (!Number.isFinite(id)) {
            return;
          }
          const info = playersState[key] || {};
          nextPlayers[id] = {
            playerId: id,
            displayName: typeof info.displayName === 'string' ? info.displayName : '',
            color: canonicalizeColor(info.color) || null,
            tokensWon: Number.isFinite(info.tokensWon) ? info.tokensWon : 0
          };
        });
        playersById = nextPlayers;
        hostPlayerId = state.hostPlayerId != null && Number.isFinite(Number(state.hostPlayerId)) ? Number(state.hostPlayerId) : null;
        if (currentPlayerId != null && playersById[currentPlayerId]) {
          const selfInfo = playersById[currentPlayerId];
          if (selfInfo.displayName) {
            currentPlayerName = selfInfo.displayName;
          }
          if (selfInfo.color) {
            currentPlayerColor = selfInfo.color;
          }
        }
        renderPlayersList();
        lowBidEl.textContent = state.currentLow != null ? state.currentLow : '—';
        lowBidderEl.textContent = state.currentLowBy != null ? `(by ${formatPlayerWithColor(state.currentLowBy)})` : '';

        const currentLow = state.currentLow;
        const leader = state.currentLeader;
        const ties = Array.isArray(state.tiesAtCurrentLow) ? state.tiesAtCurrentLow : [];
        const tieCount = ties.length;

        bidsEl.innerHTML = '';
        let leaderMarked = false;
        (state.bids || []).forEach(function (bid) {
          const li = document.createElement('li');
          const when = bid.createdAt ? new Date(bid.createdAt).toLocaleTimeString() : '—';
          const label = formatPlayerWithColor(bid.playerId);
          let text = `${label} bid ${bid.value} @ ${when}`;

          if (currentLow != null && bid.value === currentLow) {
            li.classList.add('bid-tie');
            if (leader && !leaderMarked && leader.playerId === bid.playerId && leader.value === bid.value) {
              li.classList.add('bid-leading');
              text += ' (leading)';
              leaderMarked = true;
            } else if (tieCount > 1) {
              text += ' (tied)';
            }
          }

          li.textContent = text;
          bidsEl.appendChild(li);
        });

        leaderboardEl.innerHTML = '';
        (state.leaderboard || []).forEach(function (row) {
          const tr = document.createElement('tr');
          const nameCell = document.createElement('td');
          nameCell.textContent = formatPlayerWithColor(row.playerId);
          const tokensCell = document.createElement('td');
          let tokensValue = Number.isFinite(row.tokensWon) ? row.tokensWon : null;
          if (tokensValue == null) {
            const info = getPlayerInfo(row.playerId);
            tokensValue = info && Number.isFinite(info.tokensWon) ? info.tokensWon : 0;
          }
          tokensCell.textContent = tokensValue != null ? tokensValue : '0';
          tr.appendChild(nameCell);
          tr.appendChild(tokensCell);
          leaderboardEl.appendChild(tr);
        });

        let verifyingState = null;
        if (state.status === 'verifying' && state.verifying && Array.isArray(state.verifying.queue)) {
          const queueCopy = state.verifying.queue.map(function (entry) {
            return {
              playerId: entry.playerId,
              value: entry.value,
              tokensWon: entry.tokensWon,
              createdAt: entry.createdAt
            };
          });
          const currentIndex = Number.isInteger(state.verifying.currentIndex) ? state.verifying.currentIndex : 0;
          verifyingState = { queue: queueCopy, currentIndex: currentIndex };
        }

        lastVerifyingState = verifyingState;

        if (verifyingState) {
          verifyingContainer.hidden = false;
          verifyingQueueList.innerHTML = '';
          const queue = verifyingState.queue;
          const currentIndex = verifyingState.currentIndex >= 0 ? verifyingState.currentIndex : 0;

          if (queue.length === 0) {
            const emptyLi = document.createElement('li');
            emptyLi.textContent = 'No bids awaiting verification.';
            emptyLi.classList.add('empty');
            verifyingQueueList.appendChild(emptyLi);
          } else {
            queue.forEach(function (entry, index) {
              const li = document.createElement('li');
              const valueText = entry.value != null ? entry.value : '—';
              const tokensText = entry.tokensWon != null ? ` (tokens ${entry.tokensWon})` : '';
              li.textContent = `${formatPlayerWithColor(entry.playerId)} @ ${valueText}${tokensText}`;
              if (index === currentIndex) {
                li.classList.add('current');
              }
              verifyingQueueList.appendChild(li);
            });
          }

          const currentEntry = getCurrentVerifier();
          if (currentEntry) {
            const valueText = currentEntry.value != null ? currentEntry.value : '—';
            const tokensText = currentEntry.tokensWon != null ? ` (tokens ${currentEntry.tokensWon})` : '';
            verifyingCurrent.textContent = `Current: ${formatPlayerWithColor(currentEntry.playerId)} @ ${valueText}${tokensText}`;
          } else {
            verifyingCurrent.textContent = 'Current: —';
          }

          updateVerifyButtons();
        } else {
          verifyingContainer.hidden = true;
          verifyingQueueList.innerHTML = '';
          verifyingCurrent.textContent = 'Current: —';
          lastVerifyingState = null;
          verifyInFlight = false;
          updateVerifyButtons();
          setMessage(verifyMessage, '', false);
        }

        updateHostControls(state);

        if (leader && leader.playerId != null && leader.value != null) {
          const reason = leader.leaderReason || {};
          let reasonText = '';
          if (reason.kind === 'fewer_tokens') {
            const leaderTokens = Number.isFinite(reason.leaderTokens) ? reason.leaderTokens : leader.tokensWon;
            const otherTokens = Number.isFinite(reason.otherBestTokens) ? reason.otherBestTokens : undefined;
            const otherPart = otherTokens != null ? ` vs ${otherTokens}` : '';
            reasonText = `fewer tokens: ${leaderTokens != null ? leaderTokens : '—'}${otherPart}`;
          } else if (reason.kind === 'earlier_bid') {
            let timeText = '';
            if (reason.leaderCreatedAt) {
              const parsed = Date.parse(reason.leaderCreatedAt);
              if (!Number.isNaN(parsed)) {
                timeText = new Date(parsed).toLocaleTimeString();
              }
            }
            const leaderTokens = Number.isFinite(reason.leaderTokens) ? reason.leaderTokens : leader.tokensWon;
            const otherTokens = Number.isFinite(reason.otherBestTokens) ? reason.otherBestTokens : undefined;
            const tokenPart = leaderTokens != null && otherTokens != null ? ` (tokens ${leaderTokens} vs ${otherTokens})` : '';
            reasonText = timeText ? `earlier bid at ${timeText}${tokenPart}` : `earlier bid${tokenPart}`;
          } else if (reason.kind === 'new_low') {
            const leaderTokens = Number.isFinite(reason.leaderTokens) ? reason.leaderTokens : leader.tokensWon;
            reasonText = leaderTokens != null ? `new low bid (tokens ${leaderTokens})` : 'new low bid';
          }

          const baseText = `${formatPlayerWithColor(leader.playerId)} @ ${leader.value}`;
          leadingText.textContent = reasonText ? `${baseText} (reason: ${reasonText})` : baseText;
          leadingPanel.hidden = false;
        } else {
          leadingPanel.hidden = true;
          leadingText.textContent = '';
        }

        lastServerRemaining = typeof state.remaining === 'number' ? state.remaining : null;
        const parsedServerNow = state.serverNow ? Date.parse(state.serverNow) : NaN;
        if (!Number.isNaN(parsedServerNow)) {
          lastServerTimestamp = parsedServerNow;
          if (!hasServerSkew) {
            serverSkewMs = parsedServerNow - Date.now();
            hasServerSkew = true;
          }
        } else {
          lastServerTimestamp = null;
          hasServerSkew = false;
        }

        if (lastServerRemaining == null || !hasServerSkew) {
          stopCountdownTicker();
          remainingEl.textContent = '—';
        } else {
          startCountdownTicker();
        }

        const biddingOpen = state.status === 'bidding' || state.status === 'countdown';
        setBidFormEnabled(Boolean(currentRoomCode && currentPlayerId && biddingOpen));
      }

      function estimateRemaining() {
        if (lastServerRemaining == null || lastServerTimestamp == null) {
          return null;
        }
        const serverNow = Date.now() + (hasServerSkew ? serverSkewMs : 0);
        const elapsed = Math.floor((serverNow - lastServerTimestamp) / 1000);
        return Math.max(0, lastServerRemaining - elapsed);
      }

      function runJoinFlow(code, displayName, selectedColor, options) {
        const normalizedCode = normalizeRoomCode(code);
        const sanitizedName = typeof displayName === 'string' ? displayName.trim() : '';
        const canonicalColor = canonicalizeColor(selectedColor);
        const auto = Boolean(options && options.auto);
        const showToastOnSuccess = !(options && options.showToast === false);

        if (!normalizedCode || !isValidRoomCode(normalizedCode) || !sanitizedName || !canonicalColor) {
          if (!auto && joinForm && !joinForm.hidden) {
            setJoinFormDisabled(false);
          }
          return;
        }

        if (joinInFlight) {
          if (!auto && joinForm && !joinForm.hidden) {
            setJoinFormDisabled(false);
          }
          return;
        }

        joinInFlight = true;

        if (auto) {
          setJoinFormVisible(false);
          setEditIdentityVisible(false);
          showJoinStatusBanner(`Rejoining as ${formatIdentityLabel(sanitizedName, canonicalColor)}…`);
        }

        (async function connect() {
          const previousRoomCode = currentRoomCode;

          try {
            const result = await joinOrUpdatePlayer(normalizedCode, sanitizedName, canonicalColor);
            const joinedPlayerId = Number(result.playerId) || null;
            const joinedName = result.displayName || sanitizedName;
            const joinedColor = canonicalizeColor(result.color) || canonicalColor;
            const joinedTokens = Number.isFinite(result.tokensWon) ? Number(result.tokensWon) : null;

            currentRoomCode = normalizedCode;
            currentPlayerId = joinedPlayerId;
            currentPlayerName = joinedName;
            currentPlayerColor = joinedColor;
            saveStoredPlayer(normalizedCode, currentPlayerId, currentPlayerName, currentPlayerColor);
            saveGlobalIdentity(currentPlayerId, currentPlayerName, currentPlayerColor);
            storedPlayerInfo = { playerId: currentPlayerId, displayName: currentPlayerName, color: currentPlayerColor };
            updateJoinGateRoom(currentRoomCode);
            updateColorPreview(currentPlayerColor);
            setMessage(bidMessage, '', false);
            playersFieldset.hidden = false;

            const switchingRooms = !previousRoomCode || previousRoomCode !== currentRoomCode;

            if (switchingRooms) {
              if (poller && typeof poller.stop === 'function') {
                poller.stop();
              }
              poller = null;
              resetClientState();
              playersById = {};
              hostPlayerId = null;
              renderPlayersList();
              updateHostControls({ status: 'bidding' });
            }

            if (currentPlayerId != null) {
              const existingTokens = playersById[currentPlayerId] && Number.isFinite(playersById[currentPlayerId].tokensWon)
                ? playersById[currentPlayerId].tokensWon
                : (joinedTokens != null ? joinedTokens : 0);
              playersById[currentPlayerId] = {
                playerId: currentPlayerId,
                displayName: currentPlayerName,
                color: currentPlayerColor,
                tokensWon: existingTokens
              };
              renderPlayersList();
              updateHostControls(lastStateSnapshot || { status: lastStateSnapshot ? lastStateSnapshot.status : 'bidding' });
            }

            if (!poller) {
              poller = window.PollingHelpers.createLongPoller({
                code: currentRoomCode,
                renderAll: renderAll
              });
            }

            ensureBoardReady();
            showRoomApp();
            setJoinGateVisible(false);
            maybeShowShareBanner(currentRoomCode);
            hideJoinStatusBanner();
            setMessage(joinMessage, '', false);
            setJoinFormVisible(false);
            setEditIdentityVisible(true);
            const identityLabel = formatIdentityLabel(currentPlayerName, currentPlayerColor);
            if (showToastOnSuccess) {
              showToast(`Joined as ${identityLabel}`, false);
            }
            const startResult = poller.start();
            if (startResult && typeof startResult.then === 'function') {
              await startResult;
            }
          } catch (err) {
            console.error(err);
            const message = err && err.message ? err.message : 'Unable to join the room.';
            if (auto) {
              setJoinFormVisible(true);
            }
            setEditIdentityVisible(false);
            hideJoinStatusBanner();
            setMessage(joinMessage, message, true);
            showToast(message, true);
            if (err && err.status === 404) {
              clearStoredPlayer(normalizedCode);
            }
          } finally {
            if (!auto && joinForm && !joinForm.hidden) {
              setJoinFormDisabled(false);
            }
            joinInFlight = false;
          }
        }());
      }

      joinForm.addEventListener('submit', function (event) {
        event.preventDefault();
        hideColorWarning();

        if (!window.PollingHelpers) {
          setMessage(joinMessage, 'Helpers not loaded yet. Please retry.', true);
          return;
        }

        const code = normalizeRoomCode(roomCodeInput.value);
        const displayName = playerNameInput.value.trim();
        const selectedColor = canonicalizeColor(playerColorInput.value);

        if (!code) {
          setMessage(joinMessage, 'Enter a room code to join.', true);
          return;
        }
        if (!isValidRoomCode(code)) {
          setMessage(joinMessage, 'Room codes use lowercase letters, numbers, and single hyphen (no leading, trailing, or double hyphen).', true);
          return;
        }
        if (!displayName) {
          setMessage(joinMessage, 'Enter a display name.', true);
          return;
        }
        if (!selectedColor) {
          showColorWarning('Choose one of the available player colors.');
          setMessage(joinMessage, 'Pick a valid player color.', true);
          return;
        }

        roomCodeInput.value = code;
        playerNameInput.value = displayName;
        setMessage(joinMessage, 'Joining…', false);
        setJoinFormDisabled(true);
        runJoinFlow(code, displayName, selectedColor, { auto: false });
      });

      if (editIdentityButton) {
        editIdentityButton.addEventListener('click', function () {
          if (joinInFlight) {
            return;
          }
          setJoinGateVisible(true);
          setJoinFormVisible(true);
          setEditIdentityVisible(false);
          updateJoinGateRoom(currentRoomCode || roomCodeInput.value);
          hideJoinStatusBanner();
          setMessage(joinMessage, '', false);
          hideColorWarning();
          if (playerNameInput) {
            playerNameInput.focus({ preventScroll: true });
          }
        });
      }

      if (shareCopyButton) {
        shareCopyButton.addEventListener('click', function () {
          copyShareLink();
        });
      }

      if (shareDismissButton) {
        shareDismissButton.addEventListener('click', function () {
          hideShareBanner();
        });
      }

      if (autoJoinContext && !autoJoinScheduled) {
        autoJoinScheduled = true;
        whenPollingHelpersReady(function () {
          const autoName = typeof autoJoinContext.displayName === 'string'
            ? autoJoinContext.displayName.trim()
            : '';
          const autoColor = canonicalizeColor(autoJoinContext.color);
          if (!autoName || !autoColor) {
            setJoinFormVisible(true);
            setEditIdentityVisible(false);
            hideJoinStatusBanner();
            return;
          }
          runJoinFlow(autoJoinContext.code, autoName, autoColor, { auto: true });
        }, function () {
          setJoinFormVisible(true);
          setEditIdentityVisible(false);
          hideJoinStatusBanner();
        });
      }

      bidForm.addEventListener('submit', function (event) {
        event.preventDefault();
        submitBid();
      });

      async function submitBid() {
        setMessage(bidMessage, '', false);
        if (!currentRoomCode || !currentPlayerId) {
          setMessage(bidMessage, 'Join a room first.', true);
          return;
        }
        if (!bidAllowed) {
          setMessage(bidMessage, 'Bidding is closed.', true);
          return;
        }
        const rawValue = bidInput ? bidInput.value.trim() : '';
        if (!rawValue) {
          setMessage(bidMessage, 'Enter a positive bid value.', true);
          return;
        }
        const value = Number.parseInt(rawValue, 10);
        if (!Number.isFinite(value) || value <= 0) {
          setMessage(bidMessage, 'Enter a positive bid value.', true);
          return;
        }
        if (bidInFlight) {
          return;
        }

        bidInFlight = true;
        updateBidFormState();
        try {
          await window.PollingHelpers.submitBid(currentRoomCode, currentPlayerId, value);
          if (bidInput) {
            bidInput.value = '';
            if (!bidInput.disabled) {
              bidInput.focus({ preventScroll: true });
            }
          }
        } catch (err) {
          console.error(err);
          const message = err && err.message ? err.message : 'Bid failed.';
          setMessage(bidMessage, message, true);
          showToast(message, true);
          if (message.toLowerCase().includes('bidding is closed')) {
            setBidFormEnabled(false);
          }
        } finally {
          bidInFlight = false;
          updateBidFormState();
        }
      }

      setBidFormEnabled(false);
      setMessage(verifyMessage, '', false);
      updateVerifyButtons();

      verifyPassButton.addEventListener('click', function () {
        if (!currentRoomCode) {
          setMessage(verifyMessage, 'Join a room first.', true);
          return;
        }

        if (hostPlayerId == null || currentPlayerId == null || currentPlayerId !== hostPlayerId) {
          setMessage(verifyMessage, 'Only the host can mark verification results.', true);
          return;
        }

        const currentEntry = getCurrentVerifier();
        if (!currentEntry) {
          setMessage(verifyMessage, 'No verifier available.', true);
          return;
        }

        verifyInFlight = true;
        updateVerifyButtons();
        setMessage(verifyMessage, '', false);

        window.PollingHelpers.verifyPass(currentRoomCode, currentPlayerId).then(function () {
          setMessage(verifyMessage, `Marked ${formatPlayerLabel(currentEntry.playerId)} as solved.`, false);
        }).catch(function (err) {
          console.error(err);
          const message = err && err.message ? err.message : 'Verification update failed.';
          setMessage(verifyMessage, message, true);
        }).finally(function () {
          verifyInFlight = false;
          updateVerifyButtons();
        });
      });

      verifyFailButton.addEventListener('click', function () {
        if (!currentRoomCode) {
          setMessage(verifyMessage, 'Join a room first.', true);
          return;
        }

        if (hostPlayerId == null || currentPlayerId == null || currentPlayerId !== hostPlayerId) {
          setMessage(verifyMessage, 'Only the host can advance the queue.', true);
          return;
        }

        const currentEntry = getCurrentVerifier();
        if (!currentEntry) {
          setMessage(verifyMessage, 'No verifier available.', true);
          return;
        }

        verifyInFlight = true;
        updateVerifyButtons();
        setMessage(verifyMessage, '', false);

        window.PollingHelpers.verifyFail(currentRoomCode, currentPlayerId).then(function () {
          setMessage(verifyMessage, 'Advanced to next verifier.', false);
        }).catch(function (err) {
          console.error(err);
          const message = err && err.message ? err.message : 'Verification update failed.';
          setMessage(verifyMessage, message, true);
        }).finally(function () {
          verifyInFlight = false;
          updateVerifyButtons();
        });
      });

      if (claimHostButton) {
        claimHostButton.addEventListener('click', function () {
          if (!currentRoomCode || !currentPlayerId) {
            showToast('Join a room first.', true);
            return;
          }
          if (hostPlayerId != null && currentPlayerId !== hostPlayerId) {
            showToast('Host already assigned.', true);
            return;
          }

          claimInFlight = true;
          claimHostButton.disabled = true;
          claimHostOnServer(currentRoomCode, currentPlayerId).then(function () {
            hostPlayerId = currentPlayerId;
            renderPlayersList();
            updateHostControls(lastStateSnapshot || { status: lastStateSnapshot ? lastStateSnapshot.status : 'bidding' });
            showToast('You are now the host.', false);
          }).catch(function (err) {
            console.error(err);
            const message = err && err.message ? err.message : 'Unable to claim host role.';
            showToast(message, true);
          }).finally(function () {
            claimInFlight = false;
            renderPlayersList();
          });
        });
      }

      if (nextRoundButton) {
        nextRoundButton.addEventListener('click', function () {
          if (!currentRoomCode || !currentPlayerId) {
            setMessage(nextMessage, 'Join a room first.', true);
            return;
          }
          if (hostPlayerId == null || currentPlayerId !== hostPlayerId) {
            setMessage(nextMessage, 'Only the host can start the next round.', true);
            return;
          }

          nextInFlight = true;
          nextRoundButton.disabled = true;
          setMessage(nextMessage, '', false);

          window.PollingHelpers.startNextRound(currentRoomCode, currentPlayerId).then(function () {
            setMessage(nextMessage, 'Next round requested.', false);
          }).catch(function (err) {
            console.error(err);
            const message = err && err.message ? err.message : 'Unable to start next round.';
            setMessage(nextMessage, message, true);
          }).finally(function () {
            nextInFlight = false;
            updateHostControls(lastStateSnapshot || { status: lastStateSnapshot ? lastStateSnapshot.status : 'complete' });
          });
        });
      }

      function showToast(message, isError) {
        if (!toastEl) {
          return;
        }
        if (toastTimeoutId) {
          clearTimeout(toastTimeoutId);
        }
        toastEl.textContent = message;
        toastEl.setAttribute('aria-live', isError ? 'assertive' : 'polite');
        toastEl.classList.remove('toast--error', 'toast--info', 'toast--visible');
        void toastEl.offsetWidth;
        toastEl.classList.add(isError ? 'toast--error' : 'toast--info');
        toastEl.classList.add('toast--visible');
        toastTimeoutId = window.setTimeout(hideToast, 4000);
      }

      function hideToast() {
        if (!toastEl) {
          return;
        }
        toastEl.classList.remove('toast--visible');
      }

      function ensureCellWall(row, col) {
        if (row < 0 || row >= BOARD_SIZE || col < 0 || col >= BOARD_SIZE) {
          return null;
        }
        const key = `${row},${col}`;
        if (!boardWalls.has(key)) {
          boardWalls.set(key, { top: false, bottom: false, left: false, right: false });
        }
        return boardWalls.get(key);
      }

      function addWall(row, col, side) {
        const cell = ensureCellWall(row, col);
        if (!cell) {
          return;
        }
        cell[side] = true;
        const relation = WALL_RELATIONS[side];
        if (!relation) {
          return;
        }
        const neighborRow = row + relation.dr;
        const neighborCol = col + relation.dc;
        const neighborCell = ensureCellWall(neighborRow, neighborCol);
        if (neighborCell) {
          neighborCell[relation.opposite] = true;
        }
      }

      function buildWallData() {
        boardWalls.clear();
        for (let r = 0; r < BOARD_SIZE; r += 1) {
          for (let c = 0; c < BOARD_SIZE; c += 1) {
            ensureCellWall(r, c);
          }
        }
        Object.entries(STATIC_WALL_DATA).forEach(function ([key, arr]) {
          if (!Array.isArray(arr) || arr.length < 4) {
            return;
          }
          const parts = key.split(',');
          const row = Number.parseInt(parts[0], 10);
          const col = Number.parseInt(parts[1], 10);
          if (!Number.isFinite(row) || !Number.isFinite(col)) {
            return;
          }
          if (arr[0]) {
            addWall(row, col, 'top');
          }
          if (arr[1]) {
            addWall(row, col, 'bottom');
          }
          if (arr[2]) {
            addWall(row, col, 'left');
          }
          if (arr[3]) {
            addWall(row, col, 'right');
          }
        });
        CENTER_CELLS.forEach(function (pair) {
          const row = pair[0];
          const col = pair[1];
          ['top', 'bottom', 'left', 'right'].forEach(function (side) {
            addWall(row, col, side);
          });
        });
      }

      function buildBoardGrid() {
        if (!boardGridEl) {
          return;
        }
        const fragment = document.createDocumentFragment();
        boardGridEl.innerHTML = '';
        for (let r = 0; r < BOARD_SIZE; r += 1) {
          for (let c = 0; c < BOARD_SIZE; c += 1) {
            const cell = document.createElement('div');
            cell.className = 'board-cell';
            cell.dataset.row = String(r);
            cell.dataset.col = String(c);
            const cellWalls = boardWalls.get(`${r},${c}`);
            if (cellWalls) {
              if (cellWalls.top) {
                cell.classList.add('wall-top');
              }
              if (cellWalls.bottom) {
                cell.classList.add('wall-bottom');
              }
              if (cellWalls.left) {
                cell.classList.add('wall-left');
              }
              if (cellWalls.right) {
                cell.classList.add('wall-right');
              }
            }
            fragment.appendChild(cell);
          }
        }
        boardGridEl.appendChild(fragment);
      }

      function initializeRobots() {
        ROBOT_ORDER.forEach(function (name) {
          const start = INITIAL_ROBOT_POSITIONS[name] || { row: 0, col: 0 };
          const clampedRow = Math.max(0, Math.min(BOARD_SIZE - 1, start.row));
          const clampedCol = Math.max(0, Math.min(BOARD_SIZE - 1, start.col));
          robotState[name] = { row: clampedRow, col: clampedCol };
        });
      }

      function renderRobotBadges() {
        if (!robotBadgesEl) {
          return;
        }
        robotBadgesEl.innerHTML = '';
        const fragment = document.createDocumentFragment();
        ROBOT_ORDER.forEach(function (name) {
          const meta = ROBOT_META[name];
          if (!meta) {
            return;
          }
          const button = document.createElement('button');
          button.type = 'button';
          button.className = `robot-badge ${meta.badgeClass}`;
          button.dataset.robot = name;
          button.textContent = name;
          button.setAttribute('aria-pressed', 'false');
          button.addEventListener('click', function () {
            selectRobotByName(name);
            if (boardEl) {
              boardEl.focus({ preventScroll: true });
            }
          });
          fragment.appendChild(button);
        });
        robotBadgesEl.appendChild(fragment);
      }

      function renderRobots() {
        if (!robotLayerEl) {
          return;
        }
        robotLayerEl.innerHTML = '';
        const fragment = document.createDocumentFragment();
        ROBOT_ORDER.forEach(function (name) {
          const state = robotState[name];
          const meta = ROBOT_META[name];
          if (!state || !meta) {
            return;
          }
          const robotEl = document.createElement('div');
          robotEl.className = `robot ${meta.robotClass}`;
          robotEl.dataset.robot = name;
          robotEl.style.setProperty('--row', String(state.row));
          robotEl.style.setProperty('--col', String(state.col));
          robotEl.setAttribute('role', 'img');
          robotEl.setAttribute('aria-label', `${name} robot at row ${state.row} column ${state.col}`);
          robotEl.tabIndex = -1;
          const label = document.createElement('span');
          label.className = 'robot-label';
          label.textContent = meta.shortLabel;
          robotEl.appendChild(label);
          robotEl.addEventListener('click', function () {
            selectRobotByName(name);
            if (boardEl) {
              boardEl.focus({ preventScroll: true });
            }
          });
          fragment.appendChild(robotEl);
        });
        robotLayerEl.appendChild(fragment);
        updateSelectedRobotStyles();
      }

      function highlightSelectedCell() {
        if (!boardGridEl) {
          return;
        }
        boardGridEl.querySelectorAll('.board-cell.is-selected').forEach(function (cell) {
          cell.classList.remove('is-selected');
        });
        const currentName = ROBOT_ORDER[robotIdx];
        const state = robotState[currentName];
        if (!state) {
          return;
        }
        const cell = boardGridEl.querySelector(`.board-cell[data-row="${state.row}"][data-col="${state.col}"]`);
        if (cell) {
          cell.classList.add('is-selected');
        }
      }

      function updateSelectedRobotStyles() {
        const currentName = ROBOT_ORDER[robotIdx];
        if (robotBadgesEl) {
          robotBadgesEl.querySelectorAll('.robot-badge').forEach(function (badge) {
            const isCurrent = badge.dataset.robot === currentName;
            badge.classList.toggle('is-selected', isCurrent);
            badge.setAttribute('aria-pressed', isCurrent ? 'true' : 'false');
          });
        }
        if (robotLayerEl) {
          robotLayerEl.querySelectorAll('.robot').forEach(function (robotEl) {
            const isCurrent = robotEl.dataset.robot === currentName;
            robotEl.classList.toggle('is-selected', isCurrent);
            robotEl.setAttribute('aria-current', isCurrent ? 'true' : 'false');
          });
        }
        if (boardSelectionEl) {
          if (currentName && robotState[currentName]) {
            const pos = robotState[currentName];
            boardSelectionEl.textContent = `Selected robot: ${currentName} (${pos.row}, ${pos.col})`;
          } else {
            boardSelectionEl.textContent = 'Selected robot: —';
          }
        }
        highlightSelectedCell();
      }

      function selectRobotByIndex(index) {
        if (!ROBOT_ORDER.length) {
          return;
        }
        const normalized = ((index % ROBOT_ORDER.length) + ROBOT_ORDER.length) % ROBOT_ORDER.length;
        robotIdx = normalized;
        updateSelectedRobotStyles();
      }

      function selectRobotByName(name) {
        const nextIndex = ROBOT_ORDER.indexOf(name);
        if (nextIndex === -1) {
          return;
        }
        selectRobotByIndex(nextIndex);
      }

      function isRobotAt(row, col, ignoreName) {
        return ROBOT_ORDER.some(function (name) {
          if (name === ignoreName) {
            return false;
          }
          const state = robotState[name];
          return state && state.row === row && state.col === col;
        });
      }

      function hasWall(row, col, side) {
        if (row < 0 || row >= BOARD_SIZE || col < 0 || col >= BOARD_SIZE) {
          return true;
        }
        const cell = boardWalls.get(`${row},${col}`);
        return cell ? Boolean(cell[side]) : false;
      }

      function canMove(row, col, direction) {
        switch (direction) {
          case 'UP':
            return row > 0 && !hasWall(row, col, 'top') && !hasWall(row - 1, col, 'bottom');
          case 'DOWN':
            return row < BOARD_SIZE - 1 && !hasWall(row, col, 'bottom') && !hasWall(row + 1, col, 'top');
          case 'LEFT':
            return col > 0 && !hasWall(row, col, 'left') && !hasWall(row, col - 1, 'right');
          case 'RIGHT':
            return col < BOARD_SIZE - 1 && !hasWall(row, col, 'right') && !hasWall(row, col + 1, 'left');
          default:
            return false;
        }
      }

      function moveOne(row, col, direction) {
        switch (direction) {
          case 'UP':
            return { row: row - 1, col: col };
          case 'DOWN':
            return { row: row + 1, col: col };
          case 'LEFT':
            return { row: row, col: col - 1 };
          case 'RIGHT':
            return { row: row, col: col + 1 };
          default:
            return { row: row, col: col };
        }
      }

      function computeSlide(row, col, direction, ignoreName) {
        let nextRow = row;
        let nextCol = col;
        while (canMove(nextRow, nextCol, direction)) {
          const candidate = moveOne(nextRow, nextCol, direction);
          if (isRobotAt(candidate.row, candidate.col, ignoreName)) {
            break;
          }
          nextRow = candidate.row;
          nextCol = candidate.col;
        }
        return { row: nextRow, col: nextCol };
      }

      function slideSelectedRobot(direction) {
        const currentName = ROBOT_ORDER[robotIdx];
        const state = robotState[currentName];
        if (!state) {
          return;
        }
        const next = computeSlide(state.row, state.col, direction, currentName);
        if (next.row === state.row && next.col === state.col) {
          return;
        }
        state.row = next.row;
        state.col = next.col;
        renderRobots();
      }

      function handleBoardKeydown(event) {
        if (!boardActive) {
          return;
        }
        if (event.key === 'Escape') {
          if (boardEl) {
            boardEl.blur();
          }
          return;
        }
        if (event.key === 'Tab') {
          event.preventDefault();
          const delta = event.shiftKey ? -1 : 1;
          selectRobotByIndex(robotIdx + delta);
          return;
        }
        const key = event.key.length === 1 ? event.key.toLowerCase() : event.key;
        const direction = KEY_TO_DIR[key] || KEY_TO_DIR[event.key];
        if (!direction) {
          return;
        }
        event.preventDefault();
        slideSelectedRobot(direction);
      }

      function handleArrowClick(event) {
        const target = event.target.closest('button[data-dir]');
        if (!target) {
          return;
        }
        const direction = target.getAttribute('data-dir');
        if (!direction) {
          return;
        }
        slideSelectedRobot(direction);
        if (boardEl) {
          boardEl.focus({ preventScroll: true });
        }
      }

      function initBoard() {
        if (boardInitialized) {
          return;
        }
        if (!boardEl || !boardGridEl || !robotLayerEl) {
          return;
        }
        boardInitialized = true;
        if (boardEl.tabIndex < 0) {
          boardEl.tabIndex = 0;
        }
        boardEl.classList.remove('is-focused');
        buildWallData();
        buildBoardGrid();
        initializeRobots();
        renderRobotBadges();
        renderRobots();
        boardEl.addEventListener('focus', function () {
          boardActive = true;
          boardEl.classList.add('is-focused');
        });
        boardEl.addEventListener('blur', function () {
          boardActive = false;
          boardEl.classList.remove('is-focused');
        });
        boardEl.addEventListener('mousedown', function () {
          boardEl.focus({ preventScroll: true });
        });
        boardEl.addEventListener('touchstart', function () {
          boardEl.focus({ preventScroll: true });
        }, { passive: true });
        window.addEventListener('keydown', handleBoardKeydown);
        if (arrowControlsEl) {
          arrowControlsEl.addEventListener('click', handleArrowClick);
        }
        updateSelectedRobotStyles();
      }

      function ensureBoardReady() {
        if (!boardInitialized) {
          initBoard();
        }
      }

      if (toastEl) {
        toastEl.addEventListener('click', hideToast);
      }

      async function postJson(url, payload) {
        const res = await fetch(url, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(payload)
        });
        let data = null;
        try {
          data = await res.json();
        } catch (err) {
          data = null;
        }
        if (!res.ok) {
          const message = data && data.error ? data.error : 'Request failed.';
          const error = new Error(message);
          error.status = res.status;
          throw error;
        }
        return data || {};
      }

      async function ensureRoomCreated(code) {
        const normalized = normalizeRoomCode(code);
        if (!normalized || !ROOM_CODE_PATTERN.test(normalized) || DOUBLE_HYPHEN_PATTERN.test(normalized)) {
          throw new Error('Room code is required.');
        }
        const res = await fetch(`/api/rooms/${encodeURIComponent(normalized)}/create`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({})
        });
        let data = null;
        try {
          data = await res.json();
        } catch (err) {
          data = null;
        }
        if (res.ok) {
          return data && data.message ? data.message : '';
        }
        if (res.status === 409) {
          return data && data.error ? data.error : '';
        }
        const errorText = data && data.error ? data.error : 'Unable to create room.';
        const error = new Error(errorText);
        error.status = res.status;
        throw error;
      }

      async function joinRoomOnServer(code, displayName, color) {
        const normalized = normalizeRoomCode(code);
        if (!normalized || !ROOM_CODE_PATTERN.test(normalized) || DOUBLE_HYPHEN_PATTERN.test(normalized)) {
          throw new Error('Room code is required.');
        }
        const url = `/api/rooms/${encodeURIComponent(normalized)}/players/join`;
        try {
          return await postJson(url, { displayName: displayName, color: color });
        } catch (err) {
          if (err && err.status === 404) {
            await ensureRoomCreated(normalized);
            return await postJson(url, { displayName: displayName, color: color });
          }
          throw err;
        }
      }

      async function updatePlayerOnServer(code, playerId, displayName, color) {
        const normalized = normalizeRoomCode(code);
        if (!normalized || !ROOM_CODE_PATTERN.test(normalized) || DOUBLE_HYPHEN_PATTERN.test(normalized)) {
          throw new Error('Room code is required.');
        }
        const body = { playerId: Number(playerId) };
        if (typeof displayName === 'string') {
          body.displayName = displayName;
        }
        if (typeof color === 'string') {
          body.color = color;
        }
        return await postJson(`/api/rooms/${encodeURIComponent(normalized)}/players/update`, body);
      }

      async function joinOrUpdatePlayer(code, displayName, color) {
        const normalized = normalizeRoomCode(code);
        if (!normalized || !ROOM_CODE_PATTERN.test(normalized) || DOUBLE_HYPHEN_PATTERN.test(normalized)) {
          throw new Error('Enter a valid room code.');
        }
        const trimmedName = displayName.trim();
        if (!trimmedName) {
          throw new Error('Display name is required.');
        }
        const canonicalColor = canonicalizeColor(color);
        if (!canonicalColor) {
          throw new Error('Pick a valid player color.');
        }

        if (currentPlayerId) {
          try {
            return await updatePlayerOnServer(normalized, currentPlayerId, trimmedName, canonicalColor);
          } catch (err) {
            if (!err || err.status !== 404) {
              throw err;
            }
            currentPlayerId = null;
          }
        }

        const stored = storedPlayerInfo && storedPlayerInfo.playerId ? storedPlayerInfo : loadStoredPlayer(normalized);
        if (stored && stored.playerId) {
          try {
            const updated = await updatePlayerOnServer(normalized, stored.playerId, trimmedName, canonicalColor);
            return updated;
          } catch (err) {
            if (!err || err.status !== 404) {
              throw err;
            }
            clearStoredPlayer(normalized);
          }
        }

        return await joinRoomOnServer(normalized, trimmedName, canonicalColor);
      }

      async function claimHostOnServer(code, playerId) {
        const normalized = normalizeRoomCode(code);
        if (!normalized || !ROOM_CODE_PATTERN.test(normalized) || DOUBLE_HYPHEN_PATTERN.test(normalized)) {
          throw new Error('Room code is required.');
        }
        return await postJson(`/api/rooms/${encodeURIComponent(normalized)}/players/claim-host`, { playerId: Number(playerId) });
      }
    }());
  </script>
</body>
</html>
