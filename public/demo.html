<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Ricochet Robot Bidding Demo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <style>
    body { font-family: system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif; margin: 2rem; background: #f7f7f7; }
    h1 { margin-bottom: 0.5rem; }
    fieldset { border: 1px solid #ccc; padding: 0.75rem; margin-bottom: 0.75rem; background: #fff; }
    label { display: block; margin-bottom: 0.5rem; }
    input, select, button { padding: 0.5rem; font-size: 1rem; }
    .status { font-size: 1.25rem; margin: 0.5rem 0; }
    
    .puzzle-progress {
      margin-bottom: 0.75rem;
      font-size: 1rem;
      font-weight: bold;
      color: #059669;
      background: #d1fae5;
      padding: 0.5rem;
      border-radius: 0.375rem;
      text-align: center;
    }
    .start-game-container {
      margin-bottom: 0.75rem;
      text-align: center;
      padding: 1rem;
      background: #f0f9ff;
      border: 2px solid #0ea5e9;
      border-radius: 0.5rem;
    }
    .start-game-container button {
      font-size: 1.2rem;
      padding: 0.75rem 1.5rem;
      margin-bottom: 0.5rem;
    }
    .start-game-message {
      font-size: 0.9rem;
      color: #0369a1;
      font-weight: 500;
    }
    .timer { font-size: 2rem; font-weight: bold; }
    ul { padding-left: 1.5rem; }
    .columns { display: flex; flex-wrap: wrap; gap: 1.5rem; }
    .columns > div { flex: 1 1 250px; }
    table { width: 100%; border-collapse: collapse; }
    th, td { border: 1px solid #ddd; padding: 0.5rem; text-align: left; }
    .error { color: #b00020; }
    .message { margin-left: 1rem; font-size: 0.9rem; color: #333; }
    .message.error { color: #b00020; }
    body.join-gate-open { overflow: hidden; }
    .join-gate { position: fixed; inset: 0; background: rgba(15, 23, 42, 0.55); backdrop-filter: blur(6px); display: flex; align-items: center; justify-content: center; padding: 1.5rem; z-index: 900; }
    .join-gate[hidden] { display: none; }
    .join-gate__panel { width: min(480px, 100%); background: #fff; border-radius: 16px; padding: 1.5rem; box-shadow: 0 24px 60px rgba(15, 23, 42, 0.3); }
    .join-gate__panel h1 { margin-top: 0; margin-bottom: 0.5rem; font-size: 1.6rem; }
    .join-gate__room { margin: 0 0 1.25rem; font-size: 0.95rem; color: #475569; font-weight: 600; }
    .join-gate__room code { display: inline-block; padding: 0.2rem 0.45rem; border-radius: 6px; background: #eef2ff; color: #1d4ed8; }
    .join-gate form { display: grid; gap: 0.9rem; }
    .join-gate label { font-weight: 600; margin-bottom: 0.35rem; color: #111827; }
    .join-gate input, .join-gate select { width: 100%; box-sizing: border-box; }
    .join-gate button[type="submit"] { margin-top: 0.25rem; }
    .join-gate__status { margin-top: 0.75rem; }
    .share-banner { margin-bottom: 1.25rem; padding: 0.75rem 1rem; border-radius: 8px; border: 1px solid #facc15; background: #fef3c7; color: #92400e; display: flex; flex-wrap: wrap; gap: 0.75rem; align-items: center; }
    .share-banner.hidden { display: none !important; }
    .share-banner__text { font-weight: 600; }
    .share-banner__link { font-weight: 600; color: inherit; word-break: break-word; text-decoration: none; }
    .share-banner__link:focus-visible, .share-banner__link:hover { text-decoration: underline; }
    .share-banner__actions { margin-left: auto; display: flex; gap: 0.5rem; align-items: center; }
    .share-banner__dismiss { border: none; background: transparent; font-size: 1.15rem; line-height: 1; color: inherit; cursor: pointer; padding: 0.25rem; border-radius: 6px; }
    .share-banner__dismiss:hover, .share-banner__dismiss:focus-visible { background: rgba(250, 204, 21, 0.25); outline: none; }
    .leading-panel { margin-top: 0.75rem; padding: 0.75rem; background: #e9f5ff; border: 1px solid #9cc9f1; border-radius: 4px; }
    .leading-panel strong { font-weight: 600; }
    #bids { list-style: none; padding-left: 0; }
    #bids li { margin-bottom: 0.35rem; padding: 0.35rem 0.5rem; border-radius: 4px; background: #fff; border: 1px solid #eee; }
    #bids li.bid-tie { border-color: #c5d6f2; background: #f2f6ff; font-weight: 600; }
    #bids li.bid-leading { border-color: #58a55c; background: #e6f6e6; color: #1f6e25; }
    .verifying-panel { margin-top: 1rem; padding: 0.75rem; background: #fff4e5; border: 1px solid #f5c48b; border-radius: 4px; }
    .verifying-panel h3 { margin: 0 0 0.5rem; font-size: 1.1rem; }
    #verifying-current { font-weight: 600; margin-bottom: 0.5rem; }
    #verifying-queue { list-style: decimal inside; padding-left: 1rem; margin: 0; }
    #verifying-queue li { padding: 0.25rem 0; }
    #verifying-queue li.current { font-weight: 700; color: #a05a00; }
    #verifying-queue li.empty { list-style: none; font-style: italic; color: #555; }
    .verify-buttons { margin-top: 0.75rem; display: flex; flex-wrap: wrap; gap: 0.5rem; align-items: center; }
    .board-wrapper { display: flex; flex-wrap: wrap; gap: 1.5rem; align-items: flex-start; }
    .game-layout { display: flex; gap: 1.5rem; min-height: 100vh; }
    .game-column { flex: 1; display: flex; flex-direction: column; gap: 0.75rem; }
    .game-column-left { max-width: 50%; }
    .game-column-right { max-width: 50%; }
    @media (max-width: 1024px) {
      .game-layout { flex-direction: column; }
      .game-column-left, .game-column-right { max-width: 100%; }
    }
    #board { --cell-count: 16; background: #fff; border: 2px solid #d0d5dd; border-radius: 10px; width: 100%; max-width: 100%; padding: 0; outline: none; box-shadow: 0 10px 30px rgba(15, 23, 42, 0.08); }
    #board:focus-visible { box-shadow: 0 0 0 4px rgba(59, 130, 246, 0.35), 0 10px 30px rgba(15, 23, 42, 0.1); }
    .board.is-focused { box-shadow: 0 0 0 4px rgba(59, 130, 246, 0.25), 0 10px 30px rgba(15, 23, 42, 0.1); }
    .board-surface { position: relative; width: 100%; padding-bottom: 100%; }
    .board-grid, .robot-layer { position: absolute; inset: 0; }
    .board-grid { display: grid; grid-template-columns: repeat(16, 1fr); grid-template-rows: repeat(16, 1fr); }
    .board-cell { border: 1px solid #d1d5db; background: #fdfdfd; position: relative; }
    .board-cell.wall-top { border-top-width: 4px; border-top-color: #1f2937; }
    .board-cell.wall-bottom { border-bottom-width: 4px; border-bottom-color: #1f2937; }
    .board-cell.wall-left { border-left-width: 4px; border-left-color: #1f2937; }
    .board-cell.wall-right { border-right-width: 4px; border-right-color: #1f2937; }
    .board-cell.is-selected::after { content: ''; position: absolute; inset: 3px; border-radius: 6px; border: 2px solid rgba(59, 130, 246, 0.8); pointer-events: none; }
    .board-cell.center-cell { border: none; background: #1f2937; }
    .robot-layer { pointer-events: none; --cell-count: 16; }
    .robot { pointer-events: auto; position: absolute; width: calc(100% / 16 - 6px); height: calc(100% / 16 - 6px); border-radius: 50%; display: flex; align-items: center; justify-content: center; font-weight: 700; color: #fff; box-shadow: 0 6px 14px rgba(15, 23, 42, 0.2); user-select: none; transition: all 160ms ease; border: 2px solid #1f2937; }
    .robot-label { font-size: 0.9rem; text-transform: uppercase; letter-spacing: 0.05em; }
    .robot-purple { background: linear-gradient(135deg, #482878, #3a1f5c); }  /* Indigo */
    .robot-cyan { background: linear-gradient(135deg, #26828e, #1e6b73); }    /* Cyan */
    .robot-lime { background: linear-gradient(135deg, #90d743, #7bb83a); }    /* Lime */
    .robot-yellow { background: linear-gradient(135deg, #fde725, #e6d01a); color: #1f2937; }  /* Yellow */
    
    .robot.is-selected { box-shadow: 0 0 0 3px #fff, 0 0 0 6px rgba(59, 130, 246, 0.65); }
    .board-sidebar { flex: 1 1 220px; max-width: 320px; display: flex; flex-direction: column; gap: 1rem; }
    .board-selection { font-weight: 600; font-size: 1rem; }
    .robot-badges { display: flex; flex-wrap: wrap; gap: 0.5rem; }
    .robot-badge { border-radius: 999px; padding: 0.4rem 0.9rem; border: 1px solid #d1d5db; background: #fff; font-weight: 600; cursor: pointer; transition: transform 120ms ease, box-shadow 120ms ease; }
    .robot-badge:hover, .robot-badge:focus-visible { transform: translateY(-1px); box-shadow: 0 6px 12px rgba(59, 130, 246, 0.2); outline: none; }
    .robot-badge-purple { color: #482878; }  /* Indigo */
    .robot-badge-cyan { color: #26828e; }     /* Cyan */
    .robot-badge-lime { color: #90d743; }    /* Lime */
    .robot-badge-yellow { color: #fde725; }  /* Yellow */
    .robot-badge.is-selected { box-shadow: 0 0 0 2px rgba(59, 130, 246, 0.4); }
    .arrow-controls { display: grid; grid-template-columns: repeat(3, 48px); grid-template-rows: repeat(3, 48px); gap: 0.35rem; justify-content: flex-start; justify-items: center; align-items: center; }
    .arrow-button { border: 1px solid #d1d5db; background: #fff; border-radius: 12px; font-size: 1.25rem; font-weight: 600; display: flex; align-items: center; justify-content: center; cursor: pointer; transition: transform 120ms ease, box-shadow 120ms ease; }
    .arrow-button:hover, .arrow-button:focus-visible { transform: translateY(-1px); box-shadow: 0 8px 20px rgba(59, 130, 246, 0.25); outline: none; }
    .arrow-button.arrow-up { grid-column: 2; grid-row: 1; }
    .arrow-button.arrow-left { grid-column: 1; grid-row: 2; }
    .arrow-button.arrow-right { grid-column: 3; grid-row: 2; }
    .arrow-button.arrow-down { grid-column: 2; grid-row: 3; }
    .color-picker { display: flex; align-items: center; gap: 0.5rem; }
    .color-preview { width: 1.5rem; height: 1.5rem; border-radius: 50%; border: 1px solid #d1d5db; background: #f3f4f6; display: inline-block; }
    .banner { margin-top: 0.75rem; padding: 0.5rem 0.75rem; border-radius: 6px; border: 1px solid #facc15; background: #fef3c7; color: #92400e; font-size: 0.95rem; }
    .join-actions { margin-top: 0.75rem; display: flex; flex-wrap: wrap; gap: 0.5rem; align-items: center; }
    .players-header { display: flex; align-items: center; justify-content: space-between; margin-bottom: 0.5rem; }
    button.secondary { padding: 0.5rem 0.9rem; font-weight: 600; border-radius: 6px; border: 1px solid #2563eb; background: #fff; color: #2563eb; cursor: pointer; transition: background 120ms ease, color 120ms ease; }
    button.secondary:hover, button.secondary:focus-visible { background: #eff6ff; color: #1d4ed8; }
    .host-controls { margin-top: 0.5rem; display: flex; flex-wrap: wrap; gap: 0.5rem; align-items: center; }
    .controls-layout { display: flex; gap: 1rem; align-items: flex-start; }
    .controls-main { flex: 1; display: flex; flex-direction: column; gap: 0.75rem; }
    .controls-help { flex: 0 0 200px; }
    .board-help { background: #f9fafb; border: 1px solid #e5e7eb; border-radius: 8px; padding: 0.5rem 0.75rem; font-size: 0.9rem; }
    .board-help summary { font-weight: 600; cursor: pointer; list-style: none; }
    .board-help summary::-webkit-details-marker { display: none; }
    .board-help summary::after { content: '⌄'; float: right; transform: rotate(0deg); transition: transform 120ms ease; }
    .board-help[open] summary::after { transform: rotate(180deg); }
    .board-help ul { margin: 0.5rem 0 0; padding-left: 1rem; }
    .board-help li { margin-bottom: 0.25rem; }
    .toast { position: fixed; bottom: 1.5rem; left: 50%; transform: translateX(-50%) translateY(16px); background: #111827; color: #fff; padding: 0.75rem 1.25rem; border-radius: 999px; box-shadow: 0 16px 32px rgba(15, 23, 42, 0.2); opacity: 0; pointer-events: none; transition: opacity 150ms ease, transform 150ms ease; z-index: 1000; font-weight: 600; }
    .toast.toast--visible { opacity: 1; transform: translateX(-50%) translateY(0); }
    .toast.toast--error { background: #b91c1c; }
    .toast.toast--info { background: #2563eb; }
    .emoji-target { 
      font-size: 2rem; 
      display: block; 
      text-align: center; 
      line-height: 1; 
      font-weight: bold;
      text-shadow: 0 1px 2px rgba(0,0,0,0.3);
    }
    
    .quad-symbol {
      display: grid !important;
      grid-template-columns: 1fr 1fr;
      grid-template-rows: 1fr 1fr;
      gap: 2px;
      width: 1.5rem;
      height: 1.5rem;
      margin: 0 auto;
    }
    
    .quad-square {
      width: 100%;
      height: 100%;
      border-radius: 2px;
    }
    
    .current-target {
      margin: 0.75rem 0;
      padding: 0.75rem;
      background: #f8fafc;
      border: 2px solid #e2e8f0;
      border-radius: 8px;
      text-align: center;
    }
    
    .target-placeholder {
      color: #64748b;
      font-style: italic;
    }
    
    .target-single, .target-quad {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 0.5rem;
    }
    
    .target-symbol {
      font-size: 2rem;
      font-weight: bold;
      text-shadow: 0 1px 2px rgba(0,0,0,0.3);
    }
    
    .target-label {
      font-size: 0.9rem;
      font-weight: 600;
      color: #374151;
    }
    
    .target-quad .quad-symbol {
      display: grid;
      grid-template-columns: 1fr 1fr;
      grid-template-rows: 1fr 1fr;
      gap: 2px;
      width: 2rem;
      height: 2rem;
    }
    
    .target-highlight {
      background: rgba(59, 130, 246, 0.2) !important;
      border: 2px solid rgba(59, 130, 246, 0.6) !important;
    }
    
    .sandbox-controls {
      display: flex;
      gap: 0.5rem;
      margin-top: 0.75rem;
      flex-wrap: wrap;
    }
    
    .sandbox-controls button {
      font-size: 0.9rem;
      padding: 0.4rem 0.8rem;
    }
    
    .demonstration-controls {
      display: flex;
      gap: 0.5rem;
      margin-top: 0.75rem;
      flex-wrap: wrap;
      align-items: center;
    }
    
    .demonstration-controls button {
      font-size: 0.9rem;
      padding: 0.4rem 0.8rem;
    }
    
    .move-counter {
      font-size: 1.8rem;
      font-weight: bold;
      color: white;
      background: linear-gradient(135deg, #3498db, #2980b9);
      padding: 1rem 1.5rem;
      border-radius: 1rem;
      border: 3px solid #2980b9;
      box-shadow: 0 4px 8px rgba(0,0,0,0.2);
      text-align: center;
      min-width: 120px;
      margin-bottom: 1rem;
    }
    
    
    .mobile-controls {
      display: none;
      flex-direction: column;
      align-items: center;
      gap: 1rem;
      margin-top: 1rem;
    }
    
    .radial-pad {
      position: relative;
      width: 120px;
      height: 120px;
      border-radius: 50%;
      background: #f3f4f6;
      border: 2px solid #d1d5db;
      display: flex;
      align-items: center;
      justify-content: center;
      touch-action: none;
    }
    
    .radial-pad-center {
      width: 40px;
      height: 40px;
      border-radius: 50%;
      background: #6b7280;
      position: relative;
    }
    
    .radial-pad-direction {
      position: absolute;
      width: 30px;
      height: 30px;
      border-radius: 50%;
      background: #3b82f6;
      color: white;
      display: flex;
      align-items: center;
      justify-content: center;
      font-weight: bold;
      font-size: 1.2rem;
      cursor: pointer;
      user-select: none;
      transition: all 0.2s ease;
    }
    
    .radial-pad-direction:hover {
      background: #2563eb;
      transform: scale(1.1);
    }
    
    .radial-pad-direction:active {
      transform: scale(0.95);
    }
    
    .radial-pad-up { top: 5px; left: 50%; transform: translateX(-50%); }
    .radial-pad-right { right: 5px; top: 50%; transform: translateY(-50%); }
    .radial-pad-down { bottom: 5px; left: 50%; transform: translateX(-50%); }
    .radial-pad-left { left: 5px; top: 50%; transform: translateY(-50%); }
    
    .swipe-hint {
      font-size: 0.9rem;
      color: #6b7280;
      text-align: center;
    }
    
    @media (max-width: 768px) {
      .mobile-controls {
        display: flex;
      }
      
      .arrow-controls {
        display: none;
      }
      
      .timer-display {
        font-size: 2.5rem;
      }
      
      .bid-ladder-item {
        padding: 0.75rem;
        font-size: 1rem;
      }
    }
    
    .timer-container {
      margin: 0.75rem 0;
      text-align: center;
    }
    
    .timer-label {
      font-size: 0.9rem;
      font-weight: 600;
      color: #374151;
      margin-bottom: 0.5rem;
    }
    
    .timer-display {
      font-size: 3rem;
      font-weight: 700;
      font-family: 'Courier New', monospace;
      color: #1f2937;
      margin-bottom: 0.5rem;
      text-shadow: 0 2px 4px rgba(0,0,0,0.1);
    }
    
    .timer-bar {
      width: 100%;
      height: 8px;
      background: #e5e7eb;
      border-radius: 4px;
      overflow: hidden;
    }
    
    .timer-progress {
      height: 100%;
      background: linear-gradient(90deg, #10b981, #f59e0b, #ef4444);
      border-radius: 4px;
      transition: width 0.3s ease;
      width: 100%;
    }
    
    .timer-progress.warning {
      background: linear-gradient(90deg, #f59e0b, #ef4444);
    }
    
    .timer-progress.critical {
      background: #ef4444;
      animation: pulse 1s infinite;
    }
    
    @keyframes pulse {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.7; }
    }
    
    @keyframes celebrate {
      0%, 100% { transform: scale(1); }
      25% { transform: scale(1.02); }
      50% { transform: scale(1.05); }
      75% { transform: scale(1.02); }
    }
    
    .bid-ladder {
      margin: 0.75rem 0;
      background: #f8fafc;
      border: 1px solid #e2e8f0;
      border-radius: 8px;
      padding: 0.75rem;
    }
    
    .bid-ladder-header {
      font-weight: 600;
      color: #374151;
      margin-bottom: 0.5rem;
      font-size: 0.9rem;
    }
    
    .bid-ladder-list {
      display: flex;
      flex-direction: column;
      gap: 0.25rem;
    }
    
    .bid-ladder-item {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 0.5rem;
      background: #fff;
      border: 1px solid #e5e7eb;
      border-radius: 6px;
      font-size: 0.9rem;
    }
    
    .bid-ladder-item.leading {
      border-color: #10b981;
      background: #ecfdf5;
      font-weight: 600;
    }
    
    .bid-ladder-item.tie {
      border-color: #3b82f6;
      background: #eff6ff;
    }
    
    .bid-ladder-item.you {
      border-color: #8b5cf6;
      background: #f3e8ff;
      font-weight: 600;
    }
    
    .bid-ladder-player {
      color: #374151;
    }
    
    .bid-ladder-value {
      font-weight: 700;
      color: #1f2937;
      font-family: 'Courier New', monospace;
    }
    
    .sr-only {
      position: absolute;
      width: 1px;
      height: 1px;
      padding: 0;
      margin: -1px;
      overflow: hidden;
      clip: rect(0, 0, 0, 0);
      white-space: nowrap;
      border: 0;
    }
    
    @media (max-width: 960px) {
      body { margin: 1.25rem; }
      .board-wrapper { flex-direction: column; }
      #board { flex: 1 1 auto; width: 100%; max-width: none; }
      .board-sidebar { width: 100%; max-width: none; }
    }
    @media (max-width: 540px) {
      .arrow-controls { grid-template-columns: repeat(3, 40px); grid-template-rows: repeat(3, 40px); }
      .arrow-button { font-size: 1rem; }
      .robot { font-size: 0.85rem; }
      .controls-layout { flex-direction: column; }
      .controls-help { flex: none; }
    }
  </style>
  <script src="/public/js/polling.js" defer></script>
</head>
<body class="join-gate-open">
  <div id="join-gate" class="join-gate" role="dialog" aria-modal="true" aria-labelledby="join-gate-title">
    <div class="join-gate__panel">
      <h1 id="join-gate-title">Join the room</h1>
      <p id="join-gate-room" class="join-gate__room" aria-live="polite" hidden></p>
      <form id="join-form">
        <label>
          Room code
          <input id="room-code" type="text" required minlength="1" maxlength="32" pattern="^[a-z0-9](?:[a-z0-9-]{0,30}[a-z0-9])?$" autocomplete="off" autocapitalize="off" spellcheck="false">
        </label>
        <label>
          Display name
          <input id="player-name" type="text" maxlength="64" autocomplete="off" required>
        </label>
        <button type="submit">Join room</button>
        <span id="join-message" class="message" aria-live="polite"></span>
      </form>
      <div id="join-status" class="banner join-gate__status" hidden aria-live="polite"></div>
      <div id="color-warning" class="banner" hidden></div>
    </div>
  </div>
  <div id="room-app" hidden aria-hidden="true">
    <div id="share-banner" class="share-banner" hidden role="status" aria-live="polite">
      <span class="share-banner__text">Room created! Share this link with your friends:</span>
      <a id="share-link" class="share-banner__link" href="" rel="noopener noreferrer"></a>
      <div class="share-banner__actions">
        <button type="button" id="share-copy" class="secondary">Copy</button>
        <button type="button" id="share-dismiss" class="share-banner__dismiss" aria-label="Dismiss banner">✕</button>
      </div>
    </div>

    <div class="game-layout">
      <!-- Column A: Players, Bids, and Game Info -->
      <div class="game-column game-column-left">
        <fieldset id="players-fieldset" hidden>
          <legend>Leaderboard</legend>
          <div class="players-header">
            <button type="button" id="claim-host" class="secondary" hidden>Claim Host</button>
          </div>
          <div id="bid-ladder" class="bid-ladder">
            <div class="bid-ladder-header">Current Bids</div>
            <div id="bid-ladder-list" class="bid-ladder-list"></div>
          </div>
          <table>
            <thead>
              <tr>
                <th>Player</th>
                <th>Bid</th>
                <th>Tokens</th>
              </tr>
            </thead>
            <tbody id="leaderboard"></tbody>
          </table>
        </fieldset>

        <fieldset>
          <legend>Submit Bid</legend>
          <form id="bid-form">
            <label>
              Bid value
              <input id="bidInput" inputmode="numeric" autocomplete="off" autocapitalize="off" spellcheck="false" autofocus>
            </label>
            <button type="submit">Submit Bid</button>
            <span id="bid-message" class="message" aria-live="polite"></span>
          </form>
        </fieldset>

        <fieldset>
          <legend>Controls</legend>
          <div class="controls-layout">
            <div class="controls-main">
              <div id="board-selection" class="board-selection" aria-live="polite">Selected robot: —</div>
              <div id="robot-badges" class="robot-badges" role="group" aria-label="Select robot"></div>
              <div id="arrow-controls" class="arrow-controls" role="group" aria-label="Move robot">
                <button type="button" class="arrow-button arrow-up" data-dir="UP" aria-label="Move up">↑</button>
                <button type="button" class="arrow-button arrow-left" data-dir="LEFT" aria-label="Move left">←</button>
                <button type="button" class="arrow-button arrow-right" data-dir="RIGHT" aria-label="Move right">→</button>
                <button type="button" class="arrow-button arrow-down" data-dir="DOWN" aria-label="Move down">↓</button>
              </div>
              <div id="sandbox-controls" class="sandbox-controls" hidden>
                <button type="button" id="reset-sandbox" class="secondary">Reset</button>
                <button type="button" id="undo-move" class="secondary">Undo</button>
                <button type="button" id="exit-thinking" class="secondary">Exit Thinking</button>
              </div>
              <div id="demonstration-controls" class="demonstration-controls" hidden>
                <div id="move-counter" class="move-counter">Moves: 0</div>
                <button type="button" id="submit-solution" class="primary">Submit Solution</button>
                <button type="button" id="give-up" class="secondary">Give Up</button>
              </div>
              <div id="mobile-controls" class="mobile-controls">
                <div class="radial-pad" id="radial-pad">
                  <div class="radial-pad-center"></div>
                  <button class="radial-pad-direction radial-pad-up" data-dir="UP" aria-label="Move up">↑</button>
                  <button class="radial-pad-direction radial-pad-right" data-dir="RIGHT" aria-label="Move right">→</button>
                  <button class="radial-pad-direction radial-pad-down" data-dir="DOWN" aria-label="Move down">↓</button>
                  <button class="radial-pad-direction radial-pad-left" data-dir="LEFT" aria-label="Move left">←</button>
                </div>
                <div class="swipe-hint">Or swipe on the board to move</div>
              </div>
            </div>
            <div class="controls-help">
              <details class="board-help" open>
                <summary>Keyboard tips</summary>
                <ul>
                  <li><strong>Bid:</strong> Type digits, press Enter</li>
                  <li><strong>Select robot:</strong> Tab / Shift+Tab, Space, or click a badge</li>
                  <li><strong>Move:</strong> Arrow keys or W/A/S/D</li>
                  <li><strong>Clear bid:</strong> Esc</li>
                  <li><strong>Board focus:</strong> Click board or Tab to it</li>
                  <li><strong>Exit board:</strong> Esc when board is focused</li>
                </ul>
              </details>
            </div>
          </div>
        </fieldset>

        <fieldset>
          <legend>Current Round</legend>
          <div class="status">
            Status: <span id="status">—</span> (state version <span id="state-version">0</span>)
          </div>
          <div class="puzzle-progress">
            Puzzle <span id="current-puzzle">1</span> of <span id="total-puzzles">17</span>
          </div>
          <div id="start-game-container" class="start-game-container" hidden>
            <button type="button" id="start-game-button" class="primary">Start Game</button>
            <div class="start-game-message">Click "Start Game" to begin the first puzzle!</div>
          </div>
          <div class="timer-container">
            <div class="timer-label">Time Remaining</div>
            <div class="timer-display" id="timer-display" aria-live="polite" aria-label="Time remaining">—</div>
            <div class="timer-bar" role="progressbar" aria-valuenow="60" aria-valuemin="0" aria-valuemax="60" aria-label="Countdown progress">
              <div class="timer-progress" id="timer-progress"></div>
            </div>
          </div>
          <div id="current-target" class="current-target">
            <div class="target-placeholder">No target selected</div>
          </div>
          <div>
            Lowest Bid: <span id="low-bid">—</span>
            <span id="low-bidder"></span>
          </div>
          <div id="leading-info" class="leading-panel" hidden>
            <strong>Leading:</strong>
            <span id="leading-text"></span>
          </div>
          <div id="verifying-container" class="verifying-panel" hidden>
            <h3>Verification Queue</h3>
            <div id="verifying-current">Current: —</div>
            <ol id="verifying-queue"></ol>
            <div class="verify-buttons">
              <button type="button" id="verify-pass">Pass</button>
              <button type="button" id="verify-fail">Fail</button>
              <span id="verify-message" class="message" aria-live="polite"></span>
            </div>
          </div>
          <div id="host-controls" class="host-controls" hidden>
            <button type="button" id="next-round" class="secondary">Next Round</button>
            <span id="next-message" class="message" aria-live="polite"></span>
          </div>
        </fieldset>
      </div>

      <!-- Column B: Board -->
      <div class="game-column game-column-right">
        <fieldset>
          <legend>Board</legend>
          <div id="board" class="board" tabindex="0" role="application" aria-label="Ricochet Robot game board. Use arrow keys to move robots. Press Tab to select different robots.">
            <div class="board-surface">
              <div id="board-grid" class="board-grid" aria-hidden="true"></div>
              <div id="robot-layer" class="robot-layer" aria-hidden="true"></div>
            </div>
            <div id="board-instructions" class="sr-only">
              Use arrow keys or WASD to move the selected robot. Press Tab to cycle through robots. 
              Press Escape to cancel current action.
            </div>
          </div>
        </fieldset>
      </div>
    </div>

  </div>

  <div id="toast" class="toast" aria-live="polite" aria-atomic="true"></div>
  
  <!-- Accessibility announcements -->
  <div id="aria-announcements" class="sr-only" aria-live="polite" aria-atomic="true"></div>
  <div id="aria-urgent" class="sr-only" aria-live="assertive" aria-atomic="true"></div>

  <script>
    (function () {
      console.log('Script starting, checking PollingHelpers availability');
      console.log('PollingHelpers available:', !!window.PollingHelpers);
      console.log('Current URL:', window.location.href);
      console.log('Search params:', window.location.search);
      
      const joinForm = document.getElementById('join-form');
      const bidForm = document.getElementById('bid-form');
      const joinGate = document.getElementById('join-gate');
      const joinGateRoom = document.getElementById('join-gate-room');
      const roomApp = document.getElementById('room-app');
      const shareBanner = document.getElementById('share-banner');
      const shareLink = document.getElementById('share-link');
      const shareCopyButton = document.getElementById('share-copy');
      const shareDismissButton = document.getElementById('share-dismiss');
      console.log('shareDismissButton found:', !!shareDismissButton);
      const roomCodeInput = document.getElementById('room-code');
      const playerNameInput = document.getElementById('player-name');
      const colorWarning = document.getElementById('color-warning');
      const joinMessage = document.getElementById('join-message');
      const joinStatus = document.getElementById('join-status');
      const bidMessage = document.getElementById('bid-message');
      const joinButton = joinForm ? joinForm.querySelector('button[type="submit"]') : null;
      const bidButton = bidForm ? bidForm.querySelector('button[type="submit"]') : null;
      const editIdentityButton = document.getElementById('edit-identity');
      const bidInput = document.getElementById('bidInput');
      const playersFieldset = document.getElementById('players-fieldset');
      const claimHostButton = document.getElementById('claim-host');
      const hostControls = document.getElementById('host-controls');
      const nextRoundButton = document.getElementById('next-round');
      const nextMessage = document.getElementById('next-message');

      const ROOM_CODE_PATTERN = /^[a-z0-9](?:[a-z0-9-]{0,30}[a-z0-9])?$/;
      const DOUBLE_HYPHEN_PATTERN = /--/;

      function isValidRoomCode(value) {
        const normalized = normalizeRoomCode(value);
        if (!normalized) {
          return false;
        }
        return ROOM_CODE_PATTERN.test(normalized) && !DOUBLE_HYPHEN_PATTERN.test(normalized);
      }

      const searchParams = new URLSearchParams(window.location.search);
      let shouldShowShareBanner = searchParams.get('created') === '1';
      let shareBannerDisplayed = false;
      let userDismissedBanner = false;

      let storedPlayerInfo = null;
      let autoJoinContext = null;
      const pathRoomMatch = window.location.pathname.match(/^\/r\/([^/]+)/i);
      const matchedRoomCode = pathRoomMatch ? normalizeRoomCode(decodeURIComponent(pathRoomMatch[1])) : '';
      const initialRoomCode = matchedRoomCode && isValidRoomCode(matchedRoomCode) ? matchedRoomCode : '';
      if (initialRoomCode) {
        roomCodeInput.value = initialRoomCode;
        roomCodeInput.readOnly = true;
        roomCodeInput.setAttribute('aria-readonly', 'true');
        storedPlayerInfo = loadStoredPlayer(initialRoomCode);
        updateJoinGateRoom(initialRoomCode);
      }

      if (!storedPlayerInfo && roomCodeInput && roomCodeInput.value) {
        const inputRoomCode = normalizeRoomCode(roomCodeInput.value);
        if (inputRoomCode && isValidRoomCode(inputRoomCode)) {
          storedPlayerInfo = loadStoredPlayer(inputRoomCode);
          if (!initialRoomCode) {
            roomCodeInput.value = inputRoomCode;
            updateJoinGateRoom(inputRoomCode);
          }
        } else if (!initialRoomCode) {
          updateJoinGateRoom('');
        }
      }

      const globalIdentity = loadGlobalIdentity();

      if (storedPlayerInfo) {
        const storedNameRaw = storedPlayerInfo.displayName
          ? storedPlayerInfo.displayName
          : (globalIdentity && globalIdentity.displayName ? globalIdentity.displayName : '');
        const storedName = storedNameRaw ? storedNameRaw.trim() : '';
        if (storedName) {
          playerNameInput.value = storedName;
        }
        if (initialRoomCode && storedName && storedPlayerInfo.playerId) {
          autoJoinContext = {
            code: initialRoomCode,
            displayName: storedName,
            color: 'Purple' // Default color
          };
        }
      } else if (globalIdentity) {
        const globalName = globalIdentity.displayName ? globalIdentity.displayName.trim() : '';
        if (globalName) {
          playerNameInput.value = globalName;
        }
      }


      if (autoJoinContext) {
        console.log('Auto-join context found:', autoJoinContext);
        setJoinFormVisible(false);
        setEditIdentityVisible(false);
        showJoinStatusBanner(`Rejoining as ${formatIdentityLabel(autoJoinContext.displayName, autoJoinContext.color)}…`);
      } else {
        console.log('No auto-join context found, showing join form');
        setJoinFormVisible(true);
        setEditIdentityVisible(false);
        hideJoinStatusBanner();
      }

      const statusEl = document.getElementById('status');
      const versionEl = document.getElementById('state-version');
      const startGameContainer = document.getElementById('start-game-container');
      const startGameButton = document.getElementById('start-game-button');
      // remainingEl removed - using timerDisplayEl instead
      const timerDisplayEl = document.getElementById('timer-display');
      const timerProgressEl = document.getElementById('timer-progress');
      const lowBidEl = document.getElementById('low-bid');
      const lowBidderEl = document.getElementById('low-bidder');
      const leadingPanel = document.getElementById('leading-info');
      const leadingText = document.getElementById('leading-text');
      const leaderboardEl = document.getElementById('leaderboard');
      const bidLadderListEl = document.getElementById('bid-ladder-list');
      const verifyingContainer = document.getElementById('verifying-container');
      const verifyingCurrent = document.getElementById('verifying-current');
      const verifyingQueueList = document.getElementById('verifying-queue');
      const verifyPassButton = document.getElementById('verify-pass');
      const verifyFailButton = document.getElementById('verify-fail');
      const verifyMessage = document.getElementById('verify-message');
      const boardEl = document.getElementById('board');
      const boardGridEl = document.getElementById('board-grid');
      const robotLayerEl = document.getElementById('robot-layer');
      const robotBadgesEl = document.getElementById('robot-badges');
      const arrowControlsEl = document.getElementById('arrow-controls');
      const boardSelectionEl = document.getElementById('board-selection');
      const toastEl = document.getElementById('toast');

      let poller = null;
      let currentRoomCode = null;
      let currentPlayerId = null;
      let lastStateSnapshot = null;
      let currentPlayerName = '';
      let playersById = {};
      let hostPlayerId = null;
      let lastServerRemaining = null;
      let lastServerTimestamp = null;
      let serverSkewMs = 0;
      let hasServerSkew = false;
      let countdownTimerId = null;
      let bidAllowed = false;
      let bidInFlight = false;
      let joinInFlight = false;
      let autoJoinScheduled = false;
      let lastVerifyingState = null;
      let verifyInFlight = false;
      let nextInFlight = false;
      let claimInFlight = false;
      const BOARD_SIZE = 16;
      const ROBOT_ORDER = ['Purple', 'Cyan', 'Lime', 'Yellow'];
      const ROBOT_META = {
        Purple: { id: 'purple', robotClass: 'robot-purple', badgeClass: 'robot-badge-purple', shortLabel: 'P', color: '#482878' },
        Cyan: { id: 'cyan', robotClass: 'robot-cyan', badgeClass: 'robot-badge-cyan', shortLabel: 'C', color: '#26828e' },
        Lime: { id: 'lime', robotClass: 'robot-lime', badgeClass: 'robot-badge-lime', shortLabel: 'L', color: '#90d743' },
        Yellow: { id: 'yellow', robotClass: 'robot-yellow', badgeClass: 'robot-badge-yellow', shortLabel: 'Y', color: '#fde725' }
      };

      const INITIAL_ROBOT_POSITIONS = {
        Purple: { row: 1, col: 1 },
        Cyan: { row: 1, col: 14 },
        Lime: { row: 14, col: 1 },
        Yellow: { row: 14, col: 14 }
      };
      // Static wall data system

      const STATIC_WALL_DATA = {
        '0,3': [0, 0, 0, 1],    // Row 0, Col 3: right wall
        '0,11': [0, 0, 0, 1],   // Row 0, Col 11: right wall
        '1,1': [0, 1, 1, 0],    // Row 1, Col 1: bottom + left walls
        '1,9': [0, 1, 0, 1],    // Row 1, Col 9: bottom + right walls
        '2,6': [1, 0, 0, 1],    // Row 2, Col 6: top + right walls
        '2,15': [0, 1, 0, 0],   // Row 2, Col 15: bottom wall
        '3,11': [0, 1, 1, 0],   // Row 3, Col 11: bottom + left walls
        '4,2': [0, 1, 0, 1],    // Row 4, Col 2: bottom + right walls
        '5,0': [0, 1, 0, 0],    // Row 5, Col 0: bottom wall
        '5,7': [1, 0, 1, 0],    // Row 5, Col 7: top + left walls
        '5,14': [1, 0, 1, 0],   // Row 5, Col 14: top + left walls
        '6,10': [1, 0, 0, 1],   // Row 6, Col 10: top + right walls
        '7,7': [1, 0, 1, 0],    // Row 7, Col 7: top + left walls
        '7,8': [1, 0, 0, 1],    // Row 7, Col 8: top + right walls
        '7,13': [0, 1, 1, 0],   // Row 7, Col 13: bottom + left walls
        '8,7': [0, 1, 1, 0],    // Row 8, Col 7: bottom + left walls
        '8,8': [0, 1, 0, 1],    // Row 8, Col 8: bottom + right walls
        '9,3': [1, 0, 0, 1],    // Row 9, Col 3: top + right walls
        '10,11': [1, 0, 1, 0],  // Row 10, Col 11: top + left walls
        '11,1': [0, 1, 1, 0],   // Row 11, Col 1: bottom + left walls
        '11,13': [0, 1, 1, 0],  // Row 11, Col 13: bottom + left walls
        '11,15': [0, 1, 0, 0],  // Row 11, Col 15: bottom wall
        '12,6': [0, 1, 0, 1],   // Row 12, Col 6: bottom + right walls
        '12,10': [1, 0, 0, 1],  // Row 12, Col 10: top + right walls
        '13,0': [0, 1, 0, 0],   // Row 13, Col 0: bottom wall
        '13,12': [0, 1, 0, 1],  // Row 13, Col 12: bottom + right walls
        '14,2': [1, 0, 1, 0],   // Row 14, Col 2: top + left walls
        '15,5': [0, 0, 0, 1],   // Row 15, Col 5: right wall
        '15,9': [0, 0, 0, 1]    // Row 15, Col 9: right wall
      };
      
      // Valid symbol positions - aligned with wall data for quadrant shuffling
      // Organized by quadrant for proper distribution
      const SYMBOL_POSITIONS = {
        'quadrant1': [  // Top-Left: Rows 0-7, Cols 0-7
          { row: 1, col: 1, symbol: 'DI' }, // Diamond Indigo
          { row: 2, col: 6, symbol: 'HL' }, // Heart Lime
          { row: 4, col: 2, symbol: 'CC' }, // Club Cyan
          { row: 5, col: 7, symbol: 'SY' }  // Spade Yellow
        ],
        'quadrant2': [  // Top-Right: Rows 0-7, Cols 8-15
          { row: 1, col: 9, symbol: 'DY' }, // Diamond Yellow
          { row: 3, col: 11, symbol: 'CI' }, // Club Indigo
          { row: 5, col: 14, symbol: 'HC' }, // Heart Cyan
          { row: 6, col: 10, symbol: 'SL' }  // Spade Lime
        ],
        'quadrant3': [  // Bottom-Left: Rows 8-15, Cols 0-7
          { row: 9, col: 3, symbol: 'CY' }, // Club Yellow
          { row: 11, col: 1, symbol: 'HI' }, // Heart Indigo
          { row: 12, col: 6, symbol: 'SC' }, // Spade Cyan
          { row: 14, col: 2, symbol: 'DL' } // Diamond Lime
        ],
        'quadrant4': [  // Bottom-Right: Rows 8-15, Cols 8-15
          { row: 7, col: 13, symbol: 'QUAD' }, // Special 4-color square
          { row: 10, col: 11, symbol: 'CL' }, // Club Lime
          { row: 11, col: 13, symbol: 'SI' }, // Spade Indigo
          { row: 12, col: 10, symbol: 'DC' }, // Diamond Cyan
          { row: 13, col: 12, symbol: 'HY' }  // Heart Yellow
        ]
      };
      
      const CENTER_CELLS = [[7, 7], [7, 8], [8, 7], [8, 8]];
      
      
      const KEY_TO_DIR = {
        ArrowUp: 'UP',
        ArrowDown: 'DOWN',
        ArrowLeft: 'LEFT',
        ArrowRight: 'RIGHT',
        w: 'UP',
        s: 'DOWN',
        a: 'LEFT',
        d: 'RIGHT'
      };
      const WALL_RELATIONS = {
        top: { dr: -1, dc: 0, opposite: 'bottom' },
        bottom: { dr: 1, dc: 0, opposite: 'top' },
        left: { dr: 0, dc: -1, opposite: 'right' },
        right: { dr: 0, dc: 1, opposite: 'left' }
      };
      const boardWalls = new Map();
      const robotState = {};
      let boardInitialized = false;
      let boardActive = false;
      let robotIdx = 0;
      let toastTimeoutId = null;
      
      // Game state management
      let gameMode = 'bidding'; // 'bidding', 'demo', 'thinking', 'demonstrating'
      let sandboxState = null; // Private state for thinking mode
      let moveHistory = []; // For undo/redo
      let currentTarget = null; // Current target chip
      let demonstrationMoves = 0; // Move counter during solution demonstration
      let currentPuzzleNumber = 1; // Track current puzzle (1-17)
      let totalPuzzles = 17; // Total number of puzzles in the game
      let currentPlayerBid = null; // Current player's bid during demonstration
      let demoMode = false; // Whether we're in demonstration mode
      let demoMoves = []; // Moves being demonstrated
      let demoStep = 0; // Current step in demo
      let demoPlayerId = null; // Player ID of the demonstrator
      let isDemoPlayer = false; // Whether current player is the demonstrator
      
      // Demonstration synchronization
      let synchronizedMoves = []; // Moves received from server
      let synchronizedMoveIndex = 0; // Current synchronized move index
      let synchronizedPlayerId = null; // Player ID of synchronized demonstrator
      let isSynchronizedDemonstration = false; // Whether we're in synchronized demo mode
      let demonstrationAnimationTimer = null; // Timer for synchronized animations
      let queuedNewMoves = []; // Moves queued while animation is playing
      let moveDebounceTimer = null; // Timer for debouncing rapid moves
      let pendingMoves = []; // Queue for moves waiting to be sent to server
      
      // Mobile controls
      let touchStartX = 0;
      let touchStartY = 0;
      let touchEndX = 0;
      let touchEndY = 0;
      let minSwipeDistance = 50;

      function setMessage(element, text, isError) {
        if (!element) {
          return;
        }
        element.textContent = text || '';
        if (isError) {
          element.classList.add('error');
        } else {
          element.classList.remove('error');
        }
      }

      function formatIdentityLabel(name, color) {
        const safeName = typeof name === 'string' ? name.trim() : '';
        return safeName || 'Player';
      }

      function setJoinFormDisabled(disabled) {
        if (!joinForm) {
          return;
        }
        const elements = Array.prototype.slice.call(joinForm.elements || []);
        elements.forEach(function (el) {
          if (!el || typeof el.disabled !== 'boolean') {
            return;
          }
          el.disabled = disabled;
        });
        if (joinButton) {
          joinButton.disabled = disabled;
        }
      }

      function setJoinFormVisible(visible) {
        if (!joinForm) {
          return;
        }
        joinForm.hidden = !visible;
        if (visible) {
          joinForm.removeAttribute('aria-hidden');
          setJoinFormDisabled(false);
        } else {
          joinForm.setAttribute('aria-hidden', 'true');
          setJoinFormDisabled(true);
        }
      }

      function setEditIdentityVisible(visible) {
        if (!editIdentityButton) {
          return;
        }
        editIdentityButton.hidden = !visible;
        editIdentityButton.disabled = !visible;
      }

      function showJoinStatusBanner(text) {
        if (!joinStatus) {
          return;
        }
        const message = text || '';
        joinStatus.textContent = message;
        joinStatus.hidden = message === '';
      }

      function hideJoinStatusBanner() {
        showJoinStatusBanner('');
      }

      function setJoinGateVisible(visible) {
        if (joinGate) {
          joinGate.hidden = !visible;
        }
        if (visible) {
          document.body.classList.add('join-gate-open');
          if (roomApp) {
            roomApp.setAttribute('aria-hidden', 'true');
          }
        } else {
          document.body.classList.remove('join-gate-open');
          if (roomApp) {
            roomApp.removeAttribute('aria-hidden');
          }
        }
      }

      function showRoomApp() {
        if (roomApp) {
          roomApp.hidden = false;
          roomApp.removeAttribute('aria-hidden');
        }
      }

      function updateJoinGateRoom(code) {
        if (!joinGateRoom) {
          return;
        }
        const normalized = normalizeRoomCode(code);
        if (!normalized || !ROOM_CODE_PATTERN.test(normalized) || DOUBLE_HYPHEN_PATTERN.test(normalized)) {
          joinGateRoom.textContent = '';
          joinGateRoom.hidden = true;
          return;
        }
        const display = normalized.toLowerCase();
        joinGateRoom.hidden = false;
        joinGateRoom.textContent = '';
        const label = document.createElement('span');
        label.textContent = 'Room code: ';
        const codeEl = document.createElement('code');
        codeEl.textContent = display;
        joinGateRoom.appendChild(label);
        joinGateRoom.appendChild(codeEl);
      }

      function getShareUrl(code) {
        const normalized = normalizeRoomCode(code);
        if (!normalized || !ROOM_CODE_PATTERN.test(normalized) || DOUBLE_HYPHEN_PATTERN.test(normalized)) {
          return '';
        }
        const base = `${window.location.protocol}//${window.location.host}`;
        return `${base}/r/${encodeURIComponent(normalized)}`;
      }

      function consumeCreationFlag() {
        if (!shouldShowShareBanner) {
          return;
        }
        shouldShowShareBanner = false;
        try {
          const url = new URL(window.location.href);
          url.searchParams.delete('created');
          const searchString = url.searchParams.toString();
          const next = `${url.pathname}${searchString && searchString.length > 0 ? `?${searchString}` : ''}${url.hash}`;
          window.history.replaceState(null, '', next);
        } catch (err) {
          // Ignore history errors.
        }
      }

      function maybeShowShareBanner(code) {
        console.log('maybeShowShareBanner called with:', { code, shareBanner: !!shareBanner, shareBannerDisplayed, shouldShowShareBanner, userDismissedBanner });
        if (!shareBanner || shareBannerDisplayed || userDismissedBanner) {
          console.log('maybeShowShareBanner: not showing banner, conditions:', { shareBanner: !!shareBanner, shareBannerDisplayed, userDismissedBanner });
          return;
        }
        const shareUrl = getShareUrl(code);
        if (!shareUrl) {
          console.log('maybeShowShareBanner: no share URL');
          return;
        }
        console.log('maybeShowShareBanner: showing banner with URL:', shareUrl);
        if (shareLink) {
          shareLink.href = shareUrl;
          shareLink.textContent = shareUrl;
        }
        shareBanner.classList.remove('hidden');
        shareBanner.hidden = false;
        shareBanner.style.display = ''; // Safari fallback - remove inline style
        shareBanner.removeAttribute('aria-hidden');
        shareBannerDisplayed = true;
        // Only consume the creation flag if it was actually used to trigger the banner
        if (shouldShowShareBanner) {
          consumeCreationFlag();
        }
      }

      function hideShareBanner() {
        console.log('hideShareBanner called');
        if (shareBanner) {
          console.log('Hiding share banner');
          shareBanner.classList.add('hidden');
          shareBanner.hidden = true;
          shareBanner.style.display = 'none'; // Safari fallback
          shareBanner.setAttribute('aria-hidden', 'true');
        } else {
          console.log('shareBanner element not found');
        }
        shareBannerDisplayed = false;
        shouldShowShareBanner = false; // Prevent re-showing
        userDismissedBanner = true; // Mark that user manually dismissed
        consumeCreationFlag();
      }

      async function copyShareLink() {
        const shareUrl = shareLink && shareLink.href ? shareLink.href : window.location.href;
        if (!shareUrl) {
          return;
        }
        try {
          if (navigator.clipboard && typeof navigator.clipboard.writeText === 'function') {
            await navigator.clipboard.writeText(shareUrl);
          } else {
            const textArea = document.createElement('textarea');
            textArea.value = shareUrl;
            textArea.setAttribute('readonly', '');
            textArea.style.position = 'absolute';
            textArea.style.left = '-9999px';
            document.body.appendChild(textArea);
            textArea.select();
            document.execCommand('copy');
            document.body.removeChild(textArea);
          }
          showToast('Link copied to clipboard', false);
        } catch (err) {
          showToast('Unable to copy link. Copy it manually.', true);
        }
      }

      function whenPollingHelpersReady(callback, onTimeout) {
        if (typeof callback !== 'function') {
          return;
        }
        if (window.PollingHelpers) {
          callback();
          return;
        }
        let attempts = 0;
        const maxAttempts = 60;
        const timerId = window.setInterval(function () {
          attempts += 1;
          if (window.PollingHelpers) {
            clearInterval(timerId);
            callback();
          } else if (attempts >= maxAttempts) {
            clearInterval(timerId);
            console.warn('PollingHelpers did not initialize in time.');
            if (typeof onTimeout === 'function') {
              onTimeout();
            }
          }
        }, 100);
      }

      function normalizeRoomCode(value) {
        if (typeof value !== 'string') {
          return '';
        }
        const trimmed = value.trim();
        return trimmed ? trimmed.toLowerCase() : '';
      }


      function showColorWarning(text) {
        if (!colorWarning) {
          return;
        }
        const message = text || '';
        colorWarning.textContent = message;
        colorWarning.hidden = message === '';
      }

      function hideColorWarning() {
        showColorWarning('');
      }

      function getPlayerInfo(playerId) {
        const key = Number(playerId);
        if (!Number.isFinite(key)) {
          return null;
        }
        return playersById[key] || null;
      }

      function formatPlayerLabel(playerId) {
        const info = getPlayerInfo(playerId);
        if (info && info.displayName) {
          return info.displayName;
        }
        return `Player ${playerId}`;
      }


      function storagePrefixForRoom(code) {
        const normalized = normalizeRoomCode(code);
        if (!normalized || !ROOM_CODE_PATTERN.test(normalized) || DOUBLE_HYPHEN_PATTERN.test(normalized)) {
          return null;
        }
        return `rr.${normalized}`;
      }

      function loadStoredPlayer(code) {
        const prefix = storagePrefixForRoom(code);
        if (!prefix) {
          return null;
        }
        try {
          const idRaw = window.localStorage.getItem(`${prefix}.playerId`);
          const nameRaw = window.localStorage.getItem(`${prefix}.displayName`) || '';
          const colorRaw = window.localStorage.getItem(`${prefix}.color`) || '';
          const parsedId = idRaw != null ? Number.parseInt(idRaw, 10) : NaN;
          const playerId = Number.isFinite(parsedId) && parsedId > 0 ? parsedId : null;
          const displayName = typeof nameRaw === 'string' ? nameRaw : '';
          const color = typeof colorRaw === 'string' && colorRaw ? colorRaw : null;
          if (playerId || displayName || color) {
            return { playerId: playerId, displayName: displayName, color: color };
          }
        } catch (err) {
          // Ignore storage errors.
        }
        return null;
      }

      function saveStoredPlayer(code, playerId, displayName, color) {
        const prefix = storagePrefixForRoom(code);
        if (!prefix) {
          return;
        }
        try {
          if (Number.isFinite(Number(playerId)) && Number(playerId) > 0) {
            window.localStorage.setItem(`${prefix}.playerId`, String(Number(playerId)));
          } else {
            window.localStorage.removeItem(`${prefix}.playerId`);
          }
          const trimmedName = typeof displayName === 'string' ? displayName.trim() : '';
          if (trimmedName) {
            window.localStorage.setItem(`${prefix}.displayName`, trimmedName);
          } else {
            window.localStorage.removeItem(`${prefix}.displayName`);
          }
          if (color) {
            window.localStorage.setItem(`${prefix}.color`, color);
          } else {
            window.localStorage.removeItem(`${prefix}.color`);
          }
        } catch (err) {
          // Ignore storage failures.
        }
      }

      function clearStoredPlayer(code) {
        const prefix = storagePrefixForRoom(code);
        if (!prefix) {
          return;
        }
        try {
          window.localStorage.removeItem(`${prefix}.playerId`);
          window.localStorage.removeItem(`${prefix}.displayName`);
          window.localStorage.removeItem(`${prefix}.color`);
        } catch (err) {
          // Ignore.
        }
      }

      function loadGlobalIdentity() {
        try {
          const storedId = window.localStorage.getItem('rr.playerId');
          const storedName = window.localStorage.getItem('rr.displayName') || '';
          const storedColor = window.localStorage.getItem('rr.color') || null;
          const parsedId = storedId != null ? Number.parseInt(storedId, 10) : NaN;
          if (Number.isFinite(parsedId) && parsedId > 0) {
            return { playerId: parsedId, displayName: storedName, color: storedColor };
          }
          if (storedName || storedColor) {
            return { playerId: null, displayName: storedName, color: storedColor };
          }
        } catch (err) {
          return null;
        }
        return null;
      }

      function saveGlobalIdentity(playerId, displayName, color) {
        try {
          if (playerId != null && Number.isFinite(Number(playerId)) && Number(playerId) > 0) {
            window.localStorage.setItem('rr.playerId', String(playerId));
          } else {
            window.localStorage.removeItem('rr.playerId');
          }
          if (typeof displayName === 'string' && displayName) {
            window.localStorage.setItem('rr.displayName', displayName);
          } else {
            window.localStorage.removeItem('rr.displayName');
          }
          if (typeof color === 'string' && color) {
            window.localStorage.setItem('rr.color', color);
          } else {
            window.localStorage.removeItem('rr.color');
          }
        } catch (err) {
          // Ignore storage errors.
        }
      }

      function clearGlobalIdentity() {
        try {
          window.localStorage.removeItem('rr.playerId');
          window.localStorage.removeItem('rr.displayName');
          window.localStorage.removeItem('rr.color');
        } catch (err) {
          // Ignore.
        }
      }

      function updateBidFormState() {
        const inputEnabled = bidAllowed && !bidInFlight;
        if (bidInput) {
          bidInput.disabled = !inputEnabled;
        }
        bidButton.disabled = !bidAllowed || bidInFlight;
      }

      function setBidFormEnabled(enabled) {
        bidAllowed = Boolean(enabled);
        updateBidFormState();
        if (!bidAllowed && bidInput) {
          bidInput.blur();
        }
        if (bidAllowed && !bidInFlight && bidInput) {
          window.requestAnimationFrame(function () {
            if (document.activeElement !== bidInput && !bidInput.disabled) {
              bidInput.focus({ preventScroll: true });
            }
          });
        }
      }

      function resetClientState() {
        lastServerRemaining = null;
        lastServerTimestamp = null;
        serverSkewMs = 0;
        hasServerSkew = false;
        stopCountdownTicker();
        setBidFormEnabled(false);
        lastVerifyingState = null;
        verifyInFlight = false;
        nextInFlight = false;
        if (verifyMessage) {
          setMessage(verifyMessage, '', false);
        }
        if (nextMessage) {
          setMessage(nextMessage, '', false);
        }
      }

      if (bidInput) {
        bidInput.addEventListener('input', function (event) {
          const digits = event.target.value.replace(/\D+/g, '').slice(0, 3);
          if (event.target.value !== digits) {
            event.target.value = digits;
          }
        });
        bidInput.addEventListener('keydown', function (event) {
          if (event.key === 'Enter') {
            event.preventDefault();
            submitBid();
          } else if (event.key === 'Escape') {
            event.preventDefault();
            bidInput.value = '';
            setMessage(bidMessage, '', false);
          }
        });
      }


      function getCurrentVerifier() {
        if (!lastVerifyingState || !Array.isArray(lastVerifyingState.queue)) {
          return null;
        }

        const index = Number.isInteger(lastVerifyingState.currentIndex)
          ? lastVerifyingState.currentIndex
          : 0;

        if (index < 0) {
          return null;
        }

        return lastVerifyingState.queue[index] || null;
      }

      function updateVerifyButtons() {
        if (!verifyPassButton || !verifyFailButton) {
          return;
        }
        const isHost = currentPlayerId != null && hostPlayerId != null && currentPlayerId === hostPlayerId;
        const currentEntry = getCurrentVerifier();
        const enabled = Boolean(currentRoomCode && currentEntry && !verifyInFlight && isHost);
        verifyPassButton.disabled = !enabled;
        verifyFailButton.disabled = !enabled;
        verifyPassButton.hidden = !isHost;
        verifyFailButton.hidden = !isHost;
      }

      function stopCountdownTicker() {
        if (countdownTimerId != null) {
          clearInterval(countdownTimerId);
          countdownTimerId = null;
        }
      }

      function updateCountdownDisplay() {
        const remaining = estimateRemaining();
        if (remaining == null) {
          if (timerDisplayEl) timerDisplayEl.textContent = '—';
          if (timerProgressEl) {
            timerProgressEl.style.width = '100%';
            timerProgressEl.className = 'timer-progress';
          }
          return;
        }
        
        const formatted = formatSeconds(remaining);
        if (timerDisplayEl) timerDisplayEl.textContent = formatted;
        
        // Update progress bar
        if (timerProgressEl) {
          const totalTime = 60; // 60 seconds countdown
          const progress = Math.max(0, Math.min(100, (remaining / totalTime) * 100));
          timerProgressEl.style.width = `${progress}%`;
          
          // Update ARIA attributes
          const progressBar = timerProgressEl.parentElement;
          if (progressBar) {
            progressBar.setAttribute('aria-valuenow', Math.round(remaining));
            progressBar.setAttribute('aria-label', `${Math.round(remaining)} seconds remaining`);
          }
          
          // Update progress bar color based on remaining time
          timerProgressEl.className = 'timer-progress';
          if (remaining <= 10) {
            timerProgressEl.classList.add('critical');
            announceUrgent(`Warning: Only ${Math.round(remaining)} seconds remaining!`);
          } else if (remaining <= 30) {
            timerProgressEl.classList.add('warning');
            announceUrgent(`${Math.round(remaining)} seconds remaining`);
          }
        }
        
        if (remaining <= 0) {
          stopCountdownTicker();
          announceUrgent('Time is up! Bidding is closed.');
        }
      }

      function announceUrgent(message) {
        const urgentEl = document.getElementById('aria-urgent');
        if (urgentEl) {
          urgentEl.textContent = message;
        }
      }

      function announcePolite(message) {
        const politeEl = document.getElementById('aria-announcements');
        if (politeEl) {
          politeEl.textContent = message;
        }
      }

      function startCountdownTicker() {
        updateCountdownDisplay();
        if (countdownTimerId == null) {
          countdownTimerId = setInterval(updateCountdownDisplay, 250);
        }
      }

      function formatSeconds(seconds) {
        if (seconds == null) {
          return '—';
        }
        const s = Math.max(0, Math.floor(seconds));
        const mins = Math.floor(s / 60);
        const secs = s % 60;
        return mins > 0 ? `${mins}:${secs.toString().padStart(2, '0')}` : `${secs}`;
      }

      function updatePlayerInfo() {
        if (!playersFieldset) {
          return;
        }

        const entries = Object.values(playersById || {});
        const hasPlayers = entries.length > 0;
        playersFieldset.hidden = !hasPlayers && !currentRoomCode;


        if (claimHostButton) {
          const canClaim = hostPlayerId == null && currentPlayerId != null;
          claimHostButton.hidden = !canClaim;
          claimHostButton.disabled = !canClaim || claimInFlight;
        }
      }

      function updateHostControls(state) {
        if (!hostControls || !nextRoundButton) {
          return;
        }
        const isHost = currentPlayerId != null && hostPlayerId != null && currentPlayerId === hostPlayerId;
        if (!isHost) {
          hostControls.hidden = true;
          nextRoundButton.disabled = true;
          return;
        }
        hostControls.hidden = false;
        const canAdvance = state.status === 'complete';
        nextRoundButton.disabled = !canAdvance || nextInFlight;
      }

      function renderAll(state) {
        lastStateSnapshot = state;
        statusEl.textContent = state.status;
        versionEl.textContent = state.stateVersion;
        
        // Show/hide start game button
        if (startGameContainer) {
          const shouldShowStartGame = state.status === 'bidding' && 
                                    (!state.currentTarget || !state.currentTarget.symbol);
          startGameContainer.hidden = !shouldShowStartGame;
        }
        
        // Load robot positions from server state
        console.log('State robotPositions:', state.robotPositions);
        if (state.robotPositions && typeof state.robotPositions === 'object') {
          console.log('Loading robot positions from server:', state.robotPositions);
          
          // Don't update robot positions during synchronized demonstration
          // to prevent conflicts with animation
          if (!isSynchronizedDemonstration) {
            // Update robot positions from server
            for (const [robotName, position] of Object.entries(state.robotPositions)) {
              if (position && typeof position === 'object' && 
                  typeof position.row === 'number' && typeof position.col === 'number') {
                robotState[robotName] = { row: position.row, col: position.col };
                console.log(`Set ${robotName} to position:`, position);
              }
            }
            renderRobots();
            updateSelectedRobotStyles();
          } else {
            console.log('Skipping robot position update during synchronized demonstration');
          }
        } else if (Object.keys(robotState).length === 0) {
          console.log('No server robot positions, initializing locally');
          // Initialize robots only if we have no server data and no local data
          initializeRobots();
          renderRobots();
          updateSelectedRobotStyles();
        }
        
        // Load current target from server state
        console.log('State currentTarget:', state.currentTarget);
        if (state.currentTarget && typeof state.currentTarget === 'object') {
          console.log('Loading target from server:', state.currentTarget);
          currentTarget = {
            row: state.currentTarget.row,
            col: state.currentTarget.col,
            symbol: state.currentTarget.symbol
          };
          renderTarget();
        } else {
          console.log('No server target, currentTarget is:', currentTarget);
        }
        
        // Handle demonstration synchronization
        handleDemonstrationSync(state);
        
        // Update puzzle number from server
        if (typeof state.roundNumber === 'number') {
          // Server returns the actual round count (1 for first round, 2 for second, etc.)
          // Display this as "Puzzle X of 17"
          currentPuzzleNumber = state.roundNumber;
          updatePuzzleProgress();
        }
        
        const playersState = state.players && typeof state.players === 'object' ? state.players : {};
        const nextPlayers = {};
        Object.keys(playersState).forEach(function (key) {
          const id = Number(key);
          if (!Number.isFinite(id)) {
            return;
          }
          const info = playersState[key] || {};
          nextPlayers[id] = {
            playerId: id,
            displayName: typeof info.displayName === 'string' ? info.displayName : '',
            color: 'Purple',
            tokensWon: Number.isFinite(info.tokensWon) ? info.tokensWon : 0
          };
        });
        playersById = nextPlayers;
        hostPlayerId = state.hostPlayerId != null && Number.isFinite(Number(state.hostPlayerId)) ? Number(state.hostPlayerId) : null;
        if (currentPlayerId != null && playersById[currentPlayerId]) {
          const selfInfo = playersById[currentPlayerId];
          if (selfInfo.displayName) {
            currentPlayerName = selfInfo.displayName;
          }
        }
        updatePlayerInfo();
        lowBidEl.textContent = state.currentLow != null ? state.currentLow : '—';
        lowBidderEl.textContent = state.currentLowBy != null ? `(by ${formatPlayerLabel(state.currentLowBy)})` : '';

        const currentLow = state.currentLow;
        const leader = state.currentLeader;
        const ties = Array.isArray(state.tiesAtCurrentLow) ? state.tiesAtCurrentLow : [];
        const tieCount = ties.length;


        leaderboardEl.innerHTML = '';
        (state.leaderboard || []).forEach(function (row) {
          const tr = document.createElement('tr');
          const nameCell = document.createElement('td');
          let playerName = formatPlayerLabel(row.playerId);
          // Add "Host" indicator if this player is the host
          if (hostPlayerId != null && row.playerId === hostPlayerId) {
            playerName += ' (Host)';
          }
          nameCell.textContent = playerName;
          
          const bidCell = document.createElement('td');
          // Find the current bid for this player
          let currentBid = '—';
          if (state.bids && Array.isArray(state.bids)) {
            const playerBids = state.bids.filter(bid => bid.playerId === row.playerId);
            if (playerBids.length > 0) {
              // Get the most recent bid
              const latestBid = playerBids[playerBids.length - 1];
              currentBid = latestBid.value != null ? latestBid.value : '—';
            }
          }
          bidCell.textContent = currentBid;
          
          const tokensCell = document.createElement('td');
          let tokensValue = Number.isFinite(row.tokensWon) ? row.tokensWon : null;
          if (tokensValue == null) {
            const info = getPlayerInfo(row.playerId);
            tokensValue = info && Number.isFinite(info.tokensWon) ? info.tokensWon : 0;
          }
          tokensCell.textContent = tokensValue != null ? tokensValue : '0';
          
          tr.appendChild(nameCell);
          tr.appendChild(bidCell);
          tr.appendChild(tokensCell);
          leaderboardEl.appendChild(tr);
        });

        let verifyingState = null;
        if (state.status === 'verifying' && state.verifying && Array.isArray(state.verifying.queue)) {
          const queueCopy = state.verifying.queue.map(function (entry) {
            return {
              playerId: entry.playerId,
              value: entry.value,
              tokensWon: entry.tokensWon,
              createdAt: entry.createdAt
            };
          });
          const currentIndex = Number.isInteger(state.verifying.currentIndex) ? state.verifying.currentIndex : 0;
          verifyingState = { queue: queueCopy, currentIndex: currentIndex };
        }

        lastVerifyingState = verifyingState;

        if (verifyingState) {
          verifyingContainer.hidden = false;
          verifyingQueueList.innerHTML = '';
          const queue = verifyingState.queue;
          const currentIndex = verifyingState.currentIndex >= 0 ? verifyingState.currentIndex : 0;

          if (queue.length === 0) {
            const emptyLi = document.createElement('li');
            emptyLi.textContent = 'No bids awaiting verification.';
            emptyLi.classList.add('empty');
            verifyingQueueList.appendChild(emptyLi);
          } else {
            queue.forEach(function (entry, index) {
              const li = document.createElement('li');
              const valueText = entry.value != null ? entry.value : '—';
              const tokensText = entry.tokensWon != null ? ` (tokens ${entry.tokensWon})` : '';
              li.textContent = `${formatPlayerLabel(entry.playerId)} @ ${valueText}${tokensText}`;
              if (index === currentIndex) {
                li.classList.add('current');
              }
              verifyingQueueList.appendChild(li);
            });
          }

          const currentEntry = getCurrentVerifier();
          if (currentEntry) {
            const valueText = currentEntry.value != null ? currentEntry.value : '—';
            const tokensText = currentEntry.tokensWon != null ? ` (tokens ${currentEntry.tokensWon})` : '';
            verifyingCurrent.textContent = `Current: ${formatPlayerLabel(currentEntry.playerId)} @ ${valueText}${tokensText}`;
          } else {
            verifyingCurrent.textContent = 'Current: —';
          }

          updateVerifyButtons();
        } else {
          verifyingContainer.hidden = true;
          verifyingQueueList.innerHTML = '';
          verifyingCurrent.textContent = 'Current: —';
          lastVerifyingState = null;
          verifyInFlight = false;
          updateVerifyButtons();
          setMessage(verifyMessage, '', false);
        }

        updateHostControls(state);
        updateBidLadder(state);
        
        // Check if we should enter demonstration mode
        if (state.status === 'verifying' && state.verifying && state.verifying.queue && state.verifying.queue.length > 0) {
          const currentIndex = state.verifying.currentIndex || 0;
          const currentEntry = state.verifying.queue[currentIndex];
          if (currentEntry && currentEntry.playerId) {
            // Start demonstration for all players (both the demonstrator and watchers)
            startDemonstration(currentEntry.playerId, currentEntry.value);
          }
        } else if (state.status !== 'verifying' && gameMode === 'demonstrating') {
          // Exit demonstration mode if verification is complete
          gameMode = 'bidding';
          updateGameModeUI();
        }

        if (leader && leader.playerId != null && leader.value != null) {
          const reason = leader.leaderReason || {};
          let reasonText = '';
          if (reason.kind === 'fewer_tokens') {
            const leaderTokens = Number.isFinite(reason.leaderTokens) ? reason.leaderTokens : leader.tokensWon;
            const otherTokens = Number.isFinite(reason.otherBestTokens) ? reason.otherBestTokens : undefined;
            const otherPart = otherTokens != null ? ` vs ${otherTokens}` : '';
            reasonText = `fewer tokens: ${leaderTokens != null ? leaderTokens : '—'}${otherPart}`;
          } else if (reason.kind === 'earlier_bid') {
            let timeText = '';
            if (reason.leaderCreatedAt) {
              const parsed = Date.parse(reason.leaderCreatedAt);
              if (!Number.isNaN(parsed)) {
                timeText = new Date(parsed).toLocaleTimeString();
              }
            }
            const leaderTokens = Number.isFinite(reason.leaderTokens) ? reason.leaderTokens : leader.tokensWon;
            const otherTokens = Number.isFinite(reason.otherBestTokens) ? reason.otherBestTokens : undefined;
            const tokenPart = leaderTokens != null && otherTokens != null ? ` (tokens ${leaderTokens} vs ${otherTokens})` : '';
            reasonText = timeText ? `earlier bid at ${timeText}${tokenPart}` : `earlier bid${tokenPart}`;
          } else if (reason.kind === 'new_low') {
            const leaderTokens = Number.isFinite(reason.leaderTokens) ? reason.leaderTokens : leader.tokensWon;
            reasonText = leaderTokens != null ? `new low bid (tokens ${leaderTokens})` : 'new low bid';
          }

          const baseText = `${formatPlayerLabel(leader.playerId)} @ ${leader.value}`;
          leadingText.textContent = reasonText ? `${baseText} (reason: ${reasonText})` : baseText;
          leadingPanel.hidden = false;
        } else {
          leadingPanel.hidden = true;
          leadingText.textContent = '';
        }

        lastServerRemaining = typeof state.remaining === 'number' ? state.remaining : null;
        const parsedServerNow = state.serverNow ? Date.parse(state.serverNow) : NaN;
        if (!Number.isNaN(parsedServerNow)) {
          lastServerTimestamp = parsedServerNow;
          if (!hasServerSkew) {
            serverSkewMs = parsedServerNow - Date.now();
            hasServerSkew = true;
          }
        } else {
          lastServerTimestamp = null;
          hasServerSkew = false;
        }

        if (lastServerRemaining == null || !hasServerSkew) {
          stopCountdownTicker();
          if (timerDisplayEl) timerDisplayEl.textContent = '—';
        } else {
          startCountdownTicker();
        }

        const biddingOpen = state.status === 'bidding' || state.status === 'countdown';
        setBidFormEnabled(Boolean(currentRoomCode && currentPlayerId && biddingOpen));
      }

      function estimateRemaining() {
        if (lastServerRemaining == null || lastServerTimestamp == null) {
          return null;
        }
        const serverNow = Date.now() + (hasServerSkew ? serverSkewMs : 0);
        const elapsed = Math.floor((serverNow - lastServerTimestamp) / 1000);
        return Math.max(0, lastServerRemaining - elapsed);
      }

      function runJoinFlow(code, displayName, selectedColor, options) {
        console.log('runJoinFlow called with:', { code, displayName, selectedColor, options });
        const normalizedCode = normalizeRoomCode(code);
        const sanitizedName = typeof displayName === 'string' ? displayName.trim() : '';
        const canonicalColor = 'Purple';
        const auto = Boolean(options && options.auto);
        const showToastOnSuccess = !(options && options.showToast === false);

        console.log('Normalized values:', { normalizedCode, sanitizedName, canonicalColor });

        if (!normalizedCode || !isValidRoomCode(normalizedCode) || !sanitizedName || !canonicalColor) {
          console.log('Validation failed in runJoinFlow');
          if (!auto && joinForm && !joinForm.hidden) {
            setJoinFormDisabled(false);
          }
          return;
        }

        if (joinInFlight) {
          console.log('Join already in flight');
          if (!auto && joinForm && !joinForm.hidden) {
            setJoinFormDisabled(false);
          }
          return;
        }

        console.log('Starting join process');
        joinInFlight = true;

        if (auto) {
          setJoinFormVisible(false);
          setEditIdentityVisible(false);
          showJoinStatusBanner(`Rejoining as ${formatIdentityLabel(sanitizedName, canonicalColor)}…`);
        }

        (async function connect() {
          const previousRoomCode = currentRoomCode;

          try {
            console.log('Calling joinOrUpdatePlayer with:', { normalizedCode, sanitizedName, canonicalColor });
            const result = await joinOrUpdatePlayer(normalizedCode, sanitizedName, canonicalColor);
            console.log('joinOrUpdatePlayer result:', result);
            const joinedPlayerId = Number(result.playerId) || null;
            const joinedName = result.displayName || sanitizedName;
            const joinedTokens = Number.isFinite(result.tokensWon) ? Number(result.tokensWon) : null;

            currentRoomCode = normalizedCode;
            currentPlayerId = joinedPlayerId;
            currentPlayerName = joinedName;
            saveStoredPlayer(normalizedCode, currentPlayerId, currentPlayerName, 'Purple');
            saveGlobalIdentity(currentPlayerId, currentPlayerName, 'Purple');
            storedPlayerInfo = { playerId: currentPlayerId, displayName: currentPlayerName, color: 'Purple' };
            updateJoinGateRoom(currentRoomCode);
            setMessage(bidMessage, '', false);
            playersFieldset.hidden = false;

            const switchingRooms = !previousRoomCode || previousRoomCode !== currentRoomCode;

            if (switchingRooms) {
              if (poller && typeof poller.stop === 'function') {
                poller.stop();
              }
              poller = null;
              resetClientState();
              playersById = {};
              hostPlayerId = null;
              updatePlayerInfo();
              updateHostControls({ status: 'bidding' });
            }

            if (currentPlayerId != null) {
              const existingTokens = playersById[currentPlayerId] && Number.isFinite(playersById[currentPlayerId].tokensWon)
                ? playersById[currentPlayerId].tokensWon
                : (joinedTokens != null ? joinedTokens : 0);
              playersById[currentPlayerId] = {
                playerId: currentPlayerId,
                displayName: currentPlayerName,
                color: 'Purple',
                tokensWon: existingTokens
              };
              updatePlayerInfo();
              updateHostControls(lastStateSnapshot || { status: lastStateSnapshot ? lastStateSnapshot.status : 'bidding' });
            }

            if (!poller) {
              poller = window.PollingHelpers.createLongPoller({
                code: currentRoomCode,
                renderAll: renderAll
              });
            }

            ensureBoardReady();
            showRoomApp();
            setJoinGateVisible(false);
            maybeShowShareBanner(currentRoomCode);
            hideJoinStatusBanner();
            setMessage(joinMessage, '', false);
            setJoinFormVisible(false);
            setEditIdentityVisible(true);
            const identityLabel = formatIdentityLabel(currentPlayerName, 'Purple');
            if (showToastOnSuccess) {
              showToast(`Joined as ${identityLabel}`, false);
            }
            const startResult = poller.start();
            if (startResult && typeof startResult.then === 'function') {
              await startResult;
            }
          } catch (err) {
            console.error('Error in join flow:', err);
            const message = err && err.message ? err.message : 'Unable to join the room.';
            console.log('Error message:', message);
            if (auto) {
              setJoinFormVisible(true);
            }
            setEditIdentityVisible(false);
            
            // Try to get more details about the error
            if (err && err.response) {
              console.log('Error response:', err.response);
              try {
                const errorData = JSON.parse(err.response);
                console.log('Parsed error data:', errorData);
              } catch (e) {
                console.log('Could not parse error response as JSON');
              }
            }
            hideJoinStatusBanner();
            setMessage(joinMessage, message, true);
            showToast(message, true);
            if (err && err.status === 404) {
              clearStoredPlayer(normalizedCode);
            }
          } finally {
            if (!auto && joinForm && !joinForm.hidden) {
              setJoinFormDisabled(false);
            }
            joinInFlight = false;
          }
        }());
      }

      joinForm.addEventListener('submit', function (event) {
        event.preventDefault();
        console.log('Join form submitted');
        hideColorWarning();

        if (!window.PollingHelpers) {
          console.log('PollingHelpers not available, trying direct join');
          // Try to join directly without PollingHelpers
          const code = normalizeRoomCode(roomCodeInput.value);
          const displayName = playerNameInput.value.trim();
          const selectedColor = 'Purple'; // Default color
          
          if (!code || !displayName) {
            setMessage(joinMessage, 'Please fill in all fields.', true);
            return;
          }
          
          setMessage(joinMessage, 'Joining directly...', false);
          setJoinFormDisabled(true);
          
          // Call joinOrUpdatePlayer directly
          joinOrUpdatePlayer(code, displayName, selectedColor).then(function(result) {
            console.log('Direct join result:', result);
            // Manually trigger the success flow
            const joinedPlayerId = Number(result.playerId) || null;
            const joinedName = result.displayName || displayName;
            
            currentRoomCode = code;
            currentPlayerId = joinedPlayerId;
            currentPlayerName = joinedName;
            
            showRoomApp();
            setJoinGateVisible(false);
            maybeShowShareBanner(code);
            setMessage(joinMessage, '', false);
            setJoinFormVisible(false);
            setEditIdentityVisible(true);
            
            console.log('Direct join successful');
          }).catch(function(err) {
            console.error('Direct join failed:', err);
            setMessage(joinMessage, err.message || 'Failed to join room', true);
            setJoinFormDisabled(false);
          });
          return;
        }

        const code = normalizeRoomCode(roomCodeInput.value);
        const displayName = playerNameInput.value.trim();
        const selectedColor = 'Purple'; // Default color

        console.log('Form data:', { code, displayName, selectedColor });

        if (!code) {
          console.log('No room code provided');
          setMessage(joinMessage, 'Enter a room code to join.', true);
          return;
        }
        if (!isValidRoomCode(code)) {
          console.log('Invalid room code:', code);
          setMessage(joinMessage, 'Room codes use lowercase letters, numbers, and single hyphen (no leading, trailing, or double hyphen).', true);
          return;
        }
        if (!displayName) {
          console.log('No display name provided');
          setMessage(joinMessage, 'Enter a display name.', true);
          return;
        }

        console.log('All validation passed, starting join flow');
        roomCodeInput.value = code;
        playerNameInput.value = displayName;
        setMessage(joinMessage, 'Joining…', false);
        setJoinFormDisabled(true);
        runJoinFlow(code, displayName, selectedColor, { auto: false });
      });

      if (editIdentityButton) {
        editIdentityButton.addEventListener('click', function () {
          if (joinInFlight) {
            return;
          }
          setJoinGateVisible(true);
          setJoinFormVisible(true);
          setEditIdentityVisible(false);
          updateJoinGateRoom(currentRoomCode || roomCodeInput.value);
          hideJoinStatusBanner();
          setMessage(joinMessage, '', false);
          hideColorWarning();
          if (playerNameInput) {
            playerNameInput.focus({ preventScroll: true });
          }
        });
      }

      if (shareCopyButton) {
        shareCopyButton.addEventListener('click', function () {
          copyShareLink();
        });
      }

      if (shareDismissButton) {
        shareDismissButton.addEventListener('click', function () {
          console.log('Share dismiss button clicked');
          hideShareBanner();
        });
      }

      // Check PollingHelpers availability after a short delay
      setTimeout(function() {
        console.log('After timeout, PollingHelpers available:', !!window.PollingHelpers);
        if (!window.PollingHelpers) {
          console.log('PollingHelpers still not available after timeout');
        }
      }, 1000);

      if (autoJoinContext && !autoJoinScheduled) {
        console.log('Starting auto-join process for:', autoJoinContext);
        autoJoinScheduled = true;
        whenPollingHelpersReady(function () {
          console.log('PollingHelpers ready, executing auto-join');
          const autoName = typeof autoJoinContext.displayName === 'string'
            ? autoJoinContext.displayName.trim()
            : '';
          const autoColor = 'Purple'; // Default color
          if (!autoName) {
            console.log('No auto name found, showing join form');
            setJoinFormVisible(true);
            setEditIdentityVisible(false);
            hideJoinStatusBanner();
            return;
          }
          console.log('Running auto-join flow with:', { code: autoJoinContext.code, name: autoName, color: autoColor });
          runJoinFlow(autoJoinContext.code, autoName, autoColor, { auto: true });
        }, function () {
          console.log('PollingHelpers timeout, showing join form');
          setJoinFormVisible(true);
          setEditIdentityVisible(false);
          hideJoinStatusBanner();
        });
      } else {
        console.log('No auto-join context or already scheduled');
      }

      // Show share banner if we have a room code (either from created=1 or just visiting a room)
      if (initialRoomCode) {
        console.log('Page loaded with room code, showing share banner');
        maybeShowShareBanner(initialRoomCode);
      }

      // Initialize puzzle progress
      updatePuzzleProgress();

      bidForm.addEventListener('submit', function (event) {
        event.preventDefault();
        submitBid();
      });

      async function submitBid() {
        setMessage(bidMessage, '', false);
        if (!currentRoomCode || !currentPlayerId) {
          setMessage(bidMessage, 'Join a room first.', true);
          return;
        }
        if (!bidAllowed) {
          setMessage(bidMessage, 'Bidding is closed.', true);
          return;
        }
        const rawValue = bidInput ? bidInput.value.trim() : '';
        if (!rawValue) {
          setMessage(bidMessage, 'Enter a positive bid value.', true);
          return;
        }
        const value = Number.parseInt(rawValue, 10);
        if (!Number.isFinite(value) || value <= 0) {
          setMessage(bidMessage, 'Enter a positive bid value.', true);
          return;
        }
        if (bidInFlight) {
          return;
        }

        bidInFlight = true;
        updateBidFormState();
        try {
          await window.PollingHelpers.submitBid(currentRoomCode, currentPlayerId, value);
          if (bidInput) {
            bidInput.value = '';
            if (!bidInput.disabled) {
              bidInput.focus({ preventScroll: true });
            }
          }
        } catch (err) {
          console.error(err);
          const message = err && err.message ? err.message : 'Bid failed.';
          setMessage(bidMessage, message, true);
          showToast(message, true);
          if (message.toLowerCase().includes('bidding is closed')) {
            setBidFormEnabled(false);
          }
        } finally {
          bidInFlight = false;
          updateBidFormState();
        }
      }

      setBidFormEnabled(false);
      setMessage(verifyMessage, '', false);
      updateVerifyButtons();

      verifyPassButton.addEventListener('click', function () {
        if (!currentRoomCode) {
          setMessage(verifyMessage, 'Join a room first.', true);
          return;
        }

        if (hostPlayerId == null || currentPlayerId == null || currentPlayerId !== hostPlayerId) {
          setMessage(verifyMessage, 'Only the host can mark verification results.', true);
          return;
        }

        const currentEntry = getCurrentVerifier();
        if (!currentEntry) {
          setMessage(verifyMessage, 'No verifier available.', true);
          return;
        }

        verifyInFlight = true;
        updateVerifyButtons();
        setMessage(verifyMessage, '', false);

        callVerificationAPI(true).then(function () {
          setMessage(verifyMessage, `Marked ${formatPlayerLabel(currentEntry.playerId)} as solved.`, false);
        }).catch(function (err) {
          console.error(err);
          const message = err && err.message ? err.message : 'Verification update failed.';
          setMessage(verifyMessage, message, true);
        }).finally(function () {
          verifyInFlight = false;
          updateVerifyButtons();
        });
      });

      verifyFailButton.addEventListener('click', function () {
        if (!currentRoomCode) {
          setMessage(verifyMessage, 'Join a room first.', true);
          return;
        }

        if (hostPlayerId == null || currentPlayerId == null || currentPlayerId !== hostPlayerId) {
          setMessage(verifyMessage, 'Only the host can advance the queue.', true);
          return;
        }

        const currentEntry = getCurrentVerifier();
        if (!currentEntry) {
          setMessage(verifyMessage, 'No verifier available.', true);
          return;
        }

        verifyInFlight = true;
        updateVerifyButtons();
        setMessage(verifyMessage, '', false);

        callVerificationAPI(false).then(function () {
          setMessage(verifyMessage, 'Advanced to next verifier.', false);
        }).catch(function (err) {
          console.error(err);
          const message = err && err.message ? err.message : 'Verification update failed.';
          setMessage(verifyMessage, message, true);
        }).finally(function () {
          verifyInFlight = false;
          updateVerifyButtons();
        });
      });

      if (claimHostButton) {
        claimHostButton.addEventListener('click', function () {
          if (!currentRoomCode || !currentPlayerId) {
            showToast('Join a room first.', true);
            return;
          }
          if (hostPlayerId != null && currentPlayerId !== hostPlayerId) {
            showToast('Host already assigned.', true);
            return;
          }

          claimInFlight = true;
          claimHostButton.disabled = true;
          claimHostOnServer(currentRoomCode, currentPlayerId).then(function () {
            hostPlayerId = currentPlayerId;
            updatePlayerInfo();
            updateHostControls(lastStateSnapshot || { status: lastStateSnapshot ? lastStateSnapshot.status : 'bidding' });
            showToast('You are now the host.', false);
          }).catch(function (err) {
            console.error(err);
            const message = err && err.message ? err.message : 'Unable to claim host role.';
            showToast(message, true);
          }).finally(function () {
            claimInFlight = false;
            updatePlayerInfo();
          });
        });
      }

      if (nextRoundButton) {
        nextRoundButton.addEventListener('click', function () {
          if (!currentRoomCode || !currentPlayerId) {
            setMessage(nextMessage, 'Join a room first.', true);
            return;
          }
          if (hostPlayerId == null || currentPlayerId !== hostPlayerId) {
            setMessage(nextMessage, 'Only the host can start the next round.', true);
            return;
          }

          nextInFlight = true;
          nextRoundButton.disabled = true;
          setMessage(nextMessage, '', false);

          window.PollingHelpers.startNextRound(currentRoomCode, currentPlayerId).then(function () {
            setMessage(nextMessage, 'Next round requested.', false);
            resetGameForNextRound();
          }).catch(function (err) {
            console.error(err);
            const message = err && err.message ? err.message : 'Unable to start next round.';
            setMessage(nextMessage, message, true);
          }).finally(function () {
            nextInFlight = false;
            updateHostControls(lastStateSnapshot || { status: lastStateSnapshot ? lastStateSnapshot.status : 'complete' });
          });
        });
      }

      if (startGameButton) {
        startGameButton.addEventListener('click', function () {
          if (!currentRoomCode || !currentPlayerId) {
            showToast('Join a room first.', true);
            return;
          }
          
          // Prevent multiple rapid clicks
          if (startGameButton.disabled) {
            return;
          }
          
          startGameButton.disabled = true;
          showToast('Starting game...', false);
          
          // Start the game by calling next round (which will generate the first target)
          window.PollingHelpers.startNextRound(currentRoomCode, currentPlayerId).then(function () {
            showToast('Game started!', false);
            startGameContainer.hidden = true;
            resetGameForNextRound();
          }).catch(function (err) {
            console.error(err);
            const message = err && err.message ? err.message : 'Unable to start game.';
            showToast(message, true);
            // Re-enable button on error so user can try again
            startGameButton.disabled = false;
          });
        });
      }

      function showToast(message, isError) {
        if (!toastEl) {
          return;
        }
        if (toastTimeoutId) {
          clearTimeout(toastTimeoutId);
        }
        toastEl.textContent = message;
        toastEl.setAttribute('aria-live', isError ? 'assertive' : 'polite');
        toastEl.classList.remove('toast--error', 'toast--info', 'toast--visible');
        void toastEl.offsetWidth;
        toastEl.classList.add(isError ? 'toast--error' : 'toast--info');
        toastEl.classList.add('toast--visible');
        toastTimeoutId = window.setTimeout(hideToast, 4000);
      }

      function hideToast() {
        if (!toastEl) {
          return;
        }
        toastEl.classList.remove('toast--visible');
      }

      function ensureCellWall(row, col) {
        if (row < 0 || row >= BOARD_SIZE || col < 0 || col >= BOARD_SIZE) {
          return null;
        }
        const key = `${row},${col}`;
        if (!boardWalls.has(key)) {
          boardWalls.set(key, { top: false, bottom: false, left: false, right: false });
        }
        return boardWalls.get(key);
      }

      function addWall(row, col, side) {
        const cell = ensureCellWall(row, col);
        if (!cell) {
          return;
        }
        cell[side] = true;
        const relation = WALL_RELATIONS[side];
        if (!relation) {
          return;
        }
        const neighborRow = row + relation.dr;
        const neighborCol = col + relation.dc;
        const neighborCell = ensureCellWall(neighborRow, neighborCol);
        if (neighborCell) {
          neighborCell[relation.opposite] = true;
        }
      }

      function buildWallData() {
        boardWalls.clear();
        for (let r = 0; r < BOARD_SIZE; r += 1) {
          for (let c = 0; c < BOARD_SIZE; c += 1) {
            ensureCellWall(r, c);
          }
        }
        
        // Apply walls from static data only
        Object.entries(STATIC_WALL_DATA).forEach(([key, arr]) => {
          if (!Array.isArray(arr) || arr.length < 4) {
            return;
          }
          
          const [top, bottom, left, right] = arr;
          const [row, col] = key.split(',').map(Number);
          
          // Skip if outside board bounds
          if (row < 0 || row >= BOARD_SIZE || col < 0 || col >= BOARD_SIZE) {
            return;
          }
          
          if (top) {
            addWall(row, col, 'top');
          }
          if (bottom) {
            addWall(row, col, 'bottom');
          }
          if (left) {
            addWall(row, col, 'left');
          }
          if (right) {
            addWall(row, col, 'right');
          }
        });
      }

      function buildBoardGrid() {
        if (!boardGridEl) {
          return;
        }
        const fragment = document.createDocumentFragment();
        boardGridEl.innerHTML = '';
        for (let r = 0; r < BOARD_SIZE; r += 1) {
          for (let c = 0; c < BOARD_SIZE; c += 1) {
            const cell = document.createElement('div');
            cell.className = 'board-cell';
            cell.dataset.row = String(r);
            cell.dataset.col = String(c);
            
            // Add center-cell class for the center 4 squares
            if ((r === 7 || r === 8) && (c === 7 || c === 8)) {
              cell.classList.add('center-cell');
            }
            const cellWalls = boardWalls.get(`${r},${c}`);
            if (cellWalls) {
              if (cellWalls.top) {
                cell.classList.add('wall-top');
              }
              if (cellWalls.bottom) {
                cell.classList.add('wall-bottom');
              }
              if (cellWalls.left) {
                cell.classList.add('wall-left');
              }
              if (cellWalls.right) {
                cell.classList.add('wall-right');
              }
            }
            fragment.appendChild(cell);
          }
        }
        boardGridEl.appendChild(fragment);
      }

      function initializeRobots() {
        const occupiedPositions = new Set();
        
        // Get all symbol positions
        boardGridEl.querySelectorAll('.emoji-target').forEach(symbol => {
          const cell = symbol.closest('.board-cell');
          if (cell) {
            const row = parseInt(cell.dataset.row);
            const col = parseInt(cell.dataset.col);
            occupiedPositions.add(`${row},${col}`);
          }
        });
        
        // Place each robot randomly, avoiding symbols and other robots
        ROBOT_ORDER.forEach(function (name) {
          let position = null;
          let tries = 0;
          
          while (position === null && tries < 200) {
            const row = Math.floor(Math.random() * BOARD_SIZE);
            const col = Math.floor(Math.random() * BOARD_SIZE);
            const key = `${row},${col}`;
            
            // Skip if position is occupied by symbol, other robot, or center area
            if (!occupiedPositions.has(key) && 
                !((row === 7 || row === 8) && (col === 7 || col === 8))) {
              position = { row, col };
              occupiedPositions.add(key);
            }
            tries++;
          }
          
          // Fallback to original position if random placement fails
          if (position === null) {
          const start = INITIAL_ROBOT_POSITIONS[name] || { row: 0, col: 0 };
            position = {
              row: Math.max(0, Math.min(BOARD_SIZE - 1, start.row)),
              col: Math.max(0, Math.min(BOARD_SIZE - 1, start.col))
            };
          }
          
          robotState[name] = position;
        });
      }

      function renderRobotBadges() {
        if (!robotBadgesEl) {
          return;
        }
        robotBadgesEl.innerHTML = '';
        const fragment = document.createDocumentFragment();
        ROBOT_ORDER.forEach(function (name) {
          const meta = ROBOT_META[name];
          if (!meta) {
            return;
          }
          const button = document.createElement('button');
          button.type = 'button';
          button.className = `robot-badge ${meta.badgeClass}`;
          button.dataset.robot = name;
          button.textContent = name;
          button.setAttribute('aria-pressed', 'false');
          button.addEventListener('click', function () {
            selectRobotByName(name);
            if (boardEl) {
              boardEl.focus({ preventScroll: true });
            }
          });
          fragment.appendChild(button);
        });
        robotBadgesEl.appendChild(fragment);
      }

      function renderRobots() {
        if (!robotLayerEl) {
          return;
        }
        robotLayerEl.innerHTML = '';
        const fragment = document.createDocumentFragment();
        ROBOT_ORDER.forEach(function (name) {
          const state = robotState[name];
          const meta = ROBOT_META[name];
          if (!state || !meta) {
            console.log(`Skipping robot ${name}: state=${!!state}, meta=${!!meta}`);
            return;
          }
          const robotEl = document.createElement('div');
          robotEl.className = `robot ${meta.robotClass}`;
          
          
          robotEl.dataset.robot = name;
          robotEl.dataset.row = state.row;
          robotEl.dataset.col = state.col;
          
          // Calculate position as percentage
          const leftPercent = (state.col * 100) / 16;
          const topPercent = (state.row * 100) / 16;
          robotEl.style.left = `calc(${leftPercent}% + 3px)`;
          robotEl.style.top = `calc(${topPercent}% + 3px)`;
          
          console.log(`Robot ${name}: row=${state.row}, col=${state.col}, left=${leftPercent}%, top=${topPercent}%`);
          robotEl.setAttribute('role', 'img');
          robotEl.setAttribute('aria-label', `${name} robot at row ${state.row} column ${state.col}`);
          robotEl.tabIndex = -1;
          const label = document.createElement('span');
          label.className = 'robot-label';
          label.textContent = meta.shortLabel;
          robotEl.appendChild(label);
          robotEl.addEventListener('click', function () {
            selectRobotByName(name);
            if (boardEl) {
              boardEl.focus({ preventScroll: true });
            }
          });
          fragment.appendChild(robotEl);
        });
        robotLayerEl.appendChild(fragment);
        updateSelectedRobotStyles();
      }

      function highlightSelectedCell() {
        if (!boardGridEl) {
          return;
        }
        boardGridEl.querySelectorAll('.board-cell.is-selected').forEach(function (cell) {
          cell.classList.remove('is-selected');
        });
        const currentName = ROBOT_ORDER[robotIdx];
        const state = robotState[currentName];
        if (!state) {
          return;
        }
        const cell = boardGridEl.querySelector(`.board-cell[data-row="${state.row}"][data-col="${state.col}"]`);
        if (cell) {
          cell.classList.add('is-selected');
        }
      }

      function updateSelectedRobotStyles() {
        const currentName = ROBOT_ORDER[robotIdx];
        if (robotBadgesEl) {
          robotBadgesEl.querySelectorAll('.robot-badge').forEach(function (badge) {
            const isCurrent = badge.dataset.robot === currentName;
            badge.classList.toggle('is-selected', isCurrent);
            badge.setAttribute('aria-pressed', isCurrent ? 'true' : 'false');
            badge.setAttribute('aria-label', `${badge.dataset.robot} robot${isCurrent ? ' (selected)' : ''}`);
          });
        }
        if (robotLayerEl) {
          robotLayerEl.querySelectorAll('.robot').forEach(function (robotEl) {
            const isCurrent = robotEl.dataset.robot === currentName;
            robotEl.classList.toggle('is-selected', isCurrent);
            robotEl.setAttribute('aria-current', isCurrent ? 'true' : 'false');
            
            const state = robotState[robotEl.dataset.robot];
            if (state) {
              robotEl.setAttribute('aria-label', 
                `${robotEl.dataset.robot} robot at row ${state.row}, column ${state.col}${isCurrent ? ' (selected)' : ''}`);
            }
          });
        }
        if (boardSelectionEl) {
          if (currentName && robotState[currentName]) {
            const pos = robotState[currentName];
            boardSelectionEl.textContent = `Selected robot: ${currentName} (${pos.row}, ${pos.col})`;
            announcePolite(`Selected ${currentName} robot at position ${pos.row}, ${pos.col}`);
          } else {
            boardSelectionEl.textContent = 'Selected robot: —';
          }
        }
        highlightSelectedCell();
      }

      function selectRobotByIndex(index) {
        if (!ROBOT_ORDER.length) {
          return;
        }
        const normalized = ((index % ROBOT_ORDER.length) + ROBOT_ORDER.length) % ROBOT_ORDER.length;
        robotIdx = normalized;
        updateSelectedRobotStyles();
      }

      function selectRobotByName(name) {
        const nextIndex = ROBOT_ORDER.indexOf(name);
        if (nextIndex === -1) {
          return;
        }
        selectRobotByIndex(nextIndex);
      }

      function isRobotAt(row, col, ignoreName) {
        return ROBOT_ORDER.some(function (name) {
          if (name === ignoreName) {
            return false;
          }
          const state = robotState[name];
          return state && state.row === row && state.col === col;
        });
      }

      function hasWall(row, col, side) {
        if (row < 0 || row >= BOARD_SIZE || col < 0 || col >= BOARD_SIZE) {
          return true;
        }
        const cell = boardWalls.get(`${row},${col}`);
        return cell ? Boolean(cell[side]) : false;
      }

      function canMove(row, col, direction) {
        switch (direction) {
          case 'UP':
            return row > 0 && !hasWall(row, col, 'top') && !hasWall(row - 1, col, 'bottom');
          case 'DOWN':
            return row < BOARD_SIZE - 1 && !hasWall(row, col, 'bottom') && !hasWall(row + 1, col, 'top');
          case 'LEFT':
            return col > 0 && !hasWall(row, col, 'left') && !hasWall(row, col - 1, 'right');
          case 'RIGHT':
            return col < BOARD_SIZE - 1 && !hasWall(row, col, 'right') && !hasWall(row, col + 1, 'left');
          default:
            return false;
        }
      }

      function moveOne(row, col, direction) {
        switch (direction) {
          case 'UP':
            return { row: row - 1, col: col };
          case 'DOWN':
            return { row: row + 1, col: col };
          case 'LEFT':
            return { row: row, col: col - 1 };
          case 'RIGHT':
            return { row: row, col: col + 1 };
          default:
            return { row: row, col: col };
        }
      }

      function computeSlide(row, col, direction, ignoreName) {
        let nextRow = row;
        let nextCol = col;
        while (canMove(nextRow, nextCol, direction)) {
          const candidate = moveOne(nextRow, nextCol, direction);
          if (isRobotAt(candidate.row, candidate.col, ignoreName)) {
            break;
          }
          nextRow = candidate.row;
          nextCol = candidate.col;
        }
        return { row: nextRow, col: nextCol };
      }

      // Enhanced movement system for Ricochet Robot
      function validateMove(robotName, direction) {
        const state = robotState[robotName];
        if (!state) return false;
        
        const next = computeSlide(state.row, state.col, direction, robotName);
        return next.row !== state.row || next.col !== state.col;
      }

      function executeMove(robotName, direction, isDemo = false) {
        const state = robotState[robotName];
        if (!state) return false;
        
        const startPos = { row: state.row, col: state.col };
        const endPos = computeSlide(state.row, state.col, direction, robotName);
        
        if (startPos.row === endPos.row && startPos.col === endPos.col) {
          return false; // No movement possible
        }
        
        // Validate move sequence during demonstration to prevent teleportation
        if (!isDemo && gameMode === 'demonstrating' && moveHistory.length > 0) {
          const lastMove = moveHistory[moveHistory.length - 1];
          if (lastMove.robot === robotName && 
              (lastMove.to.row !== startPos.row || lastMove.to.col !== startPos.col)) {
            console.warn(`Move sequence mismatch for ${robotName}. Expected from: (${lastMove.to.row},${lastMove.to.col}), actual from: (${startPos.row},${startPos.col})`);
            // Correct the robot position to match the last move
            state.row = lastMove.to.row;
            state.col = lastMove.to.col;
            console.log(`Corrected ${robotName} position to (${state.row},${state.col})`);
          }
        }
        
        // Count moves during demonstration
        if (gameMode === 'demonstrating' && !isDemo) {
          demonstrationMoves++;
          updateMoveCounter();
        }
        
        // Save to history for undo/redo (only in thinking mode)
        if (!isDemo && gameMode === 'thinking') {
          moveHistory.push({
            robot: robotName,
            from: { ...startPos },
            to: { ...endPos },
            direction: direction
          });
        }
        
        // Send move to server in real-time during demonstration
        if (!isDemo && gameMode === 'demonstrating') {
          const move = {
            robot: robotName,
            from: { ...startPos },
            to: { ...endPos },
            direction: direction
          };
          moveHistory.push(move);
          queueMoveForServer(move);
        }
        
        state.row = endPos.row;
        state.col = endPos.col;
        
        if (!isDemo) {
          renderRobots();
          updateSelectedRobotStyles();
        }
        
        return true;
      }

      function checkTargetReached(robotName) {
        if (!currentTarget) return false;
        
        const state = robotState[robotName];
        if (!state) return false;
        
        // Check if robot is on the target cell
        return state.row === currentTarget.row && state.col === currentTarget.col;
      }

      function getRobotAt(row, col) {
        for (const [name, state] of Object.entries(robotState)) {
          if (state.row === row && state.col === col) {
            return name;
          }
        }
        return null;
      }

      // Thinking mode and sandbox functionality
      function enterThinkingMode() {
        if (gameMode === 'thinking') return;
        
        // Save current state as sandbox
        sandboxState = JSON.parse(JSON.stringify(robotState));
        moveHistory = [];
        gameMode = 'thinking';
        updateGameModeUI();
      }

      function exitThinkingMode() {
        if (gameMode !== 'thinking') return;
        
        // Restore original state
        robotState = JSON.parse(JSON.stringify(sandboxState));
        moveHistory = [];
        gameMode = 'bidding';
        updateGameModeUI();
        renderRobots();
        updateSelectedRobotStyles();
      }

      function resetSandbox() {
        if (gameMode !== 'thinking') return;
        
        robotState = JSON.parse(JSON.stringify(sandboxState));
        moveHistory = [];
        renderRobots();
        updateSelectedRobotStyles();
      }

      function undoMove() {
        if (gameMode !== 'thinking' || moveHistory.length === 0) return;
        
        const lastMove = moveHistory.pop();
        const state = robotState[lastMove.robot];
        if (state) {
          state.row = lastMove.from.row;
          state.col = lastMove.from.col;
          renderRobots();
          updateSelectedRobotStyles();
        }
      }

      function redoMove() {
        // For now, redo is not implemented (would require a separate redo stack)
        // This could be added later if needed
      }

      function updateGameModeUI() {
      // Update UI to reflect current game mode
      const modeIndicator = document.getElementById('game-mode-indicator');
      if (modeIndicator) {
        modeIndicator.textContent = `Mode: ${gameMode}`;
      }
      
      // Show/hide sandbox controls
      const sandboxControls = document.getElementById('sandbox-controls');
      if (sandboxControls) {
        sandboxControls.hidden = gameMode !== 'thinking';
      }
      
      // Show/hide demonstration controls
      const demonstrationControls = document.getElementById('demonstration-controls');
      if (demonstrationControls) {
        demonstrationControls.hidden = gameMode !== 'demonstrating';
      }
      
      // Show/hide demo controls
        const demoControls = document.getElementById('demo-controls');
        if (demoControls) {
          demoControls.hidden = !demoMode;
        }
      }

      function updatePuzzleProgress() {
        const currentPuzzleEl = document.getElementById('current-puzzle');
        const totalPuzzlesEl = document.getElementById('total-puzzles');
        
        if (currentPuzzleEl) {
          currentPuzzleEl.textContent = currentPuzzleNumber;
        }
        if (totalPuzzlesEl) {
          totalPuzzlesEl.textContent = totalPuzzles;
        }
      }

      function updateMoveCounter() {
        const moveCounterEl = document.getElementById('move-counter');
        if (moveCounterEl) {
          if (currentPlayerBid !== null) {
            moveCounterEl.innerHTML = `
              <div style="font-size: 1.2rem; margin-bottom: 0.25rem;">Moves: ${demonstrationMoves}</div>
              <div style="font-size: 0.9rem; opacity: 0.9;">Bid: ${currentPlayerBid}</div>
            `;
          } else {
            moveCounterEl.textContent = `Moves: ${demonstrationMoves}`;
          }
        }
      }

      function startDemonstration(playerId, playerBid) {
        // Check if we're already in the same demonstration to prevent restarts
        if (gameMode === 'demonstrating' && currentPlayerBid === playerBid) {
          console.log(`Already in demonstration for player ${playerId} with bid ${playerBid} - skipping restart`);
          return;
        }
        
        console.log(`Starting demonstration for player ${playerId} with bid ${playerBid}`);
        gameMode = 'demonstrating';
        demonstrationMoves = 0;
        currentPlayerBid = playerBid;
        moveHistory = []; // Reset move history for this demonstration
        updateGameModeUI();
        updateMoveCounter();
        
        // Start demonstration synchronization
        startDemonstrationSync(playerId);
        
        // If this is the current player demonstrating, show different message
        if (currentPlayerId === playerId) {
          showToast(`🎯 Your turn to demonstrate! You bid ${playerBid} moves. Show your solution!`, false);
        } else {
          showToast(`🎬 ${formatPlayerLabel(playerId)} is demonstrating their solution (bid: ${playerBid})...`, false);
        }
      }

      function endDemonstration(success, playerId, playerBid) {
        console.log(`Ending demonstration: success=${success}, player=${playerId}, bid=${playerBid}, moves=${demonstrationMoves}`);
        
        if (success && demonstrationMoves <= playerBid) {
          // Success! Award point and move to next puzzle
          showToast(`🎉 ${formatPlayerLabel(playerId)} solved it in ${demonstrationMoves} moves! (bid: ${playerBid}) - You get the point!`, false);
          awardChipToPlayer(playerId);
          callVerificationAPI(true); // Mark as successful - advanceToNextPuzzle will be called in the success callback
        } else {
          // Failed - either didn't reach target or used too many moves
          let reason;
          if (!success) {
            reason = "didn't reach the target";
          } else {
            reason = `used ${demonstrationMoves} moves (bid: ${playerBid})`;
          }
          showToast(`❌ ${formatPlayerLabel(playerId)} failed: ${reason}. Moving to next player.`, true);
          
          // Call server API to mark this attempt as failed and advance to next player
          // Server will reset robots to original positions
          callVerificationAPI(false);
        }
        
        // Stop demonstration synchronization
        stopDemonstrationSync();
        
        // Clear any pending move timers to prevent race conditions
        if (moveDebounceTimer) {
          clearTimeout(moveDebounceTimer);
          moveDebounceTimer = null;
        }
        pendingMoves = [];
        
        gameMode = 'bidding';
        updateGameModeUI();
      }

      function advanceToNextPuzzle() {
        currentPuzzleNumber++;
        updatePuzzleProgress();
        
        if (currentPuzzleNumber > totalPuzzles) {
          // Game over!
          endGame();
        } else {
          // Start new round with new puzzle
          resetGameForNextRound();
          showToast(`Puzzle ${currentPuzzleNumber} of ${totalPuzzles}`, false);
          
          // Call next_round API to create a new round
          window.PollingHelpers.startNextRound(currentRoomCode, currentPlayerId).then(function () {
            showToast('New puzzle started!', false);
          }).catch(function (error) {
            console.error('Failed to start next round:', error);
            showToast('Failed to start next puzzle. Please try again.', true);
          });
        }
      }

      function endGame(winnerPlayerId = null, winReason = null) {
        if (winnerPlayerId && winReason) {
          showToast(`🏆 GAME OVER! ${formatPlayerLabel(winnerPlayerId)} wins! ${winReason}`, false);
        } else {
          showToast('Game Over! All 17 puzzles have been solved!', false);
        }
        
        // TODO: Show final scores and winner
        gameMode = 'complete';
        updateGameModeUI();
        
        // Disable all game controls
        const nextRoundButton = document.getElementById('next-round');
        if (nextRoundButton) {
          nextRoundButton.disabled = true;
        }
      }

      function advanceVerificationQueue() {
        // This would trigger the next player in the verification queue
        // The server will handle advancing to the next player
        console.log('Advancing to next player in verification queue');
        // The polling system will pick up the next player automatically
      }

      function updateBidLadder(state) {
        if (!bidLadderListEl) return;
        
        const bids = state.bids || [];
        const currentLow = state.currentLow;
        const currentLowBy = state.currentLowBy;
        
        // Group bids by value and sort
        const bidGroups = {};
        bids.forEach(bid => {
          const value = bid.value;
          if (!bidGroups[value]) {
            bidGroups[value] = [];
          }
          bidGroups[value].push(bid);
        });
        
        // Sort by value (ascending)
        const sortedValues = Object.keys(bidGroups).sort((a, b) => parseInt(a) - parseInt(b));
        
        bidLadderListEl.innerHTML = '';
        
        if (sortedValues.length === 0) {
          const emptyItem = document.createElement('div');
          emptyItem.className = 'bid-ladder-item';
          emptyItem.innerHTML = '<span class="bid-ladder-player">No bids yet</span>';
          bidLadderListEl.appendChild(emptyItem);
          return;
        }
        
        sortedValues.forEach(value => {
          const group = bidGroups[value];
          const isLeading = parseInt(value) === currentLow;
          const isTie = group.length > 1;
          
          group.forEach((bid, index) => {
            const item = document.createElement('div');
            item.className = 'bid-ladder-item';
            
            if (isLeading) {
              item.classList.add('leading');
            }
            if (isTie) {
              item.classList.add('tie');
            }
            if (bid.playerId === currentPlayerId) {
              item.classList.add('you');
            }
            
            const playerName = formatPlayerLabel(bid.playerId);
            const displayName = isTie ? `${playerName} (${index + 1})` : playerName;
            
            item.innerHTML = `
              <span class="bid-ladder-player">${displayName}</span>
              <span class="bid-ladder-value">${value}</span>
            `;
            
            bidLadderListEl.appendChild(item);
          });
        });
      }

      // Demo Mode functions
      function enterDemoMode(demonstratorPlayerId) {
        demoMode = true;
        demoPlayerId = demonstratorPlayerId;
        isDemoPlayer = currentPlayerId === demonstratorPlayerId;
        gameMode = 'demo';
        demoMoves = [];
        demoStep = 0;
        
        updateGameModeUI();
        
        if (isDemoPlayer) {
          showToast('You are demonstrating your solution. Use the board to show your moves.', false);
        } else {
          showToast(`${formatPlayerLabel(demonstratorPlayerId)} is demonstrating their solution.`, false);
        }
      }

      function exitDemoMode() {
        demoMode = false;
        demoPlayerId = null;
        isDemoPlayer = false;
        gameMode = 'bidding';
        demoMoves = [];
        demoStep = 0;
        
        updateGameModeUI();
      }


      function startDemo() {
        if (!isDemoPlayer || demoMode !== 'demo') return;
        
        // Switch to thinking mode to record moves
        gameMode = 'thinking';
        moveHistory = [];
        demoMoves = [];
        updateGameModeUI();
        showToast('Record your moves. Click "End Demo" when finished.', false);
      }

      function endDemo() {
        if (!isDemoPlayer || gameMode !== 'thinking') return;
        
        // Convert move history to demo moves
        demoMoves = [...moveHistory];
        gameMode = 'demo';
        demoStep = 0;
        
        updateGameModeUI();
        
        if (demoMoves.length === 0) {
          showToast('No moves recorded. Try again.', true);
          return;
        }
        
        showToast(`Recorded ${demoMoves.length} moves. Click "Next" to demonstrate.`, false);
      }

      function nextDemoStep() {
        if (!isDemoPlayer || demoStep >= demoMoves.length) return;
        
        const move = demoMoves[demoStep];
        executeMove(move.robot, move.direction, true);
        demoStep++;
        
        updateDemoControls();
        
        if (demoStep >= demoMoves.length) {
          // Check if target was reached
          if (checkTargetReached(move.robot)) {
            showToast('Solution successful! Target reached.', false);
            awardChipToPlayer(demoPlayerId);
          } else {
            showToast('Solution failed. Target not reached.', true);
            // Move to next player in verification queue
            advanceVerificationQueue();
          }
        }
      }

      function prevDemoStep() {
        if (!isDemoPlayer || demoStep <= 0) return;
        
        demoStep--;
        const move = demoMoves[demoStep];
        
        // Undo the move
        const state = robotState[move.robot];
        if (state) {
          state.row = move.from.row;
          state.col = move.from.col;
          renderRobots();
          updateSelectedRobotStyles();
        }
        
        updateDemoControls();
      }

      // Demonstration synchronization functions
      function handleDemonstrationSync(state) {
        console.log(`DEBUG: handleDemonstrationSync called - hasMoves=${!!state.demonstrationMoves}, movesLength=${state.demonstrationMoves?.length || 0}, isSynced=${isSynchronizedDemonstration}`);
        
        // Check if we have demonstration moves from server
        if (state.demonstrationMoves && Array.isArray(state.demonstrationMoves) && state.demonstrationMoves.length > 0) {
          const serverMoveIndex = state.demonstrationCurrentMoveIndex || 0;
          const serverPlayerId = state.demonstrationPlayerId;
          
          console.log(`DEBUG: serverMoves=${state.demonstrationMoves.length}, syncedMoves=${synchronizedMoves.length}, serverPlayer=${serverPlayerId}, syncedPlayer=${synchronizedPlayerId}, serverIndex=${serverMoveIndex}, syncedIndex=${synchronizedMoveIndex}`);
          
          // If this is a new demonstration or different player, start synchronized playback
          if (!isSynchronizedDemonstration || synchronizedPlayerId !== serverPlayerId) {
            console.log(`Starting new synchronized demonstration: player=${serverPlayerId}, moves=${state.demonstrationMoves.length}, currentPlayer=${synchronizedPlayerId}`);
            startSynchronizedDemonstration(state.demonstrationMoves, serverPlayerId, serverMoveIndex);
          } else if (state.demonstrationMoves.length > synchronizedMoves.length) {
            // New moves have been added - play only the new moves
            console.log(`Adding new moves: ${state.demonstrationMoves.length - synchronizedMoves.length} new moves`);
            const newMoves = state.demonstrationMoves.slice(synchronizedMoves.length);
            synchronizedMoves = [...state.demonstrationMoves];
            
            // Clear any existing animation timer and play new moves immediately
            if (demonstrationAnimationTimer) {
              console.log('Clearing existing animation timer to play new moves');
              clearTimeout(demonstrationAnimationTimer);
              demonstrationAnimationTimer = null;
            }
            console.log(`Playing ${newMoves.length} new moves immediately`);
            playNewMovesOnly(newMoves);
          } else if (serverMoveIndex !== synchronizedMoveIndex) {
            // Update to current move index (for catching up)
            console.log(`Updating move index: ${synchronizedMoveIndex} -> ${serverMoveIndex}`);
            updateSynchronizedMoveIndex(serverMoveIndex);
          } else {
            // Same demonstration, same player, no new moves - do nothing
            console.log(`No changes needed for synchronized demonstration: player=${serverPlayerId}, moves=${state.demonstrationMoves.length}, index=${serverMoveIndex}`);
          }
        } else if (isSynchronizedDemonstration) {
          // No more demonstration moves, stop synchronized playback
          console.log('Stopping synchronized demonstration - no more moves');
          stopSynchronizedDemonstration();
        }
      }

      function startSynchronizedDemonstration(moves, playerId, startIndex = 0) {
        // Check if we're already in the same synchronized demonstration
        if (isSynchronizedDemonstration && synchronizedPlayerId === playerId && synchronizedMoves.length === moves.length) {
          console.log(`Already in synchronized demonstration for player ${playerId} with ${moves.length} moves - skipping restart`);
          return;
        }
        
        console.log(`Starting synchronized demonstration for player ${playerId} with ${moves.length} moves`);
        
        synchronizedMoves = [...moves];
        synchronizedPlayerId = playerId;
        synchronizedMoveIndex = startIndex;
        isSynchronizedDemonstration = true;
        
        // For synchronized demonstrations, start from current robot positions
        // (don't reset to round start positions)
        
        // Start playing moves from the current index
        playSynchronizedMovesFromIndex(startIndex);
        
        // Show notification
        showToast(`🎬 Watching ${formatPlayerLabel(playerId)}'s solution demonstration...`, false);
      }

      function updateSynchronizedMoveIndex(newIndex) {
        if (!isSynchronizedDemonstration) return;
        
        // If we're behind, catch up by playing moves
        if (newIndex > synchronizedMoveIndex) {
          playSynchronizedMovesFromIndex(synchronizedMoveIndex);
        }
        
        synchronizedMoveIndex = newIndex;
      }

      function playSynchronizedMovesFromIndex(startIndex) {
        if (!isSynchronizedDemonstration || startIndex >= synchronizedMoves.length) return;
        
        // Clear any existing timer
        if (demonstrationAnimationTimer) {
          clearTimeout(demonstrationAnimationTimer);
          demonstrationAnimationTimer = null;
        }
        
        // Play moves with animation timing
        let currentIndex = startIndex;
        
        function playNextMove() {
          if (currentIndex >= synchronizedMoves.length || !isSynchronizedDemonstration) {
            return;
          }
          
          const move = synchronizedMoves[currentIndex];
          if (move && move.robot && move.direction) {
            // Execute the move with animation
            executeSynchronizedMove(move.robot, move.direction, currentIndex);
            currentIndex++;
            
            // Schedule next move with timing (adjustable animation speed)
            const animationDelay = getAnimationDelay();
            demonstrationAnimationTimer = setTimeout(playNextMove, animationDelay);
          }
        }
        
        playNextMove();
      }

      function playNewMovesOnly(newMoves) {
        console.log(`DEBUG: playNewMovesOnly called with ${newMoves.length} moves, isSynced=${isSynchronizedDemonstration}`);
        
        if (!isSynchronizedDemonstration || newMoves.length === 0) {
          console.log(`DEBUG: playNewMovesOnly early return - isSynced=${isSynchronizedDemonstration}, moves=${newMoves.length}`);
          return;
        }
        
        // If moves are already being played, queue these moves instead
        if (demonstrationAnimationTimer) {
          console.log('Moves already being played, queuing new moves for later');
          queuedNewMoves = [...queuedNewMoves, ...newMoves];
          return;
        }
        
        console.log(`DEBUG: Starting to play ${newMoves.length} new moves`);
        
        // Play only the new moves with animation timing
        let currentIndex = 0;
        
        function playNextNewMove() {
          console.log(`DEBUG: playNextNewMove - currentIndex=${currentIndex}, totalMoves=${newMoves.length}, isSynced=${isSynchronizedDemonstration}`);
          
          if (currentIndex >= newMoves.length || !isSynchronizedDemonstration) {
            console.log(`DEBUG: playNextNewMove finished - currentIndex=${currentIndex}, totalMoves=${newMoves.length}, isSynced=${isSynchronizedDemonstration}`);
            // Check if there are queued moves to play
            if (queuedNewMoves.length > 0) {
              console.log(`Playing ${queuedNewMoves.length} queued moves`);
              const queuedMoves = [...queuedNewMoves];
              queuedNewMoves = [];
              playNewMovesOnly(queuedMoves);
            } else {
              demonstrationAnimationTimer = null;
            }
            return;
          }
          
          const move = newMoves[currentIndex];
          console.log(`DEBUG: Playing move ${currentIndex + 1}:`, move);
          
          if (move && move.robot && move.direction) {
            // Execute the move with animation
            executeSynchronizedMove(move.robot, move.direction, synchronizedMoves.length - newMoves.length + currentIndex);
            currentIndex++;
            
            // Schedule next move with timing (adjustable animation speed)
            const animationDelay = getAnimationDelay();
            console.log(`DEBUG: Scheduling next move in ${animationDelay}ms`);
            demonstrationAnimationTimer = setTimeout(playNextNewMove, animationDelay);
          } else {
            // Invalid move, stop playing
            console.log(`DEBUG: Invalid move, stopping:`, move);
            demonstrationAnimationTimer = null;
          }
        }
        
        playNextNewMove();
      }

      function executeSynchronizedMove(robotName, direction, moveIndex) {
        const state = robotState[robotName];
        if (!state) return false;
        
        const startPos = { row: state.row, col: state.col };
        const endPos = computeSlide(state.row, state.col, direction, robotName);
        
        if (startPos.row === endPos.row && startPos.col === endPos.col) {
          return false; // No movement possible
        }
        
        // Update robot position
        state.row = endPos.row;
        state.col = endPos.col;
        
        // Update synchronized move counter
        synchronizedMoveIndex = moveIndex + 1;
        
        // Update move counter display for all players
        updateSynchronizedMoveCounter(moveIndex + 1);
        
        // Render the move
        renderRobots();
        updateSelectedRobotStyles();
        
        // Check if target was reached
        if (checkTargetReached(robotName)) {
          showToast(`🎉 ${formatPlayerLabel(synchronizedPlayerId)} reached the target!`, false);
        }
        
        return true;
      }

      function updateSynchronizedMoveCounter(moveCount) {
        const moveCounterEl = document.getElementById('move-counter');
        if (moveCounterEl) {
          moveCounterEl.innerHTML = `
            <div style="font-size: 1.2rem; margin-bottom: 0.25rem;">Moves: ${moveCount}</div>
            <div style="font-size: 0.9rem; opacity: 0.9;">${formatPlayerLabel(synchronizedPlayerId)}'s solution</div>
          `;
        }
      }

      function stopSynchronizedDemonstration() {
        console.log('Stopping synchronized demonstration');
        
        isSynchronizedDemonstration = false;
        synchronizedMoves = [];
        synchronizedMoveIndex = 0;
        synchronizedPlayerId = null;
        
        // Clear any existing timer
        if (demonstrationAnimationTimer) {
          clearTimeout(demonstrationAnimationTimer);
          demonstrationAnimationTimer = null;
        }
        
        // Reset move counter
        const moveCounterEl = document.getElementById('move-counter');
        if (moveCounterEl) {
          moveCounterEl.textContent = '';
        }
        
        // Update robot positions to match server state after demonstration ends
        if (lastStateSnapshot && lastStateSnapshot.robotPositions) {
          console.log('Updating robot positions to final server state:', lastStateSnapshot.robotPositions);
          for (const [robotName, position] of Object.entries(lastStateSnapshot.robotPositions)) {
            if (position && typeof position === 'object' && 
                typeof position.row === 'number' && typeof position.col === 'number') {
              robotState[robotName] = { row: position.row, col: position.col };
              console.log(`Set ${robotName} to final position:`, position);
            }
          }
          renderRobots();
          updateSelectedRobotStyles();
        }
      }

      // Animation timing controls
      function getAnimationDelay() {
        // Base delay of 800ms, could be made configurable
        return 800;
      }

      function setAnimationSpeed(speed) {
        // Speed could be 'slow', 'normal', 'fast'
        // This could be implemented with user controls
        console.log(`Animation speed set to: ${speed}`);
      }

      // Move queue and debouncing system
      function queueMoveForServer(move) {
        // Add move to pending queue
        pendingMoves.push(move);
        
        // Clear existing debounce timer
        if (moveDebounceTimer) {
          clearTimeout(moveDebounceTimer);
        }
        
        // Set new debounce timer (100ms delay)
        moveDebounceTimer = setTimeout(() => {
          processPendingMoves();
        }, 100);
      }
      
      function processPendingMoves() {
        if (pendingMoves.length === 0) return;
        
        // Process moves sequentially to prevent race conditions
        const movesToProcess = [...pendingMoves];
        pendingMoves = [];
        
        // Send moves one by one with small delays
        movesToProcess.forEach((move, index) => {
          setTimeout(() => {
            sendMoveToServer(move);
          }, index * 50); // 50ms delay between each move
        });
      }

      // Real-time move synchronization
      function sendMoveToServer(move) {
        if (!currentRoomCode || !currentPlayerId) return;
        
        const url = `/api/rooms/${encodeURIComponent(currentRoomCode)}/demonstration/update`;
        fetch(url, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
          },
          body: JSON.stringify({
            playerId: currentPlayerId,
            move: move,
            moveIndex: moveHistory.length - 1
          })
        })
        .then(response => {
          if (!response.ok) {
            return response.json().then(errorData => {
              throw new Error(`HTTP ${response.status}: ${errorData.error || 'Unknown error'}`);
            });
          }
          return response.json();
        })
        .then(data => {
          console.log('Move sent successfully:', data);
        })
        .catch(error => {
          console.error('Failed to send move:', error);
          
          // If it's a move sequence mismatch, retry with corrected position
          if (error.message.includes('Move sequence mismatch')) {
            console.log('Retrying move with corrected position...');
            // The move will be retried automatically by the queue system
            // The server will provide the correct expected position
          }
        });
      }

      function startDemonstrationSync(playerId) {
        if (!currentRoomCode || !playerId) return;
        
        // Don't call the start API - we'll use update for individual moves
        // The start API expects demonstrationMoves which we don't have yet
        console.log(`Starting demonstration sync for player ${playerId} - will use update API for moves`);
      }

      function stopDemonstrationSync() {
        if (!currentRoomCode) return;
        
        const url = `/api/rooms/${encodeURIComponent(currentRoomCode)}/demonstration/stop`;
        fetch(url, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
          },
          body: JSON.stringify({})
        })
        .then(response => {
          if (!response.ok) {
            console.error('Failed to stop demonstration sync:', response.status);
          }
        })
        .catch(error => {
          console.error('Error stopping demonstration sync:', error);
        });
      }

      // Award and scoreboard functions
      function awardChipToPlayer(playerId) {
        if (!playerId) return;
        
        // Update local player data
        if (playersById[playerId]) {
          playersById[playerId].tokensWon = (playersById[playerId].tokensWon || 0) + 1;
        }
        
        // Show celebration animation
        showCelebrationAnimation();
        
        // Update scoreboard
        updateScoreboard();
        
        // Notify server (this would be handled by the verification system)
        showToast(`${formatPlayerLabel(playerId)} won a chip!`, false);
        
        // End demo mode and move to next round
        setTimeout(() => {
          exitDemoMode();
          // TODO: Trigger next round or move to next verification
        }, 2000);
      }

      function showCelebrationAnimation() {
        // Simple celebration - could be enhanced with confetti, etc.
        const board = document.getElementById('board');
        if (board) {
          board.style.animation = 'celebrate 0.6s ease-in-out';
          setTimeout(() => {
            board.style.animation = '';
          }, 600);
        }
      }

      function updateScoreboard() {
        // Update the leaderboard display
        if (leaderboardEl) {
          leaderboardEl.innerHTML = '';
          const sortedPlayers = Object.values(playersById).sort((a, b) => (b.tokensWon || 0) - (a.tokensWon || 0));
          
          sortedPlayers.forEach(player => {
            const tr = document.createElement('tr');
            
            const nameCell = document.createElement('td');
            let playerName = formatPlayerLabel(player.playerId);
            if (hostPlayerId != null && player.playerId === hostPlayerId) {
              playerName += ' (Host)';
            }
            nameCell.textContent = playerName;
            
            const bidCell = document.createElement('td');
            bidCell.textContent = '—'; // No current bid in scoreboard
            
            const tokensCell = document.createElement('td');
            tokensCell.textContent = player.tokensWon || 0;
            tokensCell.style.fontWeight = 'bold';
            tokensCell.style.color = '#10b981';
            
            tr.appendChild(nameCell);
            tr.appendChild(bidCell);
            tr.appendChild(tokensCell);
            leaderboardEl.appendChild(tr);
          });
        }
      }

      function callVerificationAPI(success) {
        if (!currentRoomCode || !currentPlayerId) {
          showToast('Error: No room or player ID', true);
          return;
        }
        
        const action = success ? 'pass' : 'fail';
        showToast(`Marking verification as ${action}...`, false);
        
        // Call the verification API
        const url = `/api/rooms/${encodeURIComponent(currentRoomCode)}/verify/${action}`;
        
        // Prepare payload with demonstration moves if passing
        const payload = { 
          playerId: currentPlayerId,
          robotPositions: robotState
        };
        
        // Include demonstration moves if this is a successful verification
        if (success && gameMode === 'demonstrating' && moveHistory.length > 0) {
          payload.demonstrationMoves = moveHistory;
        }
        
        fetch(url, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
          },
          body: JSON.stringify(payload)
        })
        .then(response => {
          if (!response.ok) {
            throw new Error(`HTTP ${response.status}: ${response.statusText}`);
          }
          return response.json();
        })
        .then(data => {
          console.log(`Verification ${action} successful:`, data);
          
          if (action === 'pass') {
            if (data.gameWon) {
              showToast(`🏆 GAME OVER! ${formatPlayerLabel(data.winnerPlayerId)} wins! ${data.winReason}`, false);
              endGame(data.winnerPlayerId, data.winReason);
            } else {
              showToast(`🎉 Verification successful! Moving to next puzzle.`, false);
              // Only the host should advance to next puzzle
              if (currentPlayerId === hostPlayerId) {
                advanceToNextPuzzle();
              } else {
                // Non-host players just wait for the host to advance the round
                showToast(`Waiting for host to start next puzzle...`, false);
              }
            }
          } else {
            // Check if this was the last player in the queue
            if (data.queueExhausted || data.currentIndex >= data.queueLength) {
              showToast(`❌ No successful solutions! No one gets the point. Moving to next puzzle.`, true);
              // Only the host should advance to next puzzle
              if (currentPlayerId === hostPlayerId) {
                setTimeout(() => {
                  advanceToNextPuzzle();
                }, 2000);
              } else {
                showToast(`Waiting for host to start next puzzle...`, false);
              }
            } else {
              showToast(`Verification marked as ${action}. Moving to next player.`, false);
            }
          }
        })
        .catch(error => {
          console.error(`Verification ${action} failed:`, error);
          showToast(`Failed to mark verification as ${action}: ${error.message}`, true);
        });
      }

      function advanceVerificationQueue() {
        // This would typically be handled by the server
        // For now, just show a message
        showToast('Moving to next player in verification queue...', false);
        
        // TODO: Call server API to advance verification queue
        // This would trigger the next player's demo mode
      }

      function resetRobotsToRoundStart() {
        // Reset robots to their starting positions for this round
        // This is called when a player fails their demonstration
        if (lastStateSnapshot && lastStateSnapshot.robotPositions) {
          console.log('Resetting robots to round start positions:', lastStateSnapshot.robotPositions);
          
          // Update robot positions from server state
          for (const [robotName, position] of Object.entries(lastStateSnapshot.robotPositions)) {
            if (position && typeof position === 'object' && 
                typeof position.row === 'number' && typeof position.col === 'number') {
              robotState[robotName] = { row: position.row, col: position.col };
              console.log(`Reset ${robotName} to position:`, position);
            }
          }
          
          renderRobots();
          updateSelectedRobotStyles();
          showToast('Robots reset to starting positions', false);
        } else {
          console.warn('No server state available for robot reset');
        }
      }

      function resetGameForNextRound() {
        // Robot positions and targets will be loaded from server state
        // No need to reset them locally
        
        // Reset game state
        exitDemoMode();
        exitThinkingMode();
        
        // Clear any existing state
        moveHistory = [];
        demoMoves = [];
        demoStep = 0;
        
        showToast('New round started!', false);
      }

      // Mobile control functions
      function handleTouchStart(event) {
        if (event.touches.length !== 1) return;
        
        const touch = event.touches[0];
        touchStartX = touch.clientX;
        touchStartY = touch.clientY;
      }

      function handleTouchEnd(event) {
        if (event.changedTouches.length !== 1) return;
        
        const touch = event.changedTouches[0];
        touchEndX = touch.clientX;
        touchEndY = touch.clientY;
        
        handleSwipe();
      }

      function handleSwipe() {
        const deltaX = touchEndX - touchStartX;
        const deltaY = touchEndY - touchStartY;
        const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
        
        if (distance < minSwipeDistance) return;
        
        let direction = null;
        
        if (Math.abs(deltaX) > Math.abs(deltaY)) {
          // Horizontal swipe
          direction = deltaX > 0 ? 'RIGHT' : 'LEFT';
        } else {
          // Vertical swipe
          direction = deltaY > 0 ? 'DOWN' : 'UP';
        }
        
        if (direction) {
          slideSelectedRobot(direction);
        }
      }

      function handleRadialPadClick(event) {
        const target = event.target.closest('.radial-pad-direction');
        if (!target) return;
        
        const direction = target.getAttribute('data-dir');
        if (direction) {
          slideSelectedRobot(direction);
        }
      }

      function initMobileControls() {
        const board = document.getElementById('board');
        const radialPad = document.getElementById('radial-pad');
        
        if (board) {
          board.addEventListener('touchstart', handleTouchStart, { passive: true });
          board.addEventListener('touchend', handleTouchEnd, { passive: true });
        }
        
        if (radialPad) {
          radialPad.addEventListener('click', handleRadialPadClick);
        }
      }

      function slideSelectedRobot(direction) {
        const currentName = ROBOT_ORDER[robotIdx];
        
        // During bidding phase, players cannot move robots - they must solve mentally
        if (gameMode === 'bidding') {
          showToast('Think through your solution mentally, then place your bid!', true);
          return;
        }
        
        if (gameMode === 'demo' && !demoMode) {
          return; // Can't move during demo unless we're the demonstrator
        }
        
        // In thinking mode, allow movement for private sandbox
        if (gameMode === 'thinking') {
          // Allow movement in thinking mode
        }
        
        // In demonstration mode, allow movement and count moves
        if (gameMode === 'demonstrating') {
          // Allow movement and increment counter
        }
        
        executeMove(currentName, direction);
      }

      function handleBoardKeydown(event) {
        if (!boardActive) {
          return;
        }
        if (event.key === 'Escape') {
          if (boardEl) {
            boardEl.blur();
          }
          announcePolite('Exited board focus');
          return;
        }
        if (event.key === 'Tab') {
          event.preventDefault();
          const delta = event.shiftKey ? -1 : 1;
          selectRobotByIndex(robotIdx + delta);
          return;
        }
        if (event.key === ' ') {
          event.preventDefault();
          // Space bar cycles through robots
          selectRobotByIndex(robotIdx + 1);
          return;
        }
        const key = event.key.length === 1 ? event.key.toLowerCase() : event.key;
        const direction = KEY_TO_DIR[key] || KEY_TO_DIR[event.key];
        if (!direction) {
          return;
        }
        event.preventDefault();
        slideSelectedRobot(direction);
        
        // Announce movement
        const currentName = ROBOT_ORDER[robotIdx];
        const state = robotState[currentName];
        if (state) {
          announcePolite(`Moved ${currentName} robot to row ${state.row}, column ${state.col}`);
        }
      }

      function handleArrowClick(event) {
        const target = event.target.closest('button[data-dir]');
        if (!target) {
          return;
        }
        const direction = target.getAttribute('data-dir');
        if (!direction) {
          return;
        }
        slideSelectedRobot(direction);
        if (boardEl) {
          boardEl.focus({ preventScroll: true });
        }
      }

      function placeSymbols() {
        if (!boardGridEl) {
          return;
        }

        // Clear existing symbols
        boardGridEl.querySelectorAll('.emoji-target').forEach(el => el.remove());

        const symbolMap = {
          "D": "♦", // Diamond
          "H": "♥", // Heart
          "C": "♣", // Club
          "S": "♠", // Spade
          "★": "★"  // Star
        };

        const colorMap = {
          "I": "#482878", // Indigo
          "L": "#90d743", // Lime
          "Y": "#fde725", // Yellow
          "C": "#26828e"  // Cyan
        };

        // Place symbols according to the fixed placement map
        Object.values(SYMBOL_POSITIONS).forEach(positions => {
          positions.forEach(position => {
            const cell = boardGridEl.querySelector(`.board-cell[data-row="${position.row}"][data-col="${position.col}"]`);
            
            if (cell && !cell.querySelector('.emoji-target')) {
              const symbolCode = position.symbol;
              
              if (symbolCode === 'QUAD') {
                // Create 4-color square symbol
                const symbolEl = document.createElement('div');
                symbolEl.className = 'emoji-target quad-symbol';
                symbolEl.dataset.row = position.row;
                symbolEl.dataset.col = position.col;
                symbolEl.dataset.symbol = 'QUAD';
                
                // Create 4 small squares
                const colors = ["#482878", "#90d743", "#fde725", "#26828e"]; // I, L, Y, C
                colors.forEach(color => {
                  const square = document.createElement('div');
                  square.className = 'quad-square';
                  square.style.backgroundColor = color;
                  symbolEl.appendChild(square);
                });
                
                cell.appendChild(symbolEl);
              } else {
                // Regular symbol handling
                const shape = symbolCode[0]; // First character (D, H, C, S)
                const color = symbolCode[1]; // Second character (I, L, Y, C)
                
                const symbolEl = document.createElement('span');
                symbolEl.className = 'emoji-target';
                symbolEl.textContent = symbolMap[shape];
                symbolEl.style.color = colorMap[color];
                symbolEl.setAttribute('data-symbol-suit', shape);
                symbolEl.dataset.row = position.row;
                symbolEl.dataset.col = position.col;
                symbolEl.dataset.symbol = symbolCode;
                
                cell.appendChild(symbolEl);
              }
            }
          });
        });
      }

      function setCurrentTarget(symbol) {
        currentTarget = symbol;
        updateTargetDisplay();
        highlightCurrentTarget();
      }

      function updateTargetDisplay() {
        console.log('updateTargetDisplay called, currentTarget:', currentTarget);
        const targetDisplay = document.getElementById('current-target');
        if (!targetDisplay) return;
        
        if (!currentTarget) {
          targetDisplay.innerHTML = '<div class="target-placeholder">No target selected</div>';
          return;
        }
        
        const symbolMap = {
          "D": "♦", "H": "♥", "C": "♣", "S": "♠", "★": "★"
        };
        const colorMap = {
          "I": "#482878", "L": "#90d743", "C": "#26828e", "Y": "#fde725"
        };
        
        if (currentTarget.symbol === 'QUAD') {
          targetDisplay.innerHTML = `
            <div class="target-quad">
              <div class="quad-symbol">
                <div class="quad-square" style="background: #482878;"></div>
                <div class="quad-square" style="background: #90d743;"></div>
                <div class="quad-square" style="background: #fde725;"></div>
                <div class="quad-square" style="background: #26828e;"></div>
              </div>
              <div class="target-label">Any Robot</div>
            </div>
          `;
        } else if (currentTarget.symbol && currentTarget.symbol.length >= 2) {
          const shape = currentTarget.symbol[0];
          const color = currentTarget.symbol[1];
          const robotName = getRobotNameForColor(color);
          const symbolName = getSymbolName(shape);
          targetDisplay.innerHTML = `
            <div class="target-single">
              <span class="target-symbol" style="color: ${colorMap[color]}">${symbolMap[shape]}</span>
              <div class="target-label">${robotName} Robot must reach this ${symbolName}</div>
            </div>
          `;
        } else {
          console.log('Invalid target symbol format:', currentTarget.symbol);
          targetDisplay.innerHTML = '<div class="target-placeholder">Invalid target</div>';
        }
      }

      function getRobotNameForColor(colorCode) {
        const colorMap = {
          "I": "Purple", "L": "Lime", "C": "Cyan", "Y": "Yellow"
        };
        return colorMap[colorCode] || "Unknown";
      }
      
      function getSymbolName(symbol) {
        const symbolMap = {
          'D': 'Diamond',
          'H': 'Heart', 
          'C': 'Club',
          'S': 'Spade',
          '★': 'Star'
        };
        return symbolMap[symbol] || 'Unknown';
      }

      function getRobotNameForTarget(target) {
        if (!target || !target.symbol) return null;
        
        if (target.symbol === 'QUAD') {
          // For QUAD targets, any robot can reach it
          return 'Purple'; // Default to Purple for QUAD
        }
        
        if (target.symbol.length >= 2) {
          const colorCode = target.symbol[1]; // Second character is the color
          return getRobotNameForColor(colorCode);
        }
        
        return null;
      }

      function renderTarget() {
        console.log('renderTarget called, currentTarget:', currentTarget);
        // Update the target display in the UI
        updateTargetDisplay();
        // Highlight the target on the board
        highlightCurrentTarget();
      }

      function highlightCurrentTarget() {
        // Remove existing highlights
        boardGridEl.querySelectorAll('.target-highlight').forEach(el => {
          el.classList.remove('target-highlight');
        });
        
        if (!currentTarget) return;
        
        const cell = boardGridEl.querySelector(`.board-cell[data-row="${currentTarget.row}"][data-col="${currentTarget.col}"]`);
        if (cell) {
          cell.classList.add('target-highlight');
        }
      }

      function selectRandomTarget() {
        // Collect all available symbols
        const allSymbols = [];
        Object.values(SYMBOL_POSITIONS).forEach(positions => {
          positions.forEach(position => {
            allSymbols.push({
              row: position.row,
              col: position.col,
              symbol: position.symbol
            });
          });
        });
        
        if (allSymbols.length === 0) return;
        
        // Select a random target
        const randomIndex = Math.floor(Math.random() * allSymbols.length);
        const selectedSymbol = allSymbols[randomIndex];
        
        setCurrentTarget(selectedSymbol);
      }

      function initBoard() {
        if (boardInitialized) {
          return;
        }
        if (!boardEl || !boardGridEl || !robotLayerEl) {
          return;
        }
        boardInitialized = true;
        if (boardEl.tabIndex < 0) {
          boardEl.tabIndex = 0;
        }
        boardEl.classList.remove('is-focused');
        buildWallData();
        buildBoardGrid();
        placeSymbols();
        
        // Don't initialize robots here - they will be loaded from server state
        // or initialized when the board is first set up
        
        renderRobotBadges();
        renderRobots();
        // Target will be loaded from server state
        initMobileControls();
        boardEl.addEventListener('focus', function () {
          boardActive = true;
          boardEl.classList.add('is-focused');
        });
        boardEl.addEventListener('blur', function () {
          boardActive = false;
          boardEl.classList.remove('is-focused');
        });
        boardEl.addEventListener('mousedown', function () {
          boardEl.focus({ preventScroll: true });
        });
        boardEl.addEventListener('touchstart', function () {
          boardEl.focus({ preventScroll: true });
        }, { passive: true });
        window.addEventListener('keydown', handleBoardKeydown);
        if (arrowControlsEl) {
          arrowControlsEl.addEventListener('click', handleArrowClick);
        }
        updateSelectedRobotStyles();
      }

      function ensureBoardReady() {
        if (!boardInitialized) {
          initBoard();
        }
      }

      if (toastEl) {
        toastEl.addEventListener('click', hideToast);
      }

      // Sandbox control event listeners
      const resetSandboxBtn = document.getElementById('reset-sandbox');
      const undoMoveBtn = document.getElementById('undo-move');
      const exitThinkingBtn = document.getElementById('exit-thinking');

      if (resetSandboxBtn) {
        resetSandboxBtn.addEventListener('click', resetSandbox);
      }

      if (undoMoveBtn) {
        undoMoveBtn.addEventListener('click', undoMove);
      }

      if (exitThinkingBtn) {
        exitThinkingBtn.addEventListener('click', exitThinkingMode);
      }


      async function postJson(url, payload) {
        const res = await fetch(url, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(payload)
        });
        let data = null;
        try {
          data = await res.json();
        } catch (err) {
          data = null;
        }
        if (!res.ok) {
          const message = data && data.error ? data.error : 'Request failed.';
          const error = new Error(message);
          error.status = res.status;
          throw error;
        }
        return data || {};
      }

      async function ensureRoomCreated(code) {
        const normalized = normalizeRoomCode(code);
        if (!normalized || !ROOM_CODE_PATTERN.test(normalized) || DOUBLE_HYPHEN_PATTERN.test(normalized)) {
          throw new Error('Room code is required.');
        }
        const res = await fetch(`/api/rooms/${encodeURIComponent(normalized)}/create`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({})
        });
        let data = null;
        try {
          data = await res.json();
        } catch (err) {
          data = null;
        }
        if (res.ok) {
          return data && data.message ? data.message : '';
        }
        if (res.status === 409) {
          return data && data.error ? data.error : '';
        }
        const errorText = data && data.error ? data.error : 'Unable to create room.';
        const error = new Error(errorText);
        error.status = res.status;
        throw error;
      }

      async function joinRoomOnServer(code, displayName, color) {
        const normalized = normalizeRoomCode(code);
        if (!normalized || !ROOM_CODE_PATTERN.test(normalized) || DOUBLE_HYPHEN_PATTERN.test(normalized)) {
          throw new Error('Room code is required.');
        }
        const url = `/api/rooms/${encodeURIComponent(normalized)}/players/join`;
        try {
          return await postJson(url, { displayName: displayName, color: color });
        } catch (err) {
          if (err && err.status === 404) {
            await ensureRoomCreated(normalized);
            return await postJson(url, { displayName: displayName, color: color });
          }
          throw err;
        }
      }

      async function updatePlayerOnServer(code, playerId, displayName, color) {
        const normalized = normalizeRoomCode(code);
        if (!normalized || !ROOM_CODE_PATTERN.test(normalized) || DOUBLE_HYPHEN_PATTERN.test(normalized)) {
          throw new Error('Room code is required.');
        }
        const body = { playerId: Number(playerId) };
        if (typeof displayName === 'string') {
          body.displayName = displayName;
        }
        if (typeof color === 'string') {
          body.color = color;
        }
        return await postJson(`/api/rooms/${encodeURIComponent(normalized)}/players/update`, body);
      }

      async function joinOrUpdatePlayer(code, displayName, color) {
        const normalized = normalizeRoomCode(code);
        if (!normalized || !ROOM_CODE_PATTERN.test(normalized) || DOUBLE_HYPHEN_PATTERN.test(normalized)) {
          throw new Error('Enter a valid room code.');
        }
        const trimmedName = displayName.trim();
        if (!trimmedName) {
          throw new Error('Display name is required.');
        }
        const canonicalColor = 'Purple'; // Default color

        if (currentPlayerId) {
          try {
            return await updatePlayerOnServer(normalized, currentPlayerId, trimmedName, canonicalColor);
          } catch (err) {
            if (!err || err.status !== 404) {
              throw err;
            }
            currentPlayerId = null;
          }
        }

        const stored = storedPlayerInfo && storedPlayerInfo.playerId ? storedPlayerInfo : loadStoredPlayer(normalized);
        if (stored && stored.playerId) {
          try {
            const updated = await updatePlayerOnServer(normalized, stored.playerId, trimmedName, canonicalColor);
            return updated;
          } catch (err) {
            if (!err || err.status !== 404) {
              throw err;
            }
            clearStoredPlayer(normalized);
          }
        }

        return await joinRoomOnServer(normalized, trimmedName, canonicalColor);
      }

      async function claimHostOnServer(code, playerId) {
        const normalized = normalizeRoomCode(code);
        if (!normalized || !ROOM_CODE_PATTERN.test(normalized) || DOUBLE_HYPHEN_PATTERN.test(normalized)) {
          throw new Error('Room code is required.');
        }
        return await postJson(`/api/rooms/${encodeURIComponent(normalized)}/players/claim-host`, { playerId: Number(playerId) });
      }

      // Event listeners for demonstration controls
      const submitSolutionButton = document.getElementById('submit-solution');
      const giveUpButton = document.getElementById('give-up');
      
      if (submitSolutionButton) {
        submitSolutionButton.addEventListener('click', function() {
          if (gameMode === 'demonstrating') {
            // Determine which robot should reach the target based on the target's color
            const targetRobot = getRobotNameForTarget(currentTarget);
            const targetReached = checkTargetReached(targetRobot);
            endDemonstration(targetReached, currentPlayerId, currentPlayerBid);
          }
        });
      }
      
      if (giveUpButton) {
        giveUpButton.addEventListener('click', function() {
          if (gameMode === 'demonstrating') {
            endDemonstration(false, currentPlayerId, currentPlayerBid);
          }
        });
      }

    }());
  </script>
</body>
</html>
