<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Ricochet Robot Bidding Demo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <style>
    body { font-family: system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif; margin: 2rem; background: #f7f7f7; }
    h1 { margin-bottom: 0.5rem; }
    fieldset { border: 1px solid #ccc; padding: 1rem; margin-bottom: 1.5rem; background: #fff; }
    label { display: block; margin-bottom: 0.5rem; }
    input, select, button { padding: 0.5rem; font-size: 1rem; }
    .status { font-size: 1.25rem; margin: 0.5rem 0; }
    .timer { font-size: 2rem; font-weight: bold; }
    ul { padding-left: 1.5rem; }
    .columns { display: flex; flex-wrap: wrap; gap: 1.5rem; }
    .columns > div { flex: 1 1 250px; }
    table { width: 100%; border-collapse: collapse; }
    th, td { border: 1px solid #ddd; padding: 0.5rem; text-align: left; }
    .error { color: #b00020; }
    .message { margin-left: 1rem; font-size: 0.9rem; color: #333; }
    .message.error { color: #b00020; }
    .leading-panel { margin-top: 0.75rem; padding: 0.75rem; background: #e9f5ff; border: 1px solid #9cc9f1; border-radius: 4px; }
    .leading-panel strong { font-weight: 600; }
    #bids { list-style: none; padding-left: 0; }
    #bids li { margin-bottom: 0.35rem; padding: 0.35rem 0.5rem; border-radius: 4px; background: #fff; border: 1px solid #eee; }
    #bids li.bid-tie { border-color: #c5d6f2; background: #f2f6ff; font-weight: 600; }
    #bids li.bid-leading { border-color: #58a55c; background: #e6f6e6; color: #1f6e25; }
    .verifying-panel { margin-top: 1rem; padding: 0.75rem; background: #fff4e5; border: 1px solid #f5c48b; border-radius: 4px; }
    .verifying-panel h3 { margin: 0 0 0.5rem; font-size: 1.1rem; }
    #verifying-current { font-weight: 600; margin-bottom: 0.5rem; }
    #verifying-queue { list-style: decimal inside; padding-left: 1rem; margin: 0; }
    #verifying-queue li { padding: 0.25rem 0; }
    #verifying-queue li.current { font-weight: 700; color: #a05a00; }
    #verifying-queue li.empty { list-style: none; font-style: italic; color: #555; }
    .verify-buttons { margin-top: 0.75rem; display: flex; flex-wrap: wrap; gap: 0.5rem; align-items: center; }
  </style>
  <script src="js/polling.js" defer></script>
</head>
<body>
  <h1>Ricochet Robot Bidding Demo</h1>
  <p>Use this page to experiment with the server-authoritative bidding timer. Join the same room code in two tabs to observe live updates.</p>

  <fieldset>
    <legend>Join Room</legend>
    <form id="join-form">
      <label>
        Room code
        <input id="room-code" type="text" required minlength="1" maxlength="12" autocomplete="off">
      </label>
      <label>
        Player ID
        <input id="player-id" type="number" required min="1" step="1">
      </label>
      <label>
        Player Name (optional)
        <input id="player-name" type="text" maxlength="32" autocomplete="off">
      </label>
      <label>
        Polling mode
        <select id="polling-mode">
          <option value="adaptive">Adaptive short polling</option>
          <option value="long">Long polling</option>
        </select>
      </label>
      <button type="submit">Create / Connect</button>
      <span id="join-message" class="message" aria-live="polite"></span>
    </form>
  </fieldset>

  <fieldset>
    <legend>Current Round</legend>
    <div class="status">
      Status: <span id="status">—</span> (state version <span id="state-version">0</span>)
    </div>
    <div class="timer">
      Time Remaining: <span id="remaining">—</span>
    </div>
    <div>
      Lowest Bid: <span id="low-bid">—</span>
      <span id="low-bidder"></span>
    </div>
    <div id="leading-info" class="leading-panel" hidden>
      <strong>Leading:</strong>
      <span id="leading-text"></span>
    </div>
    <div id="verifying-container" class="verifying-panel" hidden>
      <h3>Verification Queue</h3>
      <div id="verifying-current">Current: —</div>
      <ol id="verifying-queue"></ol>
      <div class="verify-buttons">
        <button type="button" id="verify-pass">Pass</button>
        <button type="button" id="verify-fail">Fail</button>
        <span id="verify-message" class="message" aria-live="polite"></span>
      </div>
    </div>
  </fieldset>

  <div class="columns">
    <div>
      <h2>Recent Bids</h2>
      <ul id="bids"></ul>
    </div>
    <div>
      <h2>Leaderboard</h2>
      <table>
        <thead>
          <tr>
            <th>Player</th>
            <th>Tokens</th>
          </tr>
        </thead>
        <tbody id="leaderboard"></tbody>
      </table>
    </div>
  </div>

  <fieldset>
    <legend>Submit Bid</legend>
    <form id="bid-form">
      <label>
        Bid value
        <input id="bid-value" type="number" min="1" step="1" required>
      </label>
      <button type="submit">Submit Bid</button>
      <span id="bid-message" class="message" aria-live="polite"></span>
    </form>
  </fieldset>

  <script>
    (function () {
      const joinForm = document.getElementById('join-form');
      const bidForm = document.getElementById('bid-form');
      const roomCodeInput = document.getElementById('room-code');
      const playerIdInput = document.getElementById('player-id');
      const playerNameInput = document.getElementById('player-name');
      const pollingModeInput = document.getElementById('polling-mode');
      const joinMessage = document.getElementById('join-message');
      const bidMessage = document.getElementById('bid-message');
      const joinButton = joinForm.querySelector('button[type="submit"]');
      const bidButton = bidForm.querySelector('button[type="submit"]');
      const bidValueInput = document.getElementById('bid-value');

      const statusEl = document.getElementById('status');
      const versionEl = document.getElementById('state-version');
      const remainingEl = document.getElementById('remaining');
      const lowBidEl = document.getElementById('low-bid');
      const lowBidderEl = document.getElementById('low-bidder');
      const leadingPanel = document.getElementById('leading-info');
      const leadingText = document.getElementById('leading-text');
      const bidsEl = document.getElementById('bids');
      const leaderboardEl = document.getElementById('leaderboard');
      const verifyingContainer = document.getElementById('verifying-container');
      const verifyingCurrent = document.getElementById('verifying-current');
      const verifyingQueueList = document.getElementById('verifying-queue');
      const verifyPassButton = document.getElementById('verify-pass');
      const verifyFailButton = document.getElementById('verify-fail');
      const verifyMessage = document.getElementById('verify-message');

      let poller = null;
      let currentRoomCode = null;
      let currentPlayerId = null;
      let lastServerRemaining = null;
      let lastServerTimestamp = null;
      let serverSkewMs = 0;
      let hasServerSkew = false;
      let countdownTimerId = null;
      let bidAllowed = false;
      let bidInFlight = false;
      let lastVerifyingState = null;
      let verifyInFlight = false;

      function setMessage(element, text, isError) {
        if (!element) {
          return;
        }
        element.textContent = text || '';
        if (isError) {
          element.classList.add('error');
        } else {
          element.classList.remove('error');
        }
      }

      function updateBidFormState() {
        const inputEnabled = bidAllowed && !bidInFlight;
        bidValueInput.disabled = !inputEnabled;
        bidButton.disabled = !bidAllowed || bidInFlight;
      }

      function setBidFormEnabled(enabled) {
        bidAllowed = Boolean(enabled);
        updateBidFormState();
      }

      function getCurrentVerifier() {
        if (!lastVerifyingState || !Array.isArray(lastVerifyingState.queue)) {
          return null;
        }

        const index = Number.isInteger(lastVerifyingState.currentIndex)
          ? lastVerifyingState.currentIndex
          : 0;

        if (index < 0) {
          return null;
        }

        return lastVerifyingState.queue[index] || null;
      }

      function updateVerifyButtons() {
        const currentEntry = getCurrentVerifier();
        const enabled = Boolean(currentRoomCode && currentEntry && !verifyInFlight);
        verifyPassButton.disabled = !enabled;
        verifyFailButton.disabled = !enabled;
      }

      function stopCountdownTicker() {
        if (countdownTimerId != null) {
          clearInterval(countdownTimerId);
          countdownTimerId = null;
        }
      }

      function updateCountdownDisplay() {
        const remaining = estimateRemaining();
        if (remaining == null) {
          remainingEl.textContent = '—';
          return;
        }
        remainingEl.textContent = formatSeconds(remaining);
        if (remaining <= 0) {
          stopCountdownTicker();
        }
      }

      function startCountdownTicker() {
        updateCountdownDisplay();
        if (countdownTimerId == null) {
          countdownTimerId = setInterval(updateCountdownDisplay, 250);
        }
      }

      function formatSeconds(seconds) {
        if (seconds == null) {
          return '—';
        }
        const s = Math.max(0, Math.floor(seconds));
        const mins = Math.floor(s / 60);
        const secs = s % 60;
        return mins > 0 ? `${mins}:${secs.toString().padStart(2, '0')}` : `${secs}`;
      }

      function renderAll(state) {
        statusEl.textContent = state.status;
        versionEl.textContent = state.stateVersion;
        lowBidEl.textContent = state.currentLow != null ? state.currentLow : '—';
        lowBidderEl.textContent = state.currentLowBy != null ? `(by ${state.currentLowBy})` : '';

        const currentLow = state.currentLow;
        const leader = state.currentLeader;
        const ties = Array.isArray(state.tiesAtCurrentLow) ? state.tiesAtCurrentLow : [];
        const tieCount = ties.length;

        bidsEl.innerHTML = '';
        let leaderMarked = false;
        (state.bids || []).forEach(function (bid) {
          const li = document.createElement('li');
          const when = bid.createdAt ? new Date(bid.createdAt).toLocaleTimeString() : '—';
          let text = `Player ${bid.playerId} bid ${bid.value} @ ${when}`;

          if (currentLow != null && bid.value === currentLow) {
            li.classList.add('bid-tie');
            if (leader && !leaderMarked && leader.playerId === bid.playerId && leader.value === bid.value) {
              li.classList.add('bid-leading');
              text += ' (leading)';
              leaderMarked = true;
            } else if (tieCount > 1) {
              text += ' (tied)';
            }
          }

          li.textContent = text;
          bidsEl.appendChild(li);
        });

        leaderboardEl.innerHTML = '';
        (state.leaderboard || []).forEach(function (row) {
          const tr = document.createElement('tr');
          const nameCell = document.createElement('td');
          nameCell.textContent = row.name ? `${row.name} (${row.playerId})` : row.playerId;
          const tokensCell = document.createElement('td');
          let tokensValue = null;
          if (Number.isFinite(row.tokensWon)) {
            tokensValue = row.tokensWon;
          } else if (Number.isFinite(row.points)) {
            tokensValue = row.points;
          }
          tokensCell.textContent = tokensValue != null ? tokensValue : '0';
          tr.appendChild(nameCell);
          tr.appendChild(tokensCell);
          leaderboardEl.appendChild(tr);
        });

        let verifyingState = null;
        if (state.status === 'verifying' && state.verifying && Array.isArray(state.verifying.queue)) {
          const queueCopy = state.verifying.queue.map(function (entry) {
            return {
              playerId: entry.playerId,
              value: entry.value,
              tokensWon: entry.tokensWon,
              createdAt: entry.createdAt
            };
          });
          const currentIndex = Number.isInteger(state.verifying.currentIndex) ? state.verifying.currentIndex : 0;
          verifyingState = { queue: queueCopy, currentIndex: currentIndex };
        }

        lastVerifyingState = verifyingState;

        if (verifyingState) {
          verifyingContainer.hidden = false;
          verifyingQueueList.innerHTML = '';
          const queue = verifyingState.queue;
          const currentIndex = verifyingState.currentIndex >= 0 ? verifyingState.currentIndex : 0;

          if (queue.length === 0) {
            const emptyLi = document.createElement('li');
            emptyLi.textContent = 'No bids awaiting verification.';
            emptyLi.classList.add('empty');
            verifyingQueueList.appendChild(emptyLi);
          } else {
            queue.forEach(function (entry, index) {
              const li = document.createElement('li');
              const valueText = entry.value != null ? entry.value : '—';
              const tokensText = entry.tokensWon != null ? ` (tokens ${entry.tokensWon})` : '';
              li.textContent = `Player ${entry.playerId} @ ${valueText}${tokensText}`;
              if (index === currentIndex) {
                li.classList.add('current');
              }
              verifyingQueueList.appendChild(li);
            });
          }

          const currentEntry = getCurrentVerifier();
          if (currentEntry) {
            const valueText = currentEntry.value != null ? currentEntry.value : '—';
            const tokensText = currentEntry.tokensWon != null ? ` (tokens ${currentEntry.tokensWon})` : '';
            verifyingCurrent.textContent = `Current: Player ${currentEntry.playerId} @ ${valueText}${tokensText}`;
          } else {
            verifyingCurrent.textContent = 'Current: —';
          }

          updateVerifyButtons();
        } else {
          verifyingContainer.hidden = true;
          verifyingQueueList.innerHTML = '';
          verifyingCurrent.textContent = 'Current: —';
          lastVerifyingState = null;
          verifyInFlight = false;
          updateVerifyButtons();
          setMessage(verifyMessage, '', false);
        }

        if (leader && leader.playerId != null && leader.value != null) {
          const reason = leader.leaderReason || {};
          let reasonText = '';
          if (reason.kind === 'fewer_tokens') {
            const leaderTokens = Number.isFinite(reason.leaderTokens) ? reason.leaderTokens : leader.tokensWon;
            const otherTokens = Number.isFinite(reason.otherBestTokens) ? reason.otherBestTokens : undefined;
            const otherPart = otherTokens != null ? ` vs ${otherTokens}` : '';
            reasonText = `fewer tokens: ${leaderTokens != null ? leaderTokens : '—'}${otherPart}`;
          } else if (reason.kind === 'earlier_bid') {
            let timeText = '';
            if (reason.leaderCreatedAt) {
              const parsed = Date.parse(reason.leaderCreatedAt);
              if (!Number.isNaN(parsed)) {
                timeText = new Date(parsed).toLocaleTimeString();
              }
            }
            const leaderTokens = Number.isFinite(reason.leaderTokens) ? reason.leaderTokens : leader.tokensWon;
            const otherTokens = Number.isFinite(reason.otherBestTokens) ? reason.otherBestTokens : undefined;
            const tokenPart = leaderTokens != null && otherTokens != null ? ` (tokens ${leaderTokens} vs ${otherTokens})` : '';
            reasonText = timeText ? `earlier bid at ${timeText}${tokenPart}` : `earlier bid${tokenPart}`;
          } else if (reason.kind === 'new_low') {
            const leaderTokens = Number.isFinite(reason.leaderTokens) ? reason.leaderTokens : leader.tokensWon;
            reasonText = leaderTokens != null ? `new low bid (tokens ${leaderTokens})` : 'new low bid';
          }

          const baseText = `Player ${leader.playerId} @ ${leader.value}`;
          leadingText.textContent = reasonText ? `${baseText} (reason: ${reasonText})` : baseText;
          leadingPanel.hidden = false;
        } else {
          leadingPanel.hidden = true;
          leadingText.textContent = '';
        }

        lastServerRemaining = typeof state.remaining === 'number' ? state.remaining : null;
        const parsedServerNow = state.serverNow ? Date.parse(state.serverNow) : NaN;
        if (!Number.isNaN(parsedServerNow)) {
          lastServerTimestamp = parsedServerNow;
          if (!hasServerSkew) {
            serverSkewMs = parsedServerNow - Date.now();
            hasServerSkew = true;
          }
        } else {
          lastServerTimestamp = null;
          hasServerSkew = false;
        }

        if (lastServerRemaining == null || !hasServerSkew) {
          stopCountdownTicker();
          remainingEl.textContent = '—';
        } else {
          startCountdownTicker();
        }

        const biddingOpen = state.status === 'bidding' || state.status === 'countdown';
        setBidFormEnabled(Boolean(currentRoomCode && currentPlayerId && biddingOpen));
      }

      function estimateRemaining() {
        if (lastServerRemaining == null || lastServerTimestamp == null) {
          return null;
        }
        const serverNow = Date.now() + (hasServerSkew ? serverSkewMs : 0);
        const elapsed = Math.floor((serverNow - lastServerTimestamp) / 1000);
        return Math.max(0, lastServerRemaining - elapsed);
      }

      joinForm.addEventListener('submit', function (event) {
        event.preventDefault();
        if (!window.PollingHelpers) {
          setMessage(joinMessage, 'Helpers not loaded yet. Please retry.', true);
          return;
        }

        const code = roomCodeInput.value.trim();
        const player = Number(playerIdInput.value);
        const playerName = playerNameInput.value.trim();
        const mode = pollingModeInput.value;

        if (!code || !Number.isFinite(player) || player <= 0) {
          setMessage(joinMessage, 'Enter a room code and player id.', true);
          return;
        }

        setMessage(joinMessage, '', false);
        currentRoomCode = code;
        currentPlayerId = player;
        setMessage(bidMessage, '', false);

        if (poller && typeof poller.stop === 'function') {
          poller.stop();
        }
        poller = null;

        lastServerRemaining = null;
        lastServerTimestamp = null;
        serverSkewMs = 0;
        hasServerSkew = false;
        stopCountdownTicker();
        setBidFormEnabled(false);

        joinButton.disabled = true;

        (async function connect() {
          try {
            const note = await ensureRoomExists(currentRoomCode, playerName);
            let messagePrefix = note ? `${note.trim()} ` : '';

            if (mode === 'long') {
              poller = window.PollingHelpers.createLongPoller({
                code: currentRoomCode,
                renderAll: renderAll
              });
            } else {
              poller = window.PollingHelpers.createAdaptivePoller({
                code: currentRoomCode,
                renderAll: renderAll,
                getRemainingFromUI: estimateRemaining
              });
            }

            const startResult = poller.start();
            if (startResult && typeof startResult.then === 'function') {
              await startResult;
            }

            setMessage(joinMessage, `${messagePrefix}Connected to room ${currentRoomCode}.`.trim(), false);
          } catch (err) {
            console.error(err);
            setMessage(joinMessage, err && err.message ? err.message : 'Unable to connect to the room.', true);
            currentRoomCode = null;
            currentPlayerId = null;
            if (poller && typeof poller.stop === 'function') {
              poller.stop();
            }
            poller = null;
            setBidFormEnabled(false);
          } finally {
            joinButton.disabled = false;
          }
        }());
      });

      bidForm.addEventListener('submit', function (event) {
        event.preventDefault();
        setMessage(bidMessage, '', false);

        if (!currentRoomCode || !currentPlayerId) {
          setMessage(bidMessage, 'Join a room first.', true);
          return;
        }

        const value = Number(bidValueInput.value);
        if (!Number.isFinite(value) || value <= 0) {
          setMessage(bidMessage, 'Enter a positive bid value.', true);
          return;
        }

        bidInFlight = true;
        updateBidFormState();
        window.PollingHelpers.submitBid(currentRoomCode, currentPlayerId, value).then(function () {
          bidValueInput.value = '';
        }).catch(function (err) {
          console.error(err);
          const message = err && err.message ? err.message : 'Bid failed.';
          setMessage(bidMessage, message, true);
          if (message.toLowerCase().includes('bidding is closed')) {
            setBidFormEnabled(false);
          }
        }).finally(function () {
          bidInFlight = false;
          updateBidFormState();
        });
      });

      setBidFormEnabled(false);
      setMessage(verifyMessage, '', false);
      updateVerifyButtons();

      verifyPassButton.addEventListener('click', function () {
        if (!currentRoomCode) {
          setMessage(verifyMessage, 'Join a room first.', true);
          return;
        }

        const currentEntry = getCurrentVerifier();
        if (!currentEntry) {
          setMessage(verifyMessage, 'No verifier available.', true);
          return;
        }

        verifyInFlight = true;
        updateVerifyButtons();
        setMessage(verifyMessage, '', false);

        window.PollingHelpers.verifyPass(currentRoomCode, currentEntry.playerId).then(function () {
          setMessage(verifyMessage, 'Marked as solved.', false);
        }).catch(function (err) {
          console.error(err);
          const message = err && err.message ? err.message : 'Verification update failed.';
          setMessage(verifyMessage, message, true);
        }).finally(function () {
          verifyInFlight = false;
          updateVerifyButtons();
        });
      });

      verifyFailButton.addEventListener('click', function () {
        if (!currentRoomCode) {
          setMessage(verifyMessage, 'Join a room first.', true);
          return;
        }

        const currentEntry = getCurrentVerifier();
        if (!currentEntry) {
          setMessage(verifyMessage, 'No verifier available.', true);
          return;
        }

        verifyInFlight = true;
        updateVerifyButtons();
        setMessage(verifyMessage, '', false);

        window.PollingHelpers.verifyFail(currentRoomCode, currentEntry.playerId).then(function () {
          setMessage(verifyMessage, 'Advanced to next verifier.', false);
        }).catch(function (err) {
          console.error(err);
          const message = err && err.message ? err.message : 'Verification update failed.';
          setMessage(verifyMessage, message, true);
        }).finally(function () {
          verifyInFlight = false;
          updateVerifyButtons();
        });
      });

      async function ensureRoomExists(code, hostName) {
        const payload = hostName ? { hostPlayerName: hostName } : {};
        const res = await fetch(`/api/rooms/${encodeURIComponent(code)}/create`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(payload)
        });
        let data = null;
        try {
          data = await res.json();
        } catch (err) {
          data = null;
        }

        if (res.ok) {
          return data && data.message ? data.message : '';
        }

        if (res.status === 409) {
          return data && data.error ? data.error : 'Room already exists; joining…';
        }

        const errorText = data && data.error ? data.error : 'Unable to create room.';
        throw new Error(errorText);
      }
    }());
  </script>
</body>
</html>
